<!doctype html>
<html lang="en-us">
  <head>
    <title>操作系统——引论 // Zereal-宋致远技术博客</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.72.0" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75，minimum-scale=0.75, maximum-scale=0.75, user-scalable=no" />
    <meta name="author" content="Zereal" />
    <meta name="description" content="" />
    <meta name="referrer" content="never"/>
    <link rel="stylesheet" href="https://zereals7.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="操作系统——引论"/>
<meta name="twitter:description" content="完全基于《现代操作系统》第四版，摘取精华，掺杂个人理解。适用于自学党，和想要系统学习操作系统的人。
一、引论 1.为什么要有操作系统？操作系统的任务是什么？ 需求：现代计算机系统的组成极为复杂（处理器，主存，磁盘，输入输出设备&hellip;）,应用程序员没有精力去掌握系统的所有细节。而且，管理这些部件并加以使用，是一件挑战性极强的工作。
所以计算机需要安装一层软件——操作系统。来满足这些需求。（注意：操作系统是系统软件，非应用软件）
任务：为用户程序提供一个更好、更简单、更清晰的计算机模型（操作系统）来实现对计算机所有设备的管理。
一言以蔽之，就是封装硬件运行和管理的细节，服务于上层的应用程序。
抽象是管理复杂性的一个关键，操作系统的任务就是创建好的抽象，并实现和管理它所创建的抽象对象。隐藏硬件，呈现给程序以及程序员良好/清晰/优雅/一致的抽象。
2.用户与操作系统交互的方式——用户接口程序 1.基于文本的——shell（命令行）
2.基于图标的——GUI（图形用户接口）
它们都属于用户接口程序，处于用户态程序中的最低层次。用户可以通过它们运行其他程序，如Web浏览器/音乐播放器等，这些程序也在大量使用操作系统。
3.操作系统内核态和用户态的区别 软件的最基础部分——操作系统，运行在内核态（也称管态，核心态）。核心态下，操作系统具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令。（为所欲为）
所以是有危险性的。
所以在用户态下，只使用了一部分机器指令，尤其是那些影响机器控制以及和IO操作有关系的指令，在用户态中的程序是禁止的。
4.操作系统所处的位置 由底层向上：硬件（裸机）——操作系统（软件，运行在内核态）——用户接口程序（软件，属于用户态最底层，靠近操作系统）——应用程序（软件，用户态）
总之，操作系统运行在裸机（纯硬件）之上，为其他所有软件提供基础的运行环境。
与普通软件的区别：操作系统软件不能被修改，受硬件保护，防止用户试图对其进行修改。
然而，在嵌入式系统（没有内核态）或解释系统（如基于Java的操作系统，它采用解释方式而非硬件方式区分组件）中，上述区别是模糊的。
操作系统一般比用户程序大型，复杂和长寿。（Linux和Windows内核源码都超过了500万行）
5.操作系统的实际用户——应用程序 应用程序直接与操作系统及其抽象打交道，而用户与用户接口所提供的抽象打交道（命令行shell或GUI）。虽然用户接口不同，但是操作系统下面的抽象是相同的。
6.操作系统是资源管理者——把潜在的混乱有序化 资源管理多路复用资源：在时间（CPU时间片）和空间（分割内存）上复用。
操作系统会分配CPU和内存，并协调管理使其有序，以提高运行的效率。
7.操作系统的历史 第一代：真空管和穿孔卡片 ——第二代：晶体管和批处理系统——第三代：集成电路和多道程序设计——第四代：个人计算机——第五代：移动计算机
8.处理器基础知识 CPU是计算机的大脑，它从内存中取出指令并且执行之。
三大流程：取指（从内存中）/解码（确定其类型和操作数）/执行
每个CPU都有特有的指令集，所以x86不能执行ARM程序，反之亦然。而且访存取指的时间比执行指令花费的时间长得多。因此。所有CPU的内部都有一些用来保存关键变量和临时数据的寄存器。
8.1 CPU中的寄存器介绍 除了用来保存变量和临时结果的通用寄存器外，还有一些程序员可见的专用寄存器。其中之一是程序计数器，它保存了将要取出的下一条指令的内存地址。
在取完指令后，程序计数器被更新以指向后继的指令。
另一个寄存器是堆栈指针，它指向内存中当前栈的顶端。该栈包含了每个执行过程的栈帧。一个过程的栈帧中保存了有关的输入参数、局部变量以及那些没有保存在寄存器中的临时变量。
当然还有程序状态字(PSW)寄存器。这个寄存器包含了条件码位、CPU优先级、模式（用户态或内核态），以及各种其他控制位。用户程序通常读入整个PSW，但是只对其中少量字段写入。在系统调用和I/O中，PSW的作用很重要。
操作系统必须知晓所有的寄存器。在时间多路复用CPU中，操作系统经常会中止正在运行的某个程序并再启动另一个程序，每次停止一个正在运行着的程序时，操作系统必须保存所有的寄存器值。这样在稍后该程序被再次运行时，可以把这些寄存器重新装入。
为了改善性能，现代CPU有同时取出多条指令的机制。例如，一个CPU可以有单独的取指单元、解码单元和执行单元，于是当它执行指令N时，可以对指令N&#43;1进行解码，并且可以在内存读取指令N&#43;2。这样的机制称为流水线。
一旦一条指令被取进流水线中，它就必须被执行完毕，即便前一条取出的指令是条件转移，它也必须被执行完毕。
还有更先进的**超标量CPU，有多个取指，解码，执行单元。**只要有一个执行单元空闲，就检查保持缓冲区中是否还有可处理的指令，如果有就把指令从缓冲区中移出并执行之。这种设计程序的指令经常不按顺序执行。多数情况下，硬件负责保证这种运算的结果与顺序执行指令时的结果相同，但是，仍然有部分令人烦恼的复杂情形被强加给操作系统处理（暂不讨论）。
在PSW中有一个二进制位控制CPU的内核态和用户态两种模式。内核态中运行的CPU可以执行指令集中的每一条指令，并且使用硬件的每种功能。值得一提的是，在台式机和服务器中，操作系统在内核态下运行，而在大多数嵌入式系统中，一部分操作系统运行在内核态，其余部分则运行在用户态。
相反**，用户程序在用户态下运行，仅允许执行指令集的一个子集和访问所有功能的一个子集**。一般而言，在用户态中有关IO和内存保护的所有指令是禁止的。当然，将PSW中的模式位设置成内核态也是禁止的。
为了从操作系统中获得服务，用户程序必须使用系统调用以陷入内核并调用操作系统。
只有TRAP指令能把用户态切换成内核态，并启用操作系统。在有关工作完成后，系统调用后面的指令把控制权返还给用户程序。
8.2 多线程和多核芯片 多线程允许CPU保持两个不同的线程状态，然后在纳秒级的时间尺度内来回切换。多线程不提供真正的并行处理。在同一时刻只有一个进程在运行，但是线程的切换时间则减少到纳秒数量级。
**GPU擅长处理大量并行的简单计算，比如在图像应用中渲染多边形。它们不太能胜任串行任务，并且很难编程。**虽然GPU对操作系统很有用（比如加密或者处理网络传输） ，但操作系统本身不太可能运行在GPU上。
8.3存储器 速度由快到慢：寄存器——高速缓存（Cache）——主存（RAM）——磁盘。每位成本也是由高到低。
缓存有利于改善性能。RAM具有电易失性，ROM则非易失。此外ROM速度快且便宜，用于启动计算机的引导加载模块就存放在ROM中。另外，一些I/O卡也采用ROM处理底层设备控制。
EEPROM和闪存也是非易失性的，与ROM相反，他们可以擦除和重写。不过重写比写入RAM要更高数量级的时间。
闪存速度介于RAM和磁盘之间。另外，与磁盘存储器不同，如果闪存擦除的次数过多，就被磨损了。
还有一类存储器是CMOS，它是易失性的。许多计算机利用CMOS存储器保持当前时间和日期。CMOS存储器和递增时间的时钟电路由一块小电池驱动，即使计算机没有上电，时间也可以正确的更新。CMOS存储器还可以保持配置参数。如哪一个是启动磁盘等。之所以采用CMOS是因为它电能消耗非常少，一块原装电池往往能使用数年。CMOS电池没电后，计算机将会不知道由哪个磁盘启动。
磁盘同RAM相比，每个二进制位的成本低了两个数量级。而且通常容量也大几个数量级。唯一的问题是访问数据时间大约慢了三个数量级。低速的原因是因为磁盘是一种机械装置。
磁盘有一个或多个金属盘片，以较高的速度旋转。信息写在磁盘一系列同心圆上。在任意一个给定臂的位置，每个磁头可以读取一段环形区域，称为磁道。把一个给定臂位置上的所有磁道合并起来，组成了一个柱面。
每个磁道划分为若干扇区，典型大小为512字节。现代磁盘中，较外的柱面拥有更多的扇区。机械臂从一个柱面移动到相邻的柱面大概需要1ms。而随机移到一个柱面的典型时间为5-10ms，具体时间取决于驱动器的转速。一旦所需要的扇区移到磁头之下，就开始读写。
固态硬盘没有可以移动的机械臂，是属于闪存，和磁盘同样具有非易失性。
虚拟内存机制：将程序放在磁盘上，将主存作为缓存，用来保存最频繁使用的部分程序。这种机制需要快速的映像内存地址，以便把程序生成的地址转换成为有关字节在RAM中的物理地址。这种映像由CPU中一个叫内存管理单元（MMU）的部件来完成。
缓存和MMU的出现对系统的性能有着重要的影响。在多道程序系统中，从一个程序切换到另一个程序，称为上下文切换。有必要对来自缓存的修改过的块进行写回磁盘的操作。并修改MMU中的映像寄存器。而上下文切换的代价很高，程序员应该努力避免这些操作。
8.4 I/O设备 I/O设备一般包括两个部分，设备控制器和设备本身。
控制器是插在电路板上的一块芯片和一组芯片，这块电路板物理地控制设备，从操作系统接受命令。控制器中一般存在一个小的嵌入式计算机。控制器的任务是为操作系统提供接口。
设备本身也有一个接口，但是功能比较简单。设备本身有个相对简单的接口，接口既不能做很多工作，又已经被标准化。实际的接口隐藏在控制器中。操作系统看到的是对控制器的接口，这个接口可能和设备接口有很大的差别。"/>

    <meta property="og:title" content="操作系统——引论" />
<meta property="og:description" content="完全基于《现代操作系统》第四版，摘取精华，掺杂个人理解。适用于自学党，和想要系统学习操作系统的人。
一、引论 1.为什么要有操作系统？操作系统的任务是什么？ 需求：现代计算机系统的组成极为复杂（处理器，主存，磁盘，输入输出设备&hellip;）,应用程序员没有精力去掌握系统的所有细节。而且，管理这些部件并加以使用，是一件挑战性极强的工作。
所以计算机需要安装一层软件——操作系统。来满足这些需求。（注意：操作系统是系统软件，非应用软件）
任务：为用户程序提供一个更好、更简单、更清晰的计算机模型（操作系统）来实现对计算机所有设备的管理。
一言以蔽之，就是封装硬件运行和管理的细节，服务于上层的应用程序。
抽象是管理复杂性的一个关键，操作系统的任务就是创建好的抽象，并实现和管理它所创建的抽象对象。隐藏硬件，呈现给程序以及程序员良好/清晰/优雅/一致的抽象。
2.用户与操作系统交互的方式——用户接口程序 1.基于文本的——shell（命令行）
2.基于图标的——GUI（图形用户接口）
它们都属于用户接口程序，处于用户态程序中的最低层次。用户可以通过它们运行其他程序，如Web浏览器/音乐播放器等，这些程序也在大量使用操作系统。
3.操作系统内核态和用户态的区别 软件的最基础部分——操作系统，运行在内核态（也称管态，核心态）。核心态下，操作系统具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令。（为所欲为）
所以是有危险性的。
所以在用户态下，只使用了一部分机器指令，尤其是那些影响机器控制以及和IO操作有关系的指令，在用户态中的程序是禁止的。
4.操作系统所处的位置 由底层向上：硬件（裸机）——操作系统（软件，运行在内核态）——用户接口程序（软件，属于用户态最底层，靠近操作系统）——应用程序（软件，用户态）
总之，操作系统运行在裸机（纯硬件）之上，为其他所有软件提供基础的运行环境。
与普通软件的区别：操作系统软件不能被修改，受硬件保护，防止用户试图对其进行修改。
然而，在嵌入式系统（没有内核态）或解释系统（如基于Java的操作系统，它采用解释方式而非硬件方式区分组件）中，上述区别是模糊的。
操作系统一般比用户程序大型，复杂和长寿。（Linux和Windows内核源码都超过了500万行）
5.操作系统的实际用户——应用程序 应用程序直接与操作系统及其抽象打交道，而用户与用户接口所提供的抽象打交道（命令行shell或GUI）。虽然用户接口不同，但是操作系统下面的抽象是相同的。
6.操作系统是资源管理者——把潜在的混乱有序化 资源管理多路复用资源：在时间（CPU时间片）和空间（分割内存）上复用。
操作系统会分配CPU和内存，并协调管理使其有序，以提高运行的效率。
7.操作系统的历史 第一代：真空管和穿孔卡片 ——第二代：晶体管和批处理系统——第三代：集成电路和多道程序设计——第四代：个人计算机——第五代：移动计算机
8.处理器基础知识 CPU是计算机的大脑，它从内存中取出指令并且执行之。
三大流程：取指（从内存中）/解码（确定其类型和操作数）/执行
每个CPU都有特有的指令集，所以x86不能执行ARM程序，反之亦然。而且访存取指的时间比执行指令花费的时间长得多。因此。所有CPU的内部都有一些用来保存关键变量和临时数据的寄存器。
8.1 CPU中的寄存器介绍 除了用来保存变量和临时结果的通用寄存器外，还有一些程序员可见的专用寄存器。其中之一是程序计数器，它保存了将要取出的下一条指令的内存地址。
在取完指令后，程序计数器被更新以指向后继的指令。
另一个寄存器是堆栈指针，它指向内存中当前栈的顶端。该栈包含了每个执行过程的栈帧。一个过程的栈帧中保存了有关的输入参数、局部变量以及那些没有保存在寄存器中的临时变量。
当然还有程序状态字(PSW)寄存器。这个寄存器包含了条件码位、CPU优先级、模式（用户态或内核态），以及各种其他控制位。用户程序通常读入整个PSW，但是只对其中少量字段写入。在系统调用和I/O中，PSW的作用很重要。
操作系统必须知晓所有的寄存器。在时间多路复用CPU中，操作系统经常会中止正在运行的某个程序并再启动另一个程序，每次停止一个正在运行着的程序时，操作系统必须保存所有的寄存器值。这样在稍后该程序被再次运行时，可以把这些寄存器重新装入。
为了改善性能，现代CPU有同时取出多条指令的机制。例如，一个CPU可以有单独的取指单元、解码单元和执行单元，于是当它执行指令N时，可以对指令N&#43;1进行解码，并且可以在内存读取指令N&#43;2。这样的机制称为流水线。
一旦一条指令被取进流水线中，它就必须被执行完毕，即便前一条取出的指令是条件转移，它也必须被执行完毕。
还有更先进的**超标量CPU，有多个取指，解码，执行单元。**只要有一个执行单元空闲，就检查保持缓冲区中是否还有可处理的指令，如果有就把指令从缓冲区中移出并执行之。这种设计程序的指令经常不按顺序执行。多数情况下，硬件负责保证这种运算的结果与顺序执行指令时的结果相同，但是，仍然有部分令人烦恼的复杂情形被强加给操作系统处理（暂不讨论）。
在PSW中有一个二进制位控制CPU的内核态和用户态两种模式。内核态中运行的CPU可以执行指令集中的每一条指令，并且使用硬件的每种功能。值得一提的是，在台式机和服务器中，操作系统在内核态下运行，而在大多数嵌入式系统中，一部分操作系统运行在内核态，其余部分则运行在用户态。
相反**，用户程序在用户态下运行，仅允许执行指令集的一个子集和访问所有功能的一个子集**。一般而言，在用户态中有关IO和内存保护的所有指令是禁止的。当然，将PSW中的模式位设置成内核态也是禁止的。
为了从操作系统中获得服务，用户程序必须使用系统调用以陷入内核并调用操作系统。
只有TRAP指令能把用户态切换成内核态，并启用操作系统。在有关工作完成后，系统调用后面的指令把控制权返还给用户程序。
8.2 多线程和多核芯片 多线程允许CPU保持两个不同的线程状态，然后在纳秒级的时间尺度内来回切换。多线程不提供真正的并行处理。在同一时刻只有一个进程在运行，但是线程的切换时间则减少到纳秒数量级。
**GPU擅长处理大量并行的简单计算，比如在图像应用中渲染多边形。它们不太能胜任串行任务，并且很难编程。**虽然GPU对操作系统很有用（比如加密或者处理网络传输） ，但操作系统本身不太可能运行在GPU上。
8.3存储器 速度由快到慢：寄存器——高速缓存（Cache）——主存（RAM）——磁盘。每位成本也是由高到低。
缓存有利于改善性能。RAM具有电易失性，ROM则非易失。此外ROM速度快且便宜，用于启动计算机的引导加载模块就存放在ROM中。另外，一些I/O卡也采用ROM处理底层设备控制。
EEPROM和闪存也是非易失性的，与ROM相反，他们可以擦除和重写。不过重写比写入RAM要更高数量级的时间。
闪存速度介于RAM和磁盘之间。另外，与磁盘存储器不同，如果闪存擦除的次数过多，就被磨损了。
还有一类存储器是CMOS，它是易失性的。许多计算机利用CMOS存储器保持当前时间和日期。CMOS存储器和递增时间的时钟电路由一块小电池驱动，即使计算机没有上电，时间也可以正确的更新。CMOS存储器还可以保持配置参数。如哪一个是启动磁盘等。之所以采用CMOS是因为它电能消耗非常少，一块原装电池往往能使用数年。CMOS电池没电后，计算机将会不知道由哪个磁盘启动。
磁盘同RAM相比，每个二进制位的成本低了两个数量级。而且通常容量也大几个数量级。唯一的问题是访问数据时间大约慢了三个数量级。低速的原因是因为磁盘是一种机械装置。
磁盘有一个或多个金属盘片，以较高的速度旋转。信息写在磁盘一系列同心圆上。在任意一个给定臂的位置，每个磁头可以读取一段环形区域，称为磁道。把一个给定臂位置上的所有磁道合并起来，组成了一个柱面。
每个磁道划分为若干扇区，典型大小为512字节。现代磁盘中，较外的柱面拥有更多的扇区。机械臂从一个柱面移动到相邻的柱面大概需要1ms。而随机移到一个柱面的典型时间为5-10ms，具体时间取决于驱动器的转速。一旦所需要的扇区移到磁头之下，就开始读写。
固态硬盘没有可以移动的机械臂，是属于闪存，和磁盘同样具有非易失性。
虚拟内存机制：将程序放在磁盘上，将主存作为缓存，用来保存最频繁使用的部分程序。这种机制需要快速的映像内存地址，以便把程序生成的地址转换成为有关字节在RAM中的物理地址。这种映像由CPU中一个叫内存管理单元（MMU）的部件来完成。
缓存和MMU的出现对系统的性能有着重要的影响。在多道程序系统中，从一个程序切换到另一个程序，称为上下文切换。有必要对来自缓存的修改过的块进行写回磁盘的操作。并修改MMU中的映像寄存器。而上下文切换的代价很高，程序员应该努力避免这些操作。
8.4 I/O设备 I/O设备一般包括两个部分，设备控制器和设备本身。
控制器是插在电路板上的一块芯片和一组芯片，这块电路板物理地控制设备，从操作系统接受命令。控制器中一般存在一个小的嵌入式计算机。控制器的任务是为操作系统提供接口。
设备本身也有一个接口，但是功能比较简单。设备本身有个相对简单的接口，接口既不能做很多工作，又已经被标准化。实际的接口隐藏在控制器中。操作系统看到的是对控制器的接口，这个接口可能和设备接口有很大的差别。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zereals7.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" />
<meta property="article:published_time" content="2021-04-02T18:22:48+08:00" />
<meta property="article:modified_time" content="2021-04-02T18:22:48+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://zereals7.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="Zereal" /></a>
      <h1>Zereal</h1>
      <p>Java coder</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/ZerealS7" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">操作系统——引论</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Apr 2, 2021
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div></div>
    </header>
    <div class="post-content">
      <p>完全基于《现代操作系统》第四版，摘取精华，掺杂个人理解。适用于自学党，和想要系统学习操作系统的人。</p>
<h3 id="一引论">一、引论</h3>
<h4 id="1为什么要有操作系统操作系统的任务是什么">1.为什么要有操作系统？操作系统的任务是什么？</h4>
<p>需求：现代计算机系统的组成极为复杂（处理器，主存，磁盘，输入输出设备&hellip;）,应用程序员没有精力去掌握系统的所有细节。而且，管理这些部件并加以使用，是一件挑战性极强的工作。</p>
<p>所以计算机需要安装一层<strong>软件</strong>——操作系统。来满足这些需求。（注意：操作系统是系统软件，非应用软件）</p>
<p>任务：为用户程序提供一个<strong>更好、更简单、更清晰</strong>的计算机模型（操作系统）来实现对计算机所有设备的管理。</p>
<p>一言以蔽之，就是封装硬件运行和管理的细节，服务于上层的应用程序。</p>
<p>抽象是管理复杂性的一个关键，操作系统的任务就是创建好的抽象，并实现和管理它所创建的抽象对象。隐藏硬件，呈现给程序以及程序员良好/清晰/优雅/一致的抽象。</p>
<h4 id="2用户与操作系统交互的方式用户接口程序">2.用户与操作系统交互的方式——用户接口程序</h4>
<p>1.基于文本的——shell（命令行）</p>
<p>2.基于图标的——GUI（图形用户接口）</p>
<p>它们都属于用户接口程序，处于用户态程序中的最低层次。用户可以通过它们运行其他程序，如Web浏览器/音乐播放器等，这些程序也在大量使用操作系统。</p>
<h4 id="3操作系统内核态和用户态的区别">3.操作系统内核态和用户态的区别</h4>
<p>软件的最基础部分——操作系统，运行在内核态（也称管态，核心态）。核心态下，操作系统具有<strong>对所有硬件的完全访问权，可以执行机器能够运行的任何指令。</strong>（为所欲为）</p>
<p>所以是有危险性的。</p>
<p>所以在用户态下，只使用了一部分机器指令，尤其是那些影响机器控制以及和IO操作有关系的指令，在用户态中的程序是禁止的。</p>
<h4 id="4操作系统所处的位置">4.操作系统所处的位置</h4>
<p>由底层向上：硬件（裸机）——操作系统（软件，运行在内核态）——用户接口程序（软件，<strong>属于用户态最底层</strong>，靠近操作系统）——应用程序（软件，用户态）</p>
<p><img src="https://gitee.com/zerealsong/blogimage/raw/master/img/20210405154121.jpg" alt="2021-04-05 (Copy)"></p>
<p>总之，操作系统运行在裸机（纯硬件）之上，为其他所有软件提供基础的运行环境。</p>
<p><strong>与普通软件的区别</strong>：操作系统软件不能被修改，受硬件保护，防止用户试图对其进行修改。</p>
<p>然而，在嵌入式系统（没有内核态）或解释系统（如基于Java的操作系统，它采用解释方式而非硬件方式区分组件）中，上述区别是模糊的。</p>
<p>操作系统一般比用户程序大型，复杂和长寿。（Linux和Windows内核源码都超过了500万行）</p>
<h4 id="5操作系统的实际用户应用程序">5.操作系统的实际用户——应用程序</h4>
<p>应用程序直接与操作系统及其抽象打交道，而用户与用户接口所提供的抽象打交道（命令行shell或GUI）。虽然用户接口不同，但是操作系统下面的抽象是相同的。</p>
<h4 id="6操作系统是资源管理者把潜在的混乱有序化">6.操作系统是资源管理者——把潜在的混乱有序化</h4>
<p>资源管理多路复用资源：在时间（CPU时间片）和空间（分割内存）上复用。</p>
<p>操作系统会分配CPU和内存，并协调管理使其有序，以提高运行的效率。</p>
<h4 id="7操作系统的历史">7.操作系统的历史</h4>
<p>第一代：真空管和穿孔卡片 ——第二代：晶体管和批处理系统——第三代：集成电路和多道程序设计——第四代：个人计算机——第五代：移动计算机</p>
<h4 id="8处理器基础知识">8.处理器基础知识</h4>
<p>CPU是计算机的大脑，它从内存中取出指令并且执行之。</p>
<p>三大流程：取指（从内存中）/解码（确定其类型和操作数）/执行</p>
<p>每个CPU都有特有的指令集，所以x86不能执行ARM程序，反之亦然。而且<strong>访存取指的时间比执行指令花费的时间长得多</strong>。因此。所有CPU的内部都有一些用来保存关键变量和临时数据的寄存器。</p>
<h6 id="81-cpu中的寄存器介绍"><strong>8.1 CPU中的寄存器介绍</strong></h6>
<p>除了用来保存变量和临时结果的<strong>通用寄存器</strong>外，还有一些<strong>程序员可见的专用寄存器</strong>。其中之一是程序计数器，它保存了将要取出的下一条指令的内存地址。</p>
<p>在<strong>取完指令后，程序计数器被更新</strong>以指向后继的指令。</p>
<p>另一个寄存器是堆栈指针，它指向<strong>内存中当前栈的顶端</strong>。该栈包含了每个执行过程的栈帧。一个过程的栈帧中保存了有关的输入参数、局部变量以及那些没有保存在寄存器中的临时变量。</p>
<p>当然还有程序状态字(PSW)寄存器。这个寄存器包含了条件码位、CPU优先级、模式（用户态或内核态），以及各种其他控制位。用户程序通常读入整个PSW，但是只对其中少量字段写入。在系统调用和I/O中，PSW的作用很重要。</p>
<p>操作系统必须知晓所有的寄存器。在时间多路复用CPU中，操作系统经常会中止正在运行的某个程序并再启动另一个程序，每次停止一个正在运行着的程序时，操作系统必须保存所有的寄存器值。这样在稍后该程序被再次运行时，可以把这些寄存器重新装入。</p>
<p>为了改善性能，现代CPU有同时取出多条指令的机制。例如，一个CPU可以有单独的取指单元、解码单元和执行单元，于是当它执行指令N时，可以对指令N+1进行解码，并且可以在内存读取指令N+2。这样的机制称为流水线。</p>
<p><strong>一旦一条指令被取进流水线中，它就必须被执行完毕，即便前一条取出的指令是条件转移，它也必须被执行完毕。</strong></p>
<p><img src="https://gitee.com/zerealsong/blogimage/raw/master/img/20210405160725.jpg" alt="2021-04-05_2(2) (Copy)"></p>
<p>还有更先进的**超标量CPU，有多个取指，解码，执行单元。**只要有一个执行单元空闲，就检查保持缓冲区中是否还有可处理的指令，如果有就把指令从缓冲区中移出并执行之。这种设计程序的指令经常不按顺序执行。多数情况下，硬件负责保证这种运算的结果与顺序执行指令时的结果相同，但是，仍然有部分令人烦恼的复杂情形被强加给操作系统处理（暂不讨论）。</p>
<p>在PSW中有一个二进制位控制CPU的内核态和用户态两种模式。内核态中运行的CPU可以执行指令集中的每一条指令，并且使用硬件的每种功能。值得一提的是，在台式机和服务器中，操作系统在内核态下运行，而在大多数嵌入式系统中，一部分操作系统运行在内核态，其余部分则运行在用户态。</p>
<p>相反**，用户程序在用户态下运行，仅允许执行指令集的一个子集和访问所有功能的一个子集**。一般而言，在用户态中有关IO和内存保护的所有指令是禁止的。当然，将PSW中的模式位设置成内核态也是禁止的。</p>
<p>为了从操作系统中获得服务，用户程序必须使用<strong>系统调用</strong>以陷入内核并调用操作系统。</p>
<p>只有TRAP指令能把用户态切换成内核态，并启用操作系统。在有关工作完成后，系统调用后面的指令把控制权返还给用户程序。</p>
<h6 id="82-多线程和多核芯片">8.2 多线程和多核芯片</h6>
<p>多线程允许CPU保持两个不同的线程状态，然后在纳秒级的时间尺度内来回切换。<strong>多线程不提供真正的并行处理。在同一时刻只有一个进程在运行，但是线程的切换时间则减少到纳秒数量级。</strong></p>
<p>**GPU擅长处理大量并行的简单计算，比如在图像应用中渲染多边形。它们不太能胜任串行任务，并且很难编程。**虽然GPU对操作系统很有用（比如加密或者处理网络传输） ，但操作系统本身不太可能运行在GPU上。</p>
<h6 id="83存储器">8.3存储器</h6>
<p>速度由快到慢：寄存器——高速缓存（Cache）——主存（RAM）——磁盘。每位成本也是由高到低。</p>
<p>缓存有利于改善性能。RAM具有电易失性，ROM则非易失。此外ROM速度快且便宜，用于启动计算机的引导加载模块就存放在ROM中。另外，一些I/O卡也采用ROM处理底层设备控制。</p>
<p>EEPROM和闪存也是非易失性的，与ROM相反，他们可以擦除和重写。不过重写比写入RAM要更高数量级的时间。</p>
<p>闪存速度介于RAM和磁盘之间。另外，与磁盘存储器不同，如果闪存擦除的次数过多，就被磨损了。</p>
<p>还有一类存储器是CMOS，它是易失性的。许多计算机利用CMOS存储器保持当前时间和日期。CMOS存储器和递增时间的时钟电路由一块小电池驱动，即使计算机没有上电，时间也可以正确的更新。CMOS存储器还可以保持配置参数。如哪一个是启动磁盘等。之所以采用CMOS是因为它电能消耗非常少，一块原装电池往往能使用数年。CMOS电池没电后，计算机将会不知道由哪个磁盘启动。</p>
<p>磁盘同RAM相比，每个二进制位的成本低了两个数量级。而且通常容量也大几个数量级。唯一的问题是访问数据时间大约慢了三个数量级。低速的原因是因为磁盘是一种机械装置。</p>
<p>磁盘有一个或多个金属盘片，以较高的速度旋转。信息写在磁盘一系列同心圆上。在任意一个给定臂的位置，每个磁头可以读取一段环形区域，称为磁道。把一个给定臂位置上的所有磁道合并起来，组成了一个柱面。</p>
<p>每个磁道划分为若干扇区，典型大小为512字节。现代磁盘中，较外的柱面拥有更多的扇区。机械臂从一个柱面移动到相邻的柱面大概需要1ms。而随机移到一个柱面的典型时间为5-10ms，具体时间取决于驱动器的转速。一旦所需要的扇区移到磁头之下，就开始读写。</p>
<p>固态硬盘没有可以移动的机械臂，是属于闪存，和磁盘同样具有非易失性。</p>
<p><strong>虚拟内存机制</strong>：将程序放在磁盘上，将主存作为缓存，用来保存最频繁使用的部分程序。这种机制需要快速的映像内存地址，以便把程序生成的地址转换成为有关字节在RAM中的物理地址。这种映像由CPU中一个叫内存管理单元（MMU）的部件来完成。</p>
<p>缓存和MMU的出现对系统的性能有着重要的影响。在多道程序系统中，从一个程序切换到另一个程序，称为上下文切换。有必要对来自缓存的修改过的块进行写回磁盘的操作。并修改MMU中的映像寄存器。而上下文切换的代价很高，程序员应该努力避免这些操作。</p>
<h6 id="84-io设备">8.4 I/O设备</h6>
<p>I/O设备一般包括两个部分，<strong>设备控制器和设备本身</strong>。</p>
<p>控制器是插在电路板上的一块芯片和一组芯片，这块电路板物理地控制设备，从操作系统接受命令。控制器中一般存在一个小的嵌入式计算机。控制器的任务是为操作系统提供接口。</p>
<p>设备本身也有一个接口，但是功能比较简单。设备本身有个相对简单的接口，接口既不能做很多工作，又已经被标准化。实际的接口隐藏在控制器中。<strong>操作系统看到的是对控制器的接口</strong>，这个接口可能和设备接口有很大的差别。</p>
<p>每类设备控制器都不同，需要不同的软件进行控制。专门与控制器对话，发出命令并接收响应的软件，称为设备驱动程序。每个控制器厂家必须为所支持的操作系统提供相应的设备驱动程序。例如一胎扫描仪会配有用于多种操作系统的设备驱动程序。</p>
<p>为了能够使用设备驱动程序，必须把设备驱动程序装入操作系统中，这样它可以在核心态运行。</p>
<p>绝大多数驱动程序需要在内核态运行。</p>
<p>要将设备驱动程序装入操作系统的三个途径：1、将内核与设备驱动程序重新链接，然后重启系统。主要是UNIX系统以这种方式工作。2、在一个操作系统文件中设置一个入口  ，并通知该文件需要一个设备驱动程序，然后重启系统。系统启动时，操作系统去找寻所需的设备驱动并装载之。Windows就是这种方式工作。3、操作系统能够在运行时接受新的设备驱动程序并将其立即安装好，无须重启系统。像USB等热插拔设备都需要动态可装载设备驱动程序。</p>
<p>每个设备控制器都有少量用于通信的寄存器。例如一个最小的磁盘控制器也会有用于指定磁盘地址、内存地址、扇区计数和方向（读或写）的寄存器。</p>
<p>要激活控制器，设备驱动程序从操作系统获得命令，然后翻译成对应的值，并写入设备寄存器（用于命令通信）中。所有设备寄存器的集合构成了<strong>I/O端口空间</strong>。</p>
<p><strong>两种IO方式</strong></p>
<p>某些机器，设备寄存器被映射到操作系统的地址空间，以使其可以像普通存储字一样读出和写入。</p>
<p>在另一些机器中，设备寄存器被放入一个专门的I/O端口空间，每个寄存器都有一个端口地址。机器中会提供在内核态中专用的IN和OUT指令，供设备驱动程序读写这些寄存器。</p>
<p>区别：前者不需要专门的IO指令，但占用了一些地址空间。后者不占用地址空间，但是需要专门的指令。</p>
<p>两种方式都有广泛应用。</p>
<p>实现输入和输出的方式：</p>
<p>1、用户程序发出一个系统调用（进入内核态），内核将其翻译成一个对应设备驱动程序的过程调用。然后设备驱动程序启动IO并在一个连续不断的循环中检查该设备，看该设备是否完成了工作。（一般有些二进制位用来指示设备仍在忙碌中）。IO结束后，设备驱动程序把数据送到指定的地方，并返回。操作系统将控制返回给调用者，这种方式叫忙等待，缺点是要占据CPU，CPU会一直轮询设备直到对应的IO操作完成。</p>
<p>2、设备驱动程序启动设备并且让设备在操作完成时发出一个中断。  设备驱动程序在这个时刻返回。操作系统在需要时阻塞调用者并安排其他工作进行，当设备驱动程序检测到该设备操作完毕时，它发出一个中断通知操作完成。</p>
<p>IO三步走：第一步、设备驱动程序通过写设备寄存器通知设备控制器做什么。然后，设备控制器启动该设备。当设备控制器传送完毕被告知要进行读写的字节数量后，在第二步、使用特定的总线发信号给中断控制器芯片。如果中断控制器已经准备接收中断（如果正忙于更高级的中断，也可能不接收） ，它会在CPU芯片的一个管脚上声明，这就是第三步。第四步，中断控制器把该设备的编号放到总线上。这样CPU可以读总线，并且知道哪个设备刚刚完成了操作。</p>
<p>​</p>
<p>​                                        <img src="https://gitee.com/zerealsong/blogimage/raw/master/img/20210406165643.jpg" alt="2021-04-0654 (Copy)"></p>
<p>左边是启动一个IO设备并发出中断的过程，右边是中断处理的过程包括取中断、运行中断处理程序和返回用户程序。</p>
<p>一旦CPU决定取中断，通常程序计数器和PSW就被压入当前堆栈中，并且CPU被切换到用户态。设备编号可以成为部分内存的一个引用，用于寻找该设备中断处理程序的地址。这部分内存称为中断向量。当中断处理程序开始后，它取走已入栈的程序计数器和PSW，并保存之，然后查询设备的状态。在中断处理程序全部完成后，它返回先前运行的用户程序中尚未执行的头一条指令。</p>
<p>3、第三种方式为，为IO使用一种特殊的直接存储器访问芯片，它可以控制在内存和某些控制器之间的位流，无须持续的CPU干预。CPU对DMA芯片进行设置，说明需要传送的字节数/有关的设备和内存地址以及操作方向，接着启动DMA。当DMA芯片完成时，它引发一个中断，处理方式如前所述。</p>
<p>中断会在非常不适合的时刻发生，比如在另一个中断程序正在运行时发生。因此，CPU有办法关闭中断，并在稍后再开启中断。在中断关闭时，任何发出中断的设备，可以继续保持其中断信号，但是CPU不会被中断，直至中断再次启用为止。如果在关闭中断时，已有多个设备发出了中断，中断控制器将决定先处理哪个中断，通常这取决于事先赋予每个设备的静态优先级。最高优先级的设备赢得竞争并且首先获得服务，其他设备则必须等待。</p>
<h6 id="85-总线">8.5 总线</h6>
<p>大多数总线都是并行且共享的，因此，当多个设备同时需要发送数据时，需要仲裁器决定哪个设备可以使用总线。</p>
<p>传统PCI使用并行总线架构表示多条导线发送数据的每一个字。</p>
<p>例如：一个32位数据通过32条并行的导线发送。</p>
<p>相反，PCIe使用串行总线架构，通过一条被称为数据通路的链路传递集合了所有位的一条消息。</p>
<p>CPU通过DDR3总线与内存对话，通过PCIe总线与外围图形设备对话，通过DMI总线经集成中心与所有其他设备对话。而集成中心通过串行总线与USB设备对话。通过SATA总线与硬盘和DVD驱动对话，通过PCIe传输以太网帧。</p>
<p>很可能所有的PCI设备将连接到一个集成处理器中心，这些中心再连接到主集成中心，从而形成总线树。</p>
<p>USB用来将所有慢速IO设备与计算机连接。</p>
<p>SCSI总线是一种高速总线，用在高速硬盘/扫描仪和其他需要较大带宽的设备上。</p>
<p>即插即用所做的工作是，系统自动地收集有关IO设备的信息，集中赋予中断级别和IO地址，然后通知每块卡所使用的数值。这项工作与计算机的启动密切相关。</p>
<p>启动过程中，每台计算机的双亲版上都有一个称为基本输入输出系统的程序。再BIOS内有底层IO软件，包括读键盘、写屏幕、进行磁盘IO以及其他过程。现在这个程序放在一块非易失的闪速RAM中。在发现BIOS有错时可以通过操作系统对它进行更新。</p>
<h6 id="86-计算机启动过程">8.6 计算机启动过程</h6>
<p>在计算机启动时，BIOS开始运行。它首先检查所安装的RAM数量，键盘和其他基本设备是否已安装并正常响应。接着，开始扫描PCIe和PCI总线并找出连在上面的所有设别。即插即用设备也被记录下来。如果现有设备和系统上一次启动时的设备不同，则新的设备将被配置。</p>
<p>然后BIOS通过尝试存储在CMOS存储器中的设备清单决定启动设备。用户可以在系统刚启动之后进入一个BIOS配置程序，对设备清单进行修改。启动设备上的第一个扇区被读入内存并执行。这个扇区中包含一个对保存在启动扇区末尾的分区表检查的程序，以确定哪个分区是活动的。然后，从该分区读入第二个启动装载模块。来自活动分区的这个装载模块 被读入操作系统，并启动之。</p>
<p>然后，操作系统询问BIOS，以获得配置信息。对于每种设备，系统检查对应的设备驱动程序是否存在。如果没有，系统要求用户插入含有设备驱动程序的CDROM或者从网上下载驱动程序。一旦有了全部设备驱动程式，操作系统就将它们调入内核。然后初始化有关表格，创建需要的任何背景进程，并在每个终端上启动登录程序或GUI。</p>
<h6 id="87-操作系统大观园">8.7 操作系统大观园</h6>
<p>大型操作系统：主要面向多个作业的同时处理。系统提供三类服务：批处理、事务处理和分时。批处理系统不需要交互式用户干预的周期性作业。事务处理负责大量小的请求。分时系统允许多个远程用户同时在计算机上运行作业。</p>
<p>服务器操作系统：服务器上运行，可以是个人计算机，工作站甚至是大型机。通过网络同时为若干个用户服务，并且允许用户共享硬件和软件资源。服务器可提供打印服务、文件服务或WEB服务。</p>
<p>多处理机操作系统：获得大量联合计算能力的常用方式是将多个CPU连接成单个的系统。依据连接和共享的形式不同，这些系统被称为并行计算机，多计算机或多处理器。不过通常采用的操作系统是配有通信、连接和一致性等专门功能的服务器操作系统。</p>
<p>个人计算机操作系统：支持多道程序处理，能为单个用户提供良好的支持。</p>
<p>掌上计算机操作系统：安卓和IOS</p>
<p>嵌入式操作系统：微波炉，电视机等</p>
<p>传感器节点操作系统：这些节点是一种可以彼此通信而且使用无线通信基站的微型计算机。通常这个操作系统由事件驱动，可以响应外部事件，或基于内部时钟进行周期性的测量。该操作系统必须小且简单，因为这些节点的RAM很小，而且电池寿命是一个重要问题。另外和嵌入式系统一样，所有程序都是预先装载的，用户不会突然启动从互联网上下载程序，这样使得设计大大简化。TinyOS是一个用于传感器节点的知名操作系统。</p>
<p>实时操作系统：硬实时系统，用于工业过程控制，民用航空、军事。软实时系统，比如智能手机的。</p>
<p>智能卡操作系统：最小的操作系统运行在智能卡上。智能卡是一种包含一块CPU芯片的信用卡。它有非常严格的运行能耗和存储空间的限制。其中，有些智能卡只具有单项功能，如电子支付，但是其他智能卡拥有多项功能，它们有专用的操作系统。有些智能卡是面向Java的。这意味着在智能卡的ROM中有一个Java虚拟机解释器。有些卡可以同时处理多个Java小程序，这就是多道程序。</p>
<h4 id="9操作系统概念">9.操作系统概念</h4>
<h6 id="91进程">9.1进程</h6>
<p>进程 本质是一个正在执行的程序。与每个进程相关的是<strong>地址空间</strong>，这是从某个最小值的存储位置到某个最大值的存储位置的列表。在这个地址空间中，进程可以进行读写。该地址空间中存放有可执行程序、程序的数据以及程序的堆栈。与每个进程相关的还有资源集，通常包括寄存器（含有程序计数器和堆栈指针）、打开文件的清单、突出的报价、有关进程清单，以及运行该程序所需要的所有其他信息。进程基本上是容纳运行一个程序所需要的所有信息的容器。</p>
<p>在许多操作系统中，与一个进程有关的所有信息，除了该进程自身地址空间的内容以外，均存放在操作系统的一张表中，称为进程表，进程表是数组结构(链表)，当前存在的每个进程都要占用其中一项。</p>
<p>一个挂起的进程包括：进程的地址空间，以及对应的进程表项（包括寄存器以及稍后重启的该进程所需要的许多其他信息）。</p>
<p>与进程管理有关的最关键的系统调用是那些进行进程创建和进程终止的系统调用。</p>
<p>若一个进程能够创建一个或多个进程（子进程），而且这些进程又可以创建子进程，则很容易得到进程树。</p>
<p>合作完成某些作业的相关进程经常需要彼此通信以便同步它们的行为。这种通信称为进程间通信。</p>
<p>其他可用的进程系统调用：申请更多的内存，等待一个子进程结束，用另一个程序覆盖该程序等。</p>
<p>系统管理器授权给每个进程一个给定的UID。每个被启动的进程都有一个启动该进程的用户UID。子进程拥有与父进程一样的UID。用户可以是某个组的成员，每个组也有一个GID。</p>
<p>在UNIX中，有一个UID称为超级用户，或者Windows中的管理员。它具有特殊的权力，可以违背一些保护规则。</p>
<h6 id="92地址空间">9.2地址空间</h6>
<p>复杂的操作系统中同时运行多道程序，为了避免相互干扰，需要有某种保护机制。虽然机制是硬件形式的，但是由操作系统掌控。</p>
<p>通常每个进程有一些可以使用的地址集合，典型值从0开始直到某个最大值。在最简单的情形下，一个进程可拥有的最大地址空间小于主存。 在最简单的情形下，一个进程可拥有的最大地址空间小于主存。在这种方式下，进程可以用满其地址空间，而且内存中也有足够的空间容纳该进程。</p>
<p>如果进程大于内存空间，希望使用全部的内存。可以用到虚拟内存技术，操作系统把部分地址空间装入主存，部分留在磁盘上，并且在需要时来回交换它们。本质上，操作系统创建了一个地址空间的抽象。作为进程可以引用地址的集合。地址空间与机器的物理内存解耦，可能大于也可能小于该物理空间。</p>
<h6 id="93-文件">9.3 文件</h6>
<p>文件的增删查改都是要用到系统调用来完成的。</p>
<p>为了提供保存文件的地方，大多数操作系统支持目录的概念，从而可以把文件分类成组。</p>
<p>进程和文件层次都可以组织成树状结构，一般进程的树状结构层次不深（很少超过三层），而文件树状结构层次常常多达四层/五层或更多层。</p>
<p>进程树层次结构是暂时的，通常最多存在几分钟，而目录层次则可能存在数年之久。</p>
<p>只有父进程能控制和访问子进程，而在文件和目录中通常存在一种机制，使文件所有者之外的其他用户也可以访问该文件。</p>
<p>目录层结构每一个文件都可以通过目录的顶部即根目录开始的路径名来确定。绝对路径名包含了从根目录到该文件的所有目录清单，它们用正斜线隔开。在windows则是用的反斜杠。</p>
<p>在实例中，每个进程有一个工作目录，对于没有以斜线开头给出绝对地址的路径，将在这个工作目录下找。进程可以通过使用系统调用指定心的工作目录，从而变更其工作目录。</p>
<p>在读写文件之前，首先要打开文件，检查其访问权限 。若权限许可，系统将返回一个整数22，称为文件描述符，供后续操作使用。若禁止访问，系统返回一个错误码。</p>
<p>在UNIX中，一个重要的概念是特殊文件，提供特殊文件是为了使IO设备看起来像文件一般。这样，就像使用系统调用读写文件一样，IO设备也可通过同样的系统调用进行读写。</p>
<p>有两类特殊文件：块特殊文件和字符特殊文件。前者指那些由可随机存取的块组成的设备，如磁盘等。后者用于打印机、调制解调器和其他接收或输出字符流的设备。按照惯例，特殊文件保存在/dev目录中。</p>
<p>管道是一种虚文件，它可连接两个进程。如果进程A和B希望通过管道对话，它们必须提前设置该管道。当进程A想对进程B发送数据时，它把数据写到管道上，仿佛管道就是输出文件一样。进程B可以通过读该管道而得到数据，仿佛该管道就是输入文件一样。这样在UNIX中两个进程的通信就非常类似于普通文件的读写。更为强大的是，若进程想发现它所写入的输出文件不是真正的文件而是管道，则需要使用特殊的系统调用。</p>
<h6 id="94-输入输出">9.4 输入/输出</h6>
<p>UNIX操作系统通过对每个文件赋予一个9位的二进制保护代码，对UNIX中的文件实现保护。</p>
<p>该保护代码有三个3位字段，一个用于所有者，一个用于与所有者同组的其他成员，一个用于其他人。每个字段中有一位读访问，一位写访问，一位用于执行访问。这些位就是知名的<strong>rwx位</strong>。</p>
<p>操作系统是进行系统调用的代码。shell也是终端用户与操作系统之间的接口，除非用户使用的是图形用户界面。</p>
<h6 id="10系统调用">10、系统调用</h6>
<p>任何单CPU计算机一次只能执行一条指令。如果一个进程正在用户态运行一个用户程序，并且需要一个系统服务，比如从一个文件读数据 ，那么它就必须执行一个陷阱或系统调用指令，将控制转移到操作系统。操作系统接着通过参数检查找出所需要的调用进程。然后，它执行系统调用，并把控制返回给在系统调用后面跟随着的指令。在某种意义上，进行系统调用就像进行一个特殊的过程调用，但是只有系统调用可以进入内核，而过程调用则不能。</p>
<p>为了使系统调用机制机制更清晰，READ系统调用有三个参数：第一个参数指定文件，第二个指向缓冲区，第三个说明要读出的字节数。几乎与所有的系统调用一样，他的调用由C语言完成，方法是调用一个与该系统调用名称相同的库过程：read。</p>
<p>系统调用在count中返回实际读出的字节数。这个值通常和nbytes相同，但也可能更小，例如，如果在读过程中遇到文件尾的情形就是如此。</p>
<p>系统调用通过一系列步骤实现。 在准备调用这个这个实际用来进行Read系统调用的read库过程时，调用程序首先把参数压进堆栈。</p>
<p>TRAP指令与过程指令存在两个方面的差别。首先，它的副作用是，切换到内核态。而过程调用指令并不改变模式。其次，不像给定过程所在的相对或绝对地址那样，TRAP指令不能跳转到任意地址上。根据机器的体系结构，或者跳转到一个单固定地址上，或者指令中有一8位长的字段， 它给定了内存中一张表格的索引，这张表格中含有跳转地址。</p>
<p>操作系统的构建方式有多种。最常见的有单体系统、层次化系统、微内核系统、客户端-服务器系统，虚拟机系统和外核系统。</p>
<p>​</p>
<p>​</p>

    </div>
    <div class="post-footer">
      
    </div>
    <div class="post-comment">
      
      


<span id="/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="leancloud_visitors" data-flag-title="操作系统——引论">
    <span class="post-meta-item-text">文章阅读量 </span>
    <span class="leancloud-visitors-count">1000000</span>
    <p></p>
  </span>
<div id="vcomments"></div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script type="text/javascript">
  new Valine({
    el: '#vcomments' ,
    appId: 'cScQmclMsD4OOWCclCP1pNsz-gzGzoHsz',
    appKey: 'dtSaHLmdH3J4ICVVInYg9YFM',
    notify:  false ,
  verify:  false ,
  avatar:'mm',
    placeholder: '说点什么吧...',
    visitor:  true 
  });
</script>

    </div>
  </article>

    </main>
  </body>
</html>
