<!doctype html>
<html lang="en-us">
  <head>
    <title>Java核心技术第九章笔记-集合 // Zereal-宋致远技术博客</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.72.0" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75，minimum-scale=0.75, maximum-scale=0.75, user-scalable=no" />
    <meta name="author" content="Zereal" />
    <meta name="description" content="" />
    <meta name="referrer" content="never"/>
    <link rel="stylesheet" href="https://zereals7.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java核心技术第九章笔记-集合"/>
<meta name="twitter:description" content="Java集合类库是接口与实现分离的。一旦构建了集合就不需要知道究竟使用哪种实现。可以是顺序表可以是链表，可以是队列，可以是循环数组。
集合类的基本接口是Colection接口，有两个基本方法
add 方法向集合中添加元素。如果添加元素改变了集合就返回true，如果集合没有发生变化就返回false。例如，如果试图向集中添加一个对象，而这个对象在集中已经存在，这个添加请求就没有失效，因为集中不允许有重复的对象。iterator方法用于返回一个实现了Iterator接口的对象。可以用这个迭代器对象以此访问集合中的元素。
迭代器
通过反复调用next方法，可以逐个访问集合中的每个元素。但是如果到达了集合末尾，next方法将抛出一个五元素的以此。因此，在调用next之前调用hasNext方法。如果迭代器对象还有多个供访问的元素，这个方法就返回true。如果想要查看集合中的所有元素，就请求一个迭代器，并在hasnext返回true时反复调用next方法。
用for each循环可以更加简练地表示同样的循环操作：
for (String element:collection){do something with element}编译器简单地将for each循环翻译为带有迭代器的循环.
for each 循环可以与任何实现了Iterable接口的对象一起工作。
Collection接口扩展了Iterable接口。因此，对于标准类库中的任何集合都可以使用for each循环。
应该将Java迭代器认为是位于两个元素之间。当调用next时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用。
Iterator接口的remove方法将会删除上次调用next方法时返回的元素。
更重要的时，对next方法和remove方法的调用具有互相依赖性。如果调用remove之前没有调用next将是不合法的。
如果向删除两个相邻的元素，中间必须用next越过将要删除的元素。
集合框架中的接口
Java集合框架为不同类型的集合定义了大量接口
集合有两个基本接口：Collection和Map
List是一个有序集合。元素会增加到容器中的特定位置。可以采用两种方式访问元素：使用迭代器访问，或者使用一个整数索引来访问。后遗症被称为随机访问，因为这样可以按照任意顺序访问元素。
链表尽管也是有序的，但是随机访问很慢，所以最好使用迭代器来遍历。
set接口等同于Collection接口。其add方法不允许增加重复的元素。只要两个集合包含同样的元素就认为是相等的，不需要元素有相同的顺序。hashcode方法的定义要包装包含相同元素的两个集会得到相同的散列码。
建立一个set接口可以让程序员编写只接受集的方法。
SortedSet和SortedMap接口会提供用于排序的比较器对象，这两个接口定义了可以得到集合子集视图的方法。
链表与泛型集合之间有一个重要的区别，链表是一个有序集合。
如果链表中只有很少几个元素，就完全没有必要为get方法和set方法的开销而烦恼，但是优先使用链表的唯一理由是尽可能减少 在列表之间插入或删除元素所付出的代价。如果列表中只有少数几个元素，完全可以使用ArrayList。
建议避免使用以整数索引表示链表中位置的所有方法。如果对集合进行随机访问，就使用数组或ArrayList，而不要使用链表。
List接口用于描述一个有序集合，并且集合中每个元素的位置十分重要。有两种访问元素的协议：一种是用迭代器，另一种是用get和set方法随机访问每个元素。后者不适用于链表，但对数组很有用。集合类库提供了一种大家熟悉的ArrayList类，这个类也实现了List接口。ArrayList封装了一个动态再分配的对象数组。
注意：对于一个经验丰富的Java程序员，在需要动态数组时，可能会使用Vector类。为什么要用ArrayList取代Vector呢？原因很简单：Vector类的所有丰富都是同步的。可以由两个线程安全地访问一个Vector对象。但是，如果有一个线程访问Vector,代码要在同步操作上耗费大量的实际。而ArrayList方法不是同步的。因此，建议在不需要同步时使用ArrayList,而不要使用Vector。
散列集
链表和数组可以按照人们的意愿排列元素的次序。单数，如果想要查看某个指定的元素，却又忘记了它的位置，就需要访问所有的元素，知道找到为止。如果集合中包含的元素很多，将会消耗很多的时间。如果不在意元素的顺序，可以又集中能够快速 查找元素的数据结构。其缺点是无法控制元素出现的次序。它们将按照有利于其操作目的的原则组织数据。
有一种众所周知的数据结构，可以快速地查找所需要的对象，这就是散列表。散列表为每个对象计算一个整数，称为散列码。散列码是由对象的实例域产生一个整数。更准确地说，具有不同的数据域将产生不同的散列码。
最重要的问题是散列码要能够快速地计算出来，并且这个计算只与要散列的对象状态有关，与散列表中的其他对象无关。
在Java中，散列表用链表数组实现。每个列表被称为桶。要想查找标准对象的位置，就要先计算它的散列码，然后与桶的zoo那个书取余，所得到的结果就是保存这个元素的桶的索引。
有时候会遇到桶被占满的情况，这也是不可避免的。这种现象被称为散列冲突。
这是，需要用新对象与桶中的所有对象进行比较，查看这个对象是否已经存在。如果散列码是合理且随机分布的，桶的数目也足够大，需要比较的次数就会很少。
在Javase8中，桶满时会从链表变为平衡二叉树。如果选择的散列函数不当，或者如果有恶意代码试图在散列表中填充多个有相同散列码的值，会产生很多冲突。
想要更多的控制散列表的运行性能，就要指定一个初始的桶数。桶数是指用于收集具有相同散列值的桶的数目。如果要插入到散列表中的元素太多，就会增加冲突的可能性，降低运行性能。
如果大致指定最终由多少个元素插入到散列表中，就可以设置桶数。通常，将桶数设定为预计元素个数的75%-150%。最好将桶数设置为一个素数。以防止键的聚集。
如果散列表太慢，就需要再散列，如果要对散列表再散列，就需要创建以恶个桶数更多的表，并将所有元素插入到这个信标中，然后丢弃原来的表。装填因子决定合适对散列表进行再散列。例如，如果装填因子为0.75，而表中超过75%的位置已经填入元素，这个表就会用双倍的桶数自动地进行再散列。对于大多数应用程序来说，装填因子为0.75是比较合理的。
散列表可以用于实现几个重要的数据结构，其中最简单的是set类型。set是没有重复元素的元素结合。set的add方法首先在集中查找要添加的对象，如果不存在，就将这个对象添加进去。
Java集合类库提供了一个HashSet类，它实现了基于散列表的集。可以用add方法添加元素。contains方法已经被重新定义，用来快速的查看是否某个元素已经出现在集中。它只在某个桶中查找元素，而不必查看集合中的所有元素。
散列集迭代器将以此访问所有的桶。由于散列将元素分散在表的各个位置上，所以访问它们的顺序几乎是随机的。只有不关心集合中的元素的顺序时，才应该使用HashSet。
在更改集中元素时要格外小心，如果元素的散列码发生了改变，元素在数据结构中的位置也会发生变化。
树集
TreeSet与散列集十分类似，不过，它比散列集有所改进。树集是一个有序集合。可以以任意顺序将元素插入到集合中。在对集合进行遍历时，每个值将自动按照排序后的顺序呈现。
排序时用树结构完成的，当前实现使用的是红黑树。每次将一个元素添加到树中时，都被放置到正确的位置上。因此，迭代器总是以排好序的顺序访问每个元素。
将一个元素添加到树中要比添加到散列表中慢。如果树中包含n个元素，查找新元素的正确位置平均需要log2n次比较。
要使用树集，必须能够比较元素。这些元素必须实现Comparable接口。或者构造集时必须提供一个Comparator。
是否应该用树集取代散列集。比较添加一个元素所花费的时间看上去不长，而且元素是自动排序的。到底应该怎么做将取决于所要收集的数据。如果不需要对数据进行排序，就没有必要付出排序的开销。更重要的是，对于某些数据来说，对其排序要比散列更加困难。散列函数只是将对象适当地打乱存放，而比较却要精确地判别每个对象。
队列
队列可以乳糖人们有效地在尾部添加一个元素，在头部删除一个元素。由两个端头的队列，即双端队列，可以让人们有效地在头部和尾部同时添加或删除元素。不支持在队列中间添加元素。
优先级队列
优先级队列中的元素可以按照任意的顺序进行插入，却总是按照排序的顺序进行检索。也就是说，无论何时调用remove方法，总会获得当前优先级队列中最小的元素。然而，优先级队列并没有对所有的元素进行排序。如果用迭代的方式处理这些元素，并不需要对它们进行排序。优先级队列使用了一个优雅且高效的数据结构称为堆。堆是一个可以自我调整的二叉树，对树执行添加和删除操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序。
与TreeSet一样，一个优先级队列既可以保存实现了Comparable接口的类对象，也可以保存在构造器中提供的Comparator对象。
使用优先级队列的典型示例是任务调度。每个任务有一个优先级，任务以随机顺序添加到队列中。每当启动一个新的任务时，都将优先级最高的任务从队列中删除 。由于习惯上将1设为最高优先级，所有会将最小的元素删除。"/>

    <meta property="og:title" content="Java核心技术第九章笔记-集合" />
<meta property="og:description" content="Java集合类库是接口与实现分离的。一旦构建了集合就不需要知道究竟使用哪种实现。可以是顺序表可以是链表，可以是队列，可以是循环数组。
集合类的基本接口是Colection接口，有两个基本方法
add 方法向集合中添加元素。如果添加元素改变了集合就返回true，如果集合没有发生变化就返回false。例如，如果试图向集中添加一个对象，而这个对象在集中已经存在，这个添加请求就没有失效，因为集中不允许有重复的对象。iterator方法用于返回一个实现了Iterator接口的对象。可以用这个迭代器对象以此访问集合中的元素。
迭代器
通过反复调用next方法，可以逐个访问集合中的每个元素。但是如果到达了集合末尾，next方法将抛出一个五元素的以此。因此，在调用next之前调用hasNext方法。如果迭代器对象还有多个供访问的元素，这个方法就返回true。如果想要查看集合中的所有元素，就请求一个迭代器，并在hasnext返回true时反复调用next方法。
用for each循环可以更加简练地表示同样的循环操作：
for (String element:collection){do something with element}编译器简单地将for each循环翻译为带有迭代器的循环.
for each 循环可以与任何实现了Iterable接口的对象一起工作。
Collection接口扩展了Iterable接口。因此，对于标准类库中的任何集合都可以使用for each循环。
应该将Java迭代器认为是位于两个元素之间。当调用next时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用。
Iterator接口的remove方法将会删除上次调用next方法时返回的元素。
更重要的时，对next方法和remove方法的调用具有互相依赖性。如果调用remove之前没有调用next将是不合法的。
如果向删除两个相邻的元素，中间必须用next越过将要删除的元素。
集合框架中的接口
Java集合框架为不同类型的集合定义了大量接口
集合有两个基本接口：Collection和Map
List是一个有序集合。元素会增加到容器中的特定位置。可以采用两种方式访问元素：使用迭代器访问，或者使用一个整数索引来访问。后遗症被称为随机访问，因为这样可以按照任意顺序访问元素。
链表尽管也是有序的，但是随机访问很慢，所以最好使用迭代器来遍历。
set接口等同于Collection接口。其add方法不允许增加重复的元素。只要两个集合包含同样的元素就认为是相等的，不需要元素有相同的顺序。hashcode方法的定义要包装包含相同元素的两个集会得到相同的散列码。
建立一个set接口可以让程序员编写只接受集的方法。
SortedSet和SortedMap接口会提供用于排序的比较器对象，这两个接口定义了可以得到集合子集视图的方法。
链表与泛型集合之间有一个重要的区别，链表是一个有序集合。
如果链表中只有很少几个元素，就完全没有必要为get方法和set方法的开销而烦恼，但是优先使用链表的唯一理由是尽可能减少 在列表之间插入或删除元素所付出的代价。如果列表中只有少数几个元素，完全可以使用ArrayList。
建议避免使用以整数索引表示链表中位置的所有方法。如果对集合进行随机访问，就使用数组或ArrayList，而不要使用链表。
List接口用于描述一个有序集合，并且集合中每个元素的位置十分重要。有两种访问元素的协议：一种是用迭代器，另一种是用get和set方法随机访问每个元素。后者不适用于链表，但对数组很有用。集合类库提供了一种大家熟悉的ArrayList类，这个类也实现了List接口。ArrayList封装了一个动态再分配的对象数组。
注意：对于一个经验丰富的Java程序员，在需要动态数组时，可能会使用Vector类。为什么要用ArrayList取代Vector呢？原因很简单：Vector类的所有丰富都是同步的。可以由两个线程安全地访问一个Vector对象。但是，如果有一个线程访问Vector,代码要在同步操作上耗费大量的实际。而ArrayList方法不是同步的。因此，建议在不需要同步时使用ArrayList,而不要使用Vector。
散列集
链表和数组可以按照人们的意愿排列元素的次序。单数，如果想要查看某个指定的元素，却又忘记了它的位置，就需要访问所有的元素，知道找到为止。如果集合中包含的元素很多，将会消耗很多的时间。如果不在意元素的顺序，可以又集中能够快速 查找元素的数据结构。其缺点是无法控制元素出现的次序。它们将按照有利于其操作目的的原则组织数据。
有一种众所周知的数据结构，可以快速地查找所需要的对象，这就是散列表。散列表为每个对象计算一个整数，称为散列码。散列码是由对象的实例域产生一个整数。更准确地说，具有不同的数据域将产生不同的散列码。
最重要的问题是散列码要能够快速地计算出来，并且这个计算只与要散列的对象状态有关，与散列表中的其他对象无关。
在Java中，散列表用链表数组实现。每个列表被称为桶。要想查找标准对象的位置，就要先计算它的散列码，然后与桶的zoo那个书取余，所得到的结果就是保存这个元素的桶的索引。
有时候会遇到桶被占满的情况，这也是不可避免的。这种现象被称为散列冲突。
这是，需要用新对象与桶中的所有对象进行比较，查看这个对象是否已经存在。如果散列码是合理且随机分布的，桶的数目也足够大，需要比较的次数就会很少。
在Javase8中，桶满时会从链表变为平衡二叉树。如果选择的散列函数不当，或者如果有恶意代码试图在散列表中填充多个有相同散列码的值，会产生很多冲突。
想要更多的控制散列表的运行性能，就要指定一个初始的桶数。桶数是指用于收集具有相同散列值的桶的数目。如果要插入到散列表中的元素太多，就会增加冲突的可能性，降低运行性能。
如果大致指定最终由多少个元素插入到散列表中，就可以设置桶数。通常，将桶数设定为预计元素个数的75%-150%。最好将桶数设置为一个素数。以防止键的聚集。
如果散列表太慢，就需要再散列，如果要对散列表再散列，就需要创建以恶个桶数更多的表，并将所有元素插入到这个信标中，然后丢弃原来的表。装填因子决定合适对散列表进行再散列。例如，如果装填因子为0.75，而表中超过75%的位置已经填入元素，这个表就会用双倍的桶数自动地进行再散列。对于大多数应用程序来说，装填因子为0.75是比较合理的。
散列表可以用于实现几个重要的数据结构，其中最简单的是set类型。set是没有重复元素的元素结合。set的add方法首先在集中查找要添加的对象，如果不存在，就将这个对象添加进去。
Java集合类库提供了一个HashSet类，它实现了基于散列表的集。可以用add方法添加元素。contains方法已经被重新定义，用来快速的查看是否某个元素已经出现在集中。它只在某个桶中查找元素，而不必查看集合中的所有元素。
散列集迭代器将以此访问所有的桶。由于散列将元素分散在表的各个位置上，所以访问它们的顺序几乎是随机的。只有不关心集合中的元素的顺序时，才应该使用HashSet。
在更改集中元素时要格外小心，如果元素的散列码发生了改变，元素在数据结构中的位置也会发生变化。
树集
TreeSet与散列集十分类似，不过，它比散列集有所改进。树集是一个有序集合。可以以任意顺序将元素插入到集合中。在对集合进行遍历时，每个值将自动按照排序后的顺序呈现。
排序时用树结构完成的，当前实现使用的是红黑树。每次将一个元素添加到树中时，都被放置到正确的位置上。因此，迭代器总是以排好序的顺序访问每个元素。
将一个元素添加到树中要比添加到散列表中慢。如果树中包含n个元素，查找新元素的正确位置平均需要log2n次比较。
要使用树集，必须能够比较元素。这些元素必须实现Comparable接口。或者构造集时必须提供一个Comparator。
是否应该用树集取代散列集。比较添加一个元素所花费的时间看上去不长，而且元素是自动排序的。到底应该怎么做将取决于所要收集的数据。如果不需要对数据进行排序，就没有必要付出排序的开销。更重要的是，对于某些数据来说，对其排序要比散列更加困难。散列函数只是将对象适当地打乱存放，而比较却要精确地判别每个对象。
队列
队列可以乳糖人们有效地在尾部添加一个元素，在头部删除一个元素。由两个端头的队列，即双端队列，可以让人们有效地在头部和尾部同时添加或删除元素。不支持在队列中间添加元素。
优先级队列
优先级队列中的元素可以按照任意的顺序进行插入，却总是按照排序的顺序进行检索。也就是说，无论何时调用remove方法，总会获得当前优先级队列中最小的元素。然而，优先级队列并没有对所有的元素进行排序。如果用迭代的方式处理这些元素，并不需要对它们进行排序。优先级队列使用了一个优雅且高效的数据结构称为堆。堆是一个可以自我调整的二叉树，对树执行添加和删除操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序。
与TreeSet一样，一个优先级队列既可以保存实现了Comparable接口的类对象，也可以保存在构造器中提供的Comparator对象。
使用优先级队列的典型示例是任务调度。每个任务有一个优先级，任务以随机顺序添加到队列中。每当启动一个新的任务时，都将优先级最高的任务从队列中删除 。由于习惯上将1设为最高优先级，所有会将最小的元素删除。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E4%B9%9D%E7%AB%A0%E7%AC%94%E8%AE%B0-%E9%9B%86%E5%90%88/" />
<meta property="article:published_time" content="2021-07-03T23:59:02+08:00" />
<meta property="article:modified_time" content="2021-07-03T23:59:02+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://zereals7.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="Zereal" /></a>
      <h1>Zereal</h1>
      <p>Java coder</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/ZerealS7" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Java核心技术第九章笔记-集合</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jul 3, 2021
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div></div>
    </header>
    <div class="post-content">
      <p>Java集合类库是接口与实现分离的。一旦构建了集合就不需要知道究竟使用哪种实现。可以是顺序表可以是链表，可以是队列，可以是循环数组。</p>
<p>集合类的基本接口是Colection接口，有两个基本方法</p>
<p>add 方法向集合中添加元素。如果添加元素改变了集合就返回true，如果集合没有发生变化就返回false。例如，如果试图向集中添加一个对象，而这个对象在集中已经存在，这个添加请求就没有失效，因为集中不允许有重复的对象。iterator方法用于返回一个实现了Iterator接口的对象。可以用这个迭代器对象以此访问集合中的元素。</p>
<p><strong>迭代器</strong></p>
<p>通过反复调用next方法，可以逐个访问集合中的每个元素。但是如果到达了集合末尾，next方法将抛出一个五元素的以此。因此，在调用next之前调用hasNext方法。如果迭代器对象还有多个供访问的元素，这个方法就返回true。如果想要查看集合中的所有元素，就请求一个迭代器，并在hasnext返回true时反复调用next方法。</p>
<p>用for each循环可以更加简练地表示同样的循环操作：</p>
<pre><code>for (String element:collection)
{
do something with element
}
</code></pre><p>编译器简单地将for each循环翻译为带有迭代器的循环.</p>
<p>for each 循环可以与任何实现了Iterable接口的对象一起工作。</p>
<p>Collection接口扩展了Iterable接口。因此，对于标准类库中的任何集合都可以使用for each循环。</p>
<p>应该将Java迭代器认为是位于两个元素之间。当调用next时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用。</p>
<p>Iterator接口的remove方法将会删除上次调用next方法时返回的元素。</p>
<p>更重要的时，对next方法和remove方法的调用具有互相依赖性。如果调用remove之前没有调用next将是不合法的。</p>
<p>如果向删除两个相邻的元素，中间必须用next越过将要删除的元素。</p>
<p><strong>集合框架中的接口</strong></p>
<p>Java集合框架为不同类型的集合定义了大量接口</p>
<p>集合有两个基本接口：Collection和Map</p>
<p>List是一个有序集合。元素会增加到容器中的特定位置。可以采用两种方式访问元素：使用迭代器访问，或者使用一个整数索引来访问。后遗症被称为随机访问，因为这样可以按照任意顺序访问元素。</p>
<p>链表尽管也是有序的，但是随机访问很慢，所以最好使用迭代器来遍历。</p>
<p>set接口等同于Collection接口。其add方法不允许增加重复的元素。只要两个集合包含同样的元素就认为是相等的，不需要元素有相同的顺序。hashcode方法的定义要包装包含相同元素的两个集会得到相同的散列码。</p>
<p>建立一个set接口可以让程序员编写只接受集的方法。</p>
<p>SortedSet和SortedMap接口会提供用于排序的比较器对象，这两个接口定义了可以得到集合子集视图的方法。</p>
<p>链表与泛型集合之间有一个重要的区别，链表是一个有序集合。</p>
<p>如果链表中只有很少几个元素，就完全没有必要为get方法和set方法的开销而烦恼，但是优先使用链表的唯一理由是尽可能减少 在列表之间插入或删除元素所付出的代价。如果列表中只有少数几个元素，完全可以使用ArrayList。</p>
<p>建议避免使用以整数索引表示链表中位置的所有方法。如果对集合进行随机访问，就使用数组或ArrayList，而不要使用链表。</p>
<p>List接口用于描述一个有序集合，并且集合中每个元素的位置十分重要。有两种访问元素的协议：一种是用迭代器，另一种是用get和set方法随机访问每个元素。后者不适用于链表，但对数组很有用。集合类库提供了一种大家熟悉的ArrayList类，这个类也实现了List接口。ArrayList封装了一个动态再分配的对象数组。</p>
<p>注意：对于一个经验丰富的Java程序员，在需要动态数组时，可能会使用Vector类。为什么要用ArrayList取代Vector呢？原因很简单：Vector类的所有丰富都是同步的。可以由两个线程安全地访问一个Vector对象。但是，如果有一个线程访问Vector,代码要在同步操作上耗费大量的实际。而ArrayList方法不是同步的。因此，建议在不需要同步时使用ArrayList,而不要使用Vector。</p>
<p><strong>散列集</strong></p>
<p>链表和数组可以按照人们的意愿排列元素的次序。单数，如果想要查看某个指定的元素，却又忘记了它的位置，就需要访问所有的元素，知道找到为止。如果集合中包含的元素很多，将会消耗很多的时间。如果不在意元素的顺序，可以又集中能够快速 查找元素的数据结构。其缺点是无法控制元素出现的次序。它们将按照有利于其操作目的的原则组织数据。</p>
<p>有一种众所周知的数据结构，可以快速地查找所需要的对象，这就是散列表。散列表为每个对象计算一个整数，称为散列码。散列码是由对象的实例域产生一个整数。更准确地说，具有不同的数据域将产生不同的散列码。</p>
<p>最重要的问题是散列码要能够快速地计算出来，并且这个计算只与要散列的对象状态有关，与散列表中的其他对象无关。</p>
<p>在Java中，散列表用链表数组实现。每个列表被称为桶。要想查找标准对象的位置，就要先计算它的散列码，然后与桶的zoo那个书取余，所得到的结果就是保存这个元素的桶的索引。</p>
<p>有时候会遇到桶被占满的情况，这也是不可避免的。这种现象被称为散列冲突。</p>
<p>这是，需要用新对象与桶中的所有对象进行比较，查看这个对象是否已经存在。如果散列码是合理且随机分布的，桶的数目也足够大，需要比较的次数就会很少。</p>
<p>在Javase8中，桶满时会从链表变为平衡二叉树。如果选择的散列函数不当，或者如果有恶意代码试图在散列表中填充多个有相同散列码的值，会产生很多冲突。</p>
<p>想要更多的控制散列表的运行性能，就要指定一个初始的桶数。桶数是指用于收集具有相同散列值的桶的数目。如果要插入到散列表中的元素太多，就会增加冲突的可能性，降低运行性能。</p>
<p>如果大致指定最终由多少个元素插入到散列表中，就可以设置桶数。通常，将桶数设定为预计元素个数的75%-150%。最好将桶数设置为一个素数。以防止键的聚集。</p>
<p>如果散列表太慢，就需要再散列，如果要对散列表再散列，就需要创建以恶个桶数更多的表，并将所有元素插入到这个信标中，然后丢弃原来的表。装填因子决定合适对散列表进行再散列。例如，如果装填因子为0.75，而表中超过75%的位置已经填入元素，这个表就会用双倍的桶数自动地进行再散列。对于大多数应用程序来说，装填因子为0.75是比较合理的。</p>
<p>散列表可以用于实现几个重要的数据结构，其中最简单的是set类型。set是没有重复元素的元素结合。set的add方法首先在集中查找要添加的对象，如果不存在，就将这个对象添加进去。</p>
<p>Java集合类库提供了一个HashSet类，它实现了基于散列表的集。可以用add方法添加元素。contains方法已经被重新定义，用来快速的查看是否某个元素已经出现在集中。它只在某个桶中查找元素，而不必查看集合中的所有元素。</p>
<p>散列集迭代器将以此访问所有的桶。由于散列将元素分散在表的各个位置上，所以访问它们的顺序几乎是随机的。只有不关心集合中的元素的顺序时，才应该使用HashSet。</p>
<p>在更改集中元素时要格外小心，如果元素的散列码发生了改变，元素在数据结构中的位置也会发生变化。</p>
<p><strong>树集</strong></p>
<p>TreeSet与散列集十分类似，不过，它比散列集有所改进。树集是一个有序集合。可以以任意顺序将元素插入到集合中。在对集合进行遍历时，每个值将自动按照排序后的顺序呈现。</p>
<p>排序时用树结构完成的，当前实现使用的是红黑树。每次将一个元素添加到树中时，都被放置到正确的位置上。因此，迭代器总是以排好序的顺序访问每个元素。</p>
<p>将一个元素添加到树中要比添加到散列表中慢。如果树中包含n个元素，查找新元素的正确位置平均需要log2n次比较。</p>
<p>要使用树集，必须能够比较元素。这些元素必须实现Comparable接口。或者构造集时必须提供一个Comparator。</p>
<p>是否应该用树集取代散列集。比较添加一个元素所花费的时间看上去不长，而且元素是自动排序的。到底应该怎么做将取决于所要收集的数据。如果不需要对数据进行排序，就没有必要付出排序的开销。更重要的是，对于某些数据来说，对其排序要比散列更加困难。散列函数只是将对象适当地打乱存放，而比较却要精确地判别每个对象。</p>
<p><strong>队列</strong></p>
<p>队列可以乳糖人们有效地在尾部添加一个元素，在头部删除一个元素。由两个端头的队列，即双端队列，可以让人们有效地在头部和尾部同时添加或删除元素。不支持在队列中间添加元素。</p>
<p><strong>优先级队列</strong></p>
<p>优先级队列中的元素可以按照任意的顺序进行插入，却总是按照排序的顺序进行检索。也就是说，无论何时调用remove方法，总会获得当前优先级队列中最小的元素。然而，优先级队列并没有对所有的元素进行排序。如果用迭代的方式处理这些元素，并不需要对它们进行排序。优先级队列使用了一个优雅且高效的数据结构称为堆。堆是一个可以自我调整的二叉树，对树执行添加和删除操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序。</p>
<p>与TreeSet一样，一个优先级队列既可以保存实现了Comparable接口的类对象，也可以保存在构造器中提供的Comparator对象。</p>
<p>使用优先级队列的典型示例是任务调度。每个任务有一个优先级，任务以随机顺序添加到队列中。每当启动一个新的任务时，都将优先级最高的任务从队列中删除 。由于习惯上将1设为最高优先级，所有会将最小的元素删除。</p>
<p><strong>映射</strong></p>
<p>集是一个集合，可以快速查找现有的元素。单数要查看一个元素，需要查找元素的精确副本。映射map用来存放键值对。如果提供了键，就能够查找到值。</p>
<p>Java类库为映射提供了两个通用的实现：HashMap和TreeMap。这两个类都实现了Map接口。</p>
<p>散列映射对键进行散列，树映射用键的整体顺序对元素进行排序，并将其组织成搜索树。散列或比较函数只能作用于键。与键关联的值不能进行散列或比较 。</p>
<p>应该选择散列映射还是树映射呢？    与集一样，散列稍微快一些，如果不需要按照排列顺序放文件，就最好选择散列</p>
<p>每当往映射中添加对象时，必须同时提供一个键。在这里，键是一个字符串，对应的值是Employee对象。</p>
<p>要想检索一个对象，必须使用一个键。</p>
<p>如果在映射中没有给定键对应的信息，get将返回Null。</p>
<p>键必须是唯一的。不能对同一个键存放两个值。如果对同一键两次调用put方法，第二个值就会取代第一个值。实际上，put将返回用这个键参数存储的上一个值。</p>
<p>remove方法用于从映射中删除给定键对应的元素。size方法用于返回映射中的元素数。</p>
<p>要迭代处理映射的键和值，最容易的方法是使用forEach方法。可以提供一个接受键和值的lambda表达式。</p>
<p>首先将键/值对添加到映射中。然后，从映射中删除一个键，同时与之对应的值也被删除了。55</p>
<p><strong>更新映射项</strong></p>
<p>处理映射的难点是更新映射项。正常情况下，可以得到与一个键关联的原值，完成更新，再放回更新后的值。不过必须考虑一个特殊的情况，即键第一次出现。下面来看一个例子，使用一个映射统计一个单词在文件中出现的频度。看到一个单词时，我们将计数器增加1.</p>
<p>不过有一种情况除外，就是第一次看到word时。在这种情况下 ，get会返回null，因此会出现一个空指针异常。</p>
<p>使用merge方法处理这个问题。</p>
<pre><code>counts.merge(word,1,Interger::sum);
</code></pre><p>​             将word与1关联，否则使用Interger：：sum函数组合原值和1</p>
<p><strong>映射视图</strong></p>
<p>集合框架不认为映射本身是一个集合。不过，可以得到映射的视图——这是实现了Collection接口或某个子接口的对象。</p>
<p>有三种视图：键集、值集合以及键/值对集。键和键/值对可以构成一个集，因为映射中的一个键只能由有一个副本。</p>
<p><strong>弱散列映射</strong></p>
<p>如果有一个值，对应的键已经不再使用了，将会出现什么情况呢？假定对某个键的最后以此引用已经小王，不再有任何途径引用这个值的对象了。但是，由于在程序中的任何部分没有再出现这个键。所以，这个键/值对无法从映射中删除。为什么垃圾回收器不能够删除它呢？</p>
<p>垃圾回收器跟踪活动的对象。只要映射对象是活动的 ，其中的所有桶也是活动的，它们不能被回收。因此需要有程序负责从长期存活的映射表中删除那些无用的值。或者使用WeakHashMap完成这件事情。当对键的唯一引用来自散列类目时，这一数据结构将与垃圾回收器协同工作一起删除键/值对。</p>
<p><strong>视图与包装器</strong></p>
<p>通过使用视图可以获得其他的实现类Collection接口和Map接口的对象。映射类的keySet方法就是。</p>
<p>keySet方法返回一个实现了Set接口的类对象，这个类的方法对原映射进行操作。这种集合称为视图。</p>
<p><strong>轻量级集合包装器</strong></p>
<p>Arrays类的静态方法asList将返回一个包装了普通Java数组的List包装器。这个方法可以将数组传递给一个期望得到列表或集合参数的方法。</p>
<p>asList方法返沪id对象不是ArrayList。它是以恶个视图对象，带有访问底层数组的get和set方法。改变数组大小的所有方法都会排除以此。</p>
<p><strong>遗留的集合</strong></p>
<p>Hashtable类与HashMap类的作用一样，实际上，它们拥有相同的接口。与Vector类的方法一样。Hashtable的方法也是同步的。如果对同步性或与遗留代码的兼容性没有要求，就应该使用HashMap。</p>
<p><strong>属性映射</strong></p>
<p>属性映射是以一个类型非常特殊的映射结构。有以下3个特性：</p>
<p>键与值都是字符串</p>
<p>表可以保存到一个文件中，也可以从文件中加载</p>
<p>使用一个默认的辅助表</p>
<p>实现属性映射的Java平台类称为Properties。</p>

    </div>
    <div class="post-footer">
      
    </div>
    <div class="post-comment">
      
      


<span id="/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E4%B9%9D%E7%AB%A0%E7%AC%94%E8%AE%B0-%E9%9B%86%E5%90%88/" class="leancloud_visitors" data-flag-title="Java核心技术第九章笔记-集合">
    <span class="post-meta-item-text">文章阅读量 </span>
    <span class="leancloud-visitors-count">1000000</span>
    <p></p>
  </span>
<div id="vcomments"></div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script type="text/javascript">
  new Valine({
    el: '#vcomments' ,
    appId: 'cScQmclMsD4OOWCclCP1pNsz-gzGzoHsz',
    appKey: 'dtSaHLmdH3J4ICVVInYg9YFM',
    notify:  false ,
  verify:  false ,
  avatar:'mm',
    placeholder: '说点什么吧...',
    visitor:  true 
  });
</script>

    </div>
  </article>

    </main>
  </body>
</html>
