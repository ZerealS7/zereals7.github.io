<!doctype html>
<html lang="en-us">
  <head>
    <title>SSM第五章-映射器 // Zereal-宋致远技术博客</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.72.0" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75，minimum-scale=0.75, maximum-scale=0.75, user-scalable=no" />
    <meta name="author" content="Zereal" />
    <meta name="description" content="" />
    <meta name="referrer" content="never"/>
    <link rel="stylesheet" href="https://zereals7.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="SSM第五章-映射器"/>
<meta name="twitter:description" content="映射器是MyBatis最复杂且最重要的组件。它由一个接口加上XML文件（或者注解）组成。在映射器中可以配置参数、各类的SQL语句、存储过程、缓存、级联等复杂的内容，并且通过简易的映射规则映射到指定的POJO或者其他对象上，映射器能有效消除JDBC底层的代码。
在MyBatis应用程序开发中，映射器的开发工作量占全部工作量的80%。在MyBatis中映射器的配置顶级元素不多，但是里面的一些细节，比如缓存、级联、#和￥字符的替换参数、存储过程需要我们进一步学习。
MyBatis的映射器也可以使用注解完成，但是它在企业应用不广，原因主要来自3个方面：其一，面对复杂性，SQL会显得无力，尤其是长SQL。其二，注解的可读性比较差。其三，在功能上，注解丢失了XML上下文相互引用的功能。
5.1 概述 parameterMap是MyBatis官方不推荐的元素，可能即将被删除。
5.2 select元素——查询语句 在映射器中select元素代表SQL的select语句，用于查询。在SQL中，select语句是用得最多的语句，在MyBatis中select元素也是用得最多的元素，使用的多就意味着强大和复杂。
   元素 说明 备注     id 它和Mapper的命名空间组合起来是唯一的，供MyBatis调用 如果命名空间和id结合起来不唯一，MyBatis将抛出异常   parameterType 可以给出类的全命名，也可以给出别名，但是别名必须是MyBatis内部定义或者自定义的 ——   parameterMap 即将废弃的元素，不讨论 ——   resultType 定义类的全路径，在允许自动匹配的情况下，结果集将通过JavaBean的规范映射：或定义为int、double、float、map等参数；也可以使用别名，但必须要符合别名的命名规范，且不能和resultMap同时使用 常用的参数之一，比如统计总条数数时可以把它的值设置为int   resultMap 它是映射集的引用，将执行强大的映射功能，我们可以使用resultType和resultMap其中的一个，resultMap能提供自定义映射规则的机会。 是MyBatis最复杂的元素，可以配置映射规则、级联、typeHandler   flushCache 它的作用是在调用SQL后，是否要求MyBatis清空之前查询本地缓存和二级缓存 取值为布尔值，true/false.默认值为false   useCache 启动二级缓存的开关，是否要求MyBatsi将此次结果缓存 取值为布尔值，true/false.默认值为true   timeout 设置超时参数，超时将抛出异常，单位为秒 默认值是数据库厂商提供的JDBC驱动所设置的秒数   fetchSize 获取记录的总条数设定 默认值是数据库厂商提供的JDBC驱动所设置的条数   statementType 告诉Mybatis使用哪个JDBC的Statement工作，取值为STATEMENT、PREPARED、CALLABLE 默认值为PREPARED   resultSetType 这是对JDBC的resultSet接口而言，它的值包括FORWARD_ONLY（游标允许向前访问）、SCROLL_SENSITIVE（双向滚动，但不及时更新，就是如果数据库里的数据修改过，并不再resultSet中反映出来）、SCROLL_INSENSITIVE（双向滚动，并及时跟踪数据库的更新，以便更改resultSet中的数据） 默认值是数据库厂商提供的JDBC驱动所设置的   databaseId 配置使用 提供多种数据库的支持   resultOrdered 这个设置仅适用于嵌套结果select语句，如果为true，就是假设包含了嵌套结果集或是分组了，当返回一个主结果行是，就不能引用前面结果集了。这就确保了在获取嵌套的结果集时不至于导致内存不够用。 取值为布尔值，true/false。默认值为false   resultSets 适用于多个结果集的情况，它将列出执行SQL后每个结果集的名称，每个名称之间用逗号分隔 很少使用    在实际工作中用得最多的是id、parameterType、resultType、resultMap，如果要设置缓存，还会使用到flushCache、useCache，其他的都是不常用的功能。这里主要讨论id、parameterType、resultType、resultMap及它们的映射规则。"/>

    <meta property="og:title" content="SSM第五章-映射器" />
<meta property="og:description" content="映射器是MyBatis最复杂且最重要的组件。它由一个接口加上XML文件（或者注解）组成。在映射器中可以配置参数、各类的SQL语句、存储过程、缓存、级联等复杂的内容，并且通过简易的映射规则映射到指定的POJO或者其他对象上，映射器能有效消除JDBC底层的代码。
在MyBatis应用程序开发中，映射器的开发工作量占全部工作量的80%。在MyBatis中映射器的配置顶级元素不多，但是里面的一些细节，比如缓存、级联、#和￥字符的替换参数、存储过程需要我们进一步学习。
MyBatis的映射器也可以使用注解完成，但是它在企业应用不广，原因主要来自3个方面：其一，面对复杂性，SQL会显得无力，尤其是长SQL。其二，注解的可读性比较差。其三，在功能上，注解丢失了XML上下文相互引用的功能。
5.1 概述 parameterMap是MyBatis官方不推荐的元素，可能即将被删除。
5.2 select元素——查询语句 在映射器中select元素代表SQL的select语句，用于查询。在SQL中，select语句是用得最多的语句，在MyBatis中select元素也是用得最多的元素，使用的多就意味着强大和复杂。
   元素 说明 备注     id 它和Mapper的命名空间组合起来是唯一的，供MyBatis调用 如果命名空间和id结合起来不唯一，MyBatis将抛出异常   parameterType 可以给出类的全命名，也可以给出别名，但是别名必须是MyBatis内部定义或者自定义的 ——   parameterMap 即将废弃的元素，不讨论 ——   resultType 定义类的全路径，在允许自动匹配的情况下，结果集将通过JavaBean的规范映射：或定义为int、double、float、map等参数；也可以使用别名，但必须要符合别名的命名规范，且不能和resultMap同时使用 常用的参数之一，比如统计总条数数时可以把它的值设置为int   resultMap 它是映射集的引用，将执行强大的映射功能，我们可以使用resultType和resultMap其中的一个，resultMap能提供自定义映射规则的机会。 是MyBatis最复杂的元素，可以配置映射规则、级联、typeHandler   flushCache 它的作用是在调用SQL后，是否要求MyBatis清空之前查询本地缓存和二级缓存 取值为布尔值，true/false.默认值为false   useCache 启动二级缓存的开关，是否要求MyBatsi将此次结果缓存 取值为布尔值，true/false.默认值为true   timeout 设置超时参数，超时将抛出异常，单位为秒 默认值是数据库厂商提供的JDBC驱动所设置的秒数   fetchSize 获取记录的总条数设定 默认值是数据库厂商提供的JDBC驱动所设置的条数   statementType 告诉Mybatis使用哪个JDBC的Statement工作，取值为STATEMENT、PREPARED、CALLABLE 默认值为PREPARED   resultSetType 这是对JDBC的resultSet接口而言，它的值包括FORWARD_ONLY（游标允许向前访问）、SCROLL_SENSITIVE（双向滚动，但不及时更新，就是如果数据库里的数据修改过，并不再resultSet中反映出来）、SCROLL_INSENSITIVE（双向滚动，并及时跟踪数据库的更新，以便更改resultSet中的数据） 默认值是数据库厂商提供的JDBC驱动所设置的   databaseId 配置使用 提供多种数据库的支持   resultOrdered 这个设置仅适用于嵌套结果select语句，如果为true，就是假设包含了嵌套结果集或是分组了，当返回一个主结果行是，就不能引用前面结果集了。这就确保了在获取嵌套的结果集时不至于导致内存不够用。 取值为布尔值，true/false。默认值为false   resultSets 适用于多个结果集的情况，它将列出执行SQL后每个结果集的名称，每个名称之间用逗号分隔 很少使用    在实际工作中用得最多的是id、parameterType、resultType、resultMap，如果要设置缓存，还会使用到flushCache、useCache，其他的都是不常用的功能。这里主要讨论id、parameterType、resultType、resultMap及它们的映射规则。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zereals7.github.io/post/ssm%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%98%A0%E5%B0%84%E5%99%A8/" />
<meta property="article:published_time" content="2021-04-22T18:36:47+08:00" />
<meta property="article:modified_time" content="2021-04-22T18:36:47+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://zereals7.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="Zereal" /></a>
      <h1>Zereal</h1>
      <p>Java coder</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/ZerealS7" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">SSM第五章-映射器</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Apr 22, 2021
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          7 min read
        </div></div>
    </header>
    <div class="post-content">
      <p>映射器是MyBatis最复杂且最重要的组件。它由一个接口加上XML文件（或者注解）组成。在映射器中可以配置参数、各类的SQL语句、存储过程、缓存、级联等复杂的内容，并且通过简易的映射规则映射到指定的POJO或者其他对象上，映射器能有效消除JDBC底层的代码。</p>
<p>在MyBatis应用程序开发中，映射器的开发工作量占全部工作量的80%。在MyBatis中映射器的配置顶级元素不多，但是里面的一些细节，比如缓存、级联、#和￥字符的替换参数、存储过程需要我们进一步学习。</p>
<p>MyBatis的映射器也可以使用注解完成，但是它在企业应用不广，原因主要来自3个方面：其一，面对复杂性，SQL会显得无力，尤其是长SQL。其二，注解的可读性比较差。其三，在功能上，注解丢失了XML上下文相互引用的功能。</p>
<h1 id="51-概述">5.1 概述</h1>
<p><img src="https://gitee.com/zerealsong/blogimage/raw/master/img/20210423145832.jpg" alt="2021-04-0654_4 (Copy)"></p>
<p>parameterMap是MyBatis官方不推荐的元素，可能即将被删除。</p>
<h1 id="52-select元素查询语句">5.2 select元素——查询语句</h1>
<p>在映射器中select元素代表SQL的select语句，用于查询。在SQL中，select语句是用得最多的语句，在MyBatis中select元素也是用得最多的元素，使用的多就意味着强大和复杂。</p>
<table>
<thead>
<tr>
<th align="center">元素</th>
<th align="center">说明</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">id</td>
<td align="center">它和Mapper的命名空间组合起来是唯一的，供MyBatis调用</td>
<td align="center">如果命名空间和id结合起来不唯一，MyBatis将抛出异常</td>
</tr>
<tr>
<td align="center">parameterType</td>
<td align="center">可以给出类的全命名，也可以给出别名，但是别名必须是MyBatis内部定义或者自定义的</td>
<td align="center">——</td>
</tr>
<tr>
<td align="center">parameterMap</td>
<td align="center">即将废弃的元素，不讨论</td>
<td align="center">——</td>
</tr>
<tr>
<td align="center">resultType</td>
<td align="center">定义类的全路径，在允许自动匹配的情况下，结果集将通过JavaBean的规范映射：或定义为int、double、float、map等参数；也可以使用别名，但必须要符合别名的命名规范，且不能和resultMap同时使用</td>
<td align="center">常用的参数之一，比如统计总条数数时可以把它的值设置为int</td>
</tr>
<tr>
<td align="center">resultMap</td>
<td align="center">它是映射集的引用，将执行强大的映射功能，我们可以使用resultType和resultMap其中的一个，resultMap能提供自定义映射规则的机会。</td>
<td align="center">是MyBatis最复杂的元素，可以配置映射规则、级联、typeHandler</td>
</tr>
<tr>
<td align="center">flushCache</td>
<td align="center">它的作用是在调用SQL后，是否要求MyBatis清空之前查询本地缓存和二级缓存</td>
<td align="center">取值为布尔值，true/false.默认值为false</td>
</tr>
<tr>
<td align="center">useCache</td>
<td align="center">启动二级缓存的开关，是否要求MyBatsi将此次结果缓存</td>
<td align="center">取值为布尔值，true/false.默认值为true</td>
</tr>
<tr>
<td align="center">timeout</td>
<td align="center">设置超时参数，超时将抛出异常，单位为秒</td>
<td align="center">默认值是数据库厂商提供的JDBC驱动所设置的秒数</td>
</tr>
<tr>
<td align="center">fetchSize</td>
<td align="center">获取记录的总条数设定</td>
<td align="center">默认值是数据库厂商提供的JDBC驱动所设置的条数</td>
</tr>
<tr>
<td align="center">statementType</td>
<td align="center">告诉Mybatis使用哪个JDBC的Statement工作，取值为STATEMENT、PREPARED、CALLABLE</td>
<td align="center">默认值为PREPARED</td>
</tr>
<tr>
<td align="center">resultSetType</td>
<td align="center">这是对JDBC的resultSet接口而言，它的值包括FORWARD_ONLY（游标允许向前访问）、SCROLL_SENSITIVE（双向滚动，但不及时更新，就是如果数据库里的数据修改过，并不再resultSet中反映出来）、SCROLL_INSENSITIVE（双向滚动，并及时跟踪数据库的更新，以便更改resultSet中的数据）</td>
<td align="center">默认值是数据库厂商提供的JDBC驱动所设置的</td>
</tr>
<tr>
<td align="center">databaseId</td>
<td align="center">配置使用</td>
<td align="center">提供多种数据库的支持</td>
</tr>
<tr>
<td align="center">resultOrdered</td>
<td align="center">这个设置仅适用于嵌套结果select语句，如果为true，就是假设包含了嵌套结果集或是分组了，当返回一个主结果行是，就不能引用前面结果集了。这就确保了在获取嵌套的结果集时不至于导致内存不够用。</td>
<td align="center">取值为布尔值，true/false。默认值为false</td>
</tr>
<tr>
<td align="center">resultSets</td>
<td align="center">适用于多个结果集的情况，它将列出执行SQL后每个结果集的名称，每个名称之间用逗号分隔</td>
<td align="center">很少使用</td>
</tr>
</tbody>
</table>
<p>在实际工作中用得最多的是id、parameterType、resultType、resultMap，如果要设置缓存，还会使用到flushCache、useCache，其他的都是不常用的功能。这里主要讨论id、parameterType、resultType、resultMap及它们的映射规则。</p>
<h2 id="521-简单的select元素的应用">5.2.1 简单的select元素的应用</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>select id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;countUserByFirstName&#34;</span> parameterType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;string&#34;</span> resultType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;int&#34;</span><span style="color:#f92672">&gt;</span>
select <span style="color:#a6e22e">count</span><span style="color:#f92672">(*)</span> total from t_user
where user_name like <span style="color:#a6e22e">concat</span><span style="color:#f92672">(</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">(</span>firstName<span style="color:#f92672">),</span><span style="color:#960050;background-color:#1e0010">‘</span><span style="color:#f92672">%</span><span style="color:#960050;background-color:#1e0010">’</span><span style="color:#f92672">)</span>
<span style="color:#f92672">&lt;/</span>select<span style="color:#f92672">&gt;</span>
</code></pre></div><ul>
<li>id配合Mapper的全限定名，联合成为一个唯一的标识，用于标识这条SQL。</li>
<li>parameterType表示这条SQL接受的参数类型，可以是MyBatis系统定义或者自定义的别名，比如int、string、float等，也可以是类的全限定名，比如com.learn.ssmchapter5.pojo.User</li>
<li>resultType表示这条SQL返回的结果类型，与parameterTYpe一样，可以是系统定义或者自定义的别名，也可以是类的全限定名。</li>
<li>#{firstName}是被传递进去的参数。</li>
</ul>
<p>只有这条SQL还不够，我们还需要给一个接口方法程序才能运行起来，比如SQL可以这样定义接口方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span>  Integer <span style="color:#a6e22e">countUserByFirstName</span><span style="color:#f92672">(</span>String firstName<span style="color:#f92672">);</span>
</code></pre></div><h2 id="522-自动映射和驼峰映射">5.2.2 自动映射和驼峰映射</h2>
<p>MyBatis提供了自动映射功能，在默认情况下自动映射是开启的，使用它的好处在于能有效减少大量的映射配置，从而减少工作量。</p>
<p>在setting元素中有两个可以配置的选项autoMappingBehavior和mapUnderscoreToCamelCase;它们是控制自动映射和驼峰映射的开关。一般而言，自动映射会使用得多一些，因为可以通过SQL别名机制处理一些细节，比较灵活，而驼峰映射则要求比较严苛，所以在实际中应用不算太广。</p>
<p>配置自动映射的autoMappingBehavior选项的取值范围是：</p>
<ul>
<li>NONE，不进行自动映射</li>
<li>PARTIAL,默认值，只对没有嵌套结果进行自动映射。</li>
<li>FULL，对所有的结果集进行自动映射，包括嵌套结果集。</li>
</ul>
<p>在默认情况下，使用默认的PARTIAL级别就可以了。为了实现自动映射，首先要给出POJO——Role .</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Role</span><span style="color:#f92672">{</span>
	<span style="color:#66d9ef">private</span> Long id<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> String roleName<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> String note<span style="color:#f92672">;</span>
	
	<span style="color:#75715e">/**setter and getter**/</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这是一个十分简单的POJO，它定义了3个属性及其setter和getter方法。如果编写SQL列名和属性名保持一致，那么它就会形成自动映射，比如通过角色编号（id)获取角色的信息。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>select id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;getRole&#34;</span> parameterType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;long&#34;</span>
	resultType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.learn.ssm.chapter5.pojo.Role&#34;</span><span style="color:#f92672">&gt;</span>
	select id<span style="color:#f92672">,</span>role_name as roleName<span style="color:#f92672">,</span>note from t_role where id<span style="color:#f92672">=</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>id<span style="color:#f92672">}</span>
	<span style="color:#f92672">&lt;/</span>select<span style="color:#f92672">&gt;</span>
</code></pre></div><p>原来的列名role_name被别名roleName代替了，这样就和POJO上的属性名称保持一致了。此时MyBatis就会将这个结果集 映射到POJO的属性roleName上，自动完成映射，而无须再进行 任何配置，明显减少了工作量。</p>
<p>如果系统都严格按照驼峰命名法（比如，数据库字段为role_name，则POJO属性名为roleName）,那么只要再配置项把mapUnderscoreToCamelCase设置为true即可。如果这样做上面的SQL可以改写成：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">select id<span style="color:#f92672">,</span>role_name<span style="color:#f92672">,</span>note from t_role where id<span style="color:#f92672">=</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>id<span style="color:#f92672">}</span>
</code></pre></div><p>MyBatis会严格按照驼峰命名的方式做自动映射，只是这样会要求数据字段和POJO属性名严格对应，降低了灵活性。 这也是实际工作中需要考虑的问题。</p>
<p>自动映射和驼峰映射都建立再SQL列名和POJO属性名的映射关系上，而现实中会更加复杂，比如可能有些字段有主表和从表关联的级联，又如typeHandler的复杂转换规则，此时resultType元素是无法满足这些需求的。如果需要更为强大的映射规则，则需要考虑使用resultMap,它是MyBatis中最复杂的元素。</p>
<h2 id="523-传递多个参数">5.2.3 传递多个参数</h2>
<p><strong>1.使用map接口传递参数</strong></p>
<p>再MyBatis中允许map接口通过键值对传递多个参数，把接口方法定义为：</p>
<pre><code>public List&lt;Role&gt; findRolesByMap（Map&lt;String,Object&gt; parameterMap）;
</code></pre><p>此时，传递给映射器的是一个map对象，使用它在SQL中设置对应的参数</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>select id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;findRolesByMap&#34;</span> parameterType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;map&#34;</span>
	resultType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;role&#34;</span><span style="color:#f92672">&gt;</span>
	select id<span style="color:#f92672">,</span>role_name as roleName<span style="color:#f92672">,</span>note from t_role 
    where role_name like <span style="color:#a6e22e">concat</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">,</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>roleName<span style="color:#f92672">},</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">)</span>
    and note like <span style="color:#a6e22e">concat</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">,</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>roleName<span style="color:#f92672">},</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">)</span>
	<span style="color:#f92672">&lt;/</span>select<span style="color:#f92672">&gt;</span>
</code></pre></div><p>注意，参数roleName和note，要求的是map的键,按以下的方法设置map参数，并传递。</p>
<pre><code>RoleMapper  roleMapper=sqlSesision.getMapper（RoleMapper.class);
Map&lt;String，Object&gt; parameterMap =new HashMap&lt;String,Object&gt;();
parameterMap.put(&quot;roleName&quot;,&quot;1&quot;);
parameterMap.put(&quot;note&quot;,&quot;1&quot;);
List&lt;Role&gt; roles=roleMapper.findRolesByMap(parameterMap);
</code></pre><p>在SQL中的参数标识将会被这里设置的参数所取代，这样就能够允许了。严格来说，map适用于几乎所有的场景，但是我们用得不多。原因有两个：首先，map是一个键值对应的集合，使用者要通过阅读它的键，才能明了器作用；其次，使用map不能限定其传递的数据类型，因此业务性质不强，可读性差，使用者要读懂代码才能知道需要传递什么参数给它，所有不推荐用这种方式传递多个参数。</p>
<p><strong>2.使用注解传递多个参数</strong></p>
<p>使用map传递多个参数的弊病——可读性差。为此MyBatis为开发者提供了一个注解@Param，可以通过它取定义映射器的参数名称，使用它可以得到更好的可读性。把接口方法定义为：</p>
<pre><code>public List&lt;Role&gt; findRolesByAnnotation(@Param(&quot;roleName&quot;)String rolename,
@Param(&quot;note&quot;)String note);
</code></pre><p>此时段代码的可读性大大提高了，使用者能明确参数roelName是角色名称，而note是备注，一目了然，这个时候需要修改映射文件的代码</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>select id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;findRolesByMap&#34;</span>
	resultType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;role&#34;</span><span style="color:#f92672">&gt;</span>
	select id<span style="color:#f92672">,</span>role_name as roleName<span style="color:#f92672">,</span>note from t_role 
    where role_name like <span style="color:#a6e22e">concat</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">,</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>roleName<span style="color:#f92672">},</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">)</span>
    and note like <span style="color:#a6e22e">concat</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">,</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>roleName<span style="color:#f92672">},</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">)</span>
	<span style="color:#f92672">&lt;/</span>select<span style="color:#f92672">&gt;</span>
</code></pre></div><p>注意，此时并不需要给出parameterType属性，让MyBatis自动探索便可以了。通过改写使可读性大大提高，使用者也方便了，但是会带来一个麻烦。如果SQL很复杂，拥有大于10个参数，那么接口方法的参数个数就多了，使用起来就很不容易，不过不必担心，MyBatis还提供传递JavaBean的形式。</p>
<p><strong>3.通过JavaBean传递多个参数</strong></p>
<p>先定义一个参数的POJO——RoeParams</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RoleParams</span><span style="color:#f92672">{</span>
	<span style="color:#66d9ef">private</span> String roleName<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> String note<span style="color:#f92672">;</span>
	<span style="color:#75715e">/**setter and gettter**/</span>
<span style="color:#f92672">}</span>

</code></pre></div><p>此时把接口方法定义为</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> List<span style="color:#f92672">&lt;</span>Role<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">findRolesByBean</span><span style="color:#f92672">(</span>RoleParams roleParam<span style="color:#f92672">);</span>
</code></pre></div><p>Java Bean的属性roleName代表角色名称，而note代表备注，按下面的方法修改映射文件：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>select id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;findRolesByMap&#34;</span> parameterType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.learn.ssm.chapter5.param.RoleParams&#34;</span>
	resultType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;role&#34;</span><span style="color:#f92672">&gt;</span>
	select id<span style="color:#f92672">,</span>role_name as roleName<span style="color:#f92672">,</span>note from t_role 
    where role_name like <span style="color:#a6e22e">concat</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">,</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>roleName<span style="color:#f92672">},</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">)</span>
    and note like <span style="color:#a6e22e">concat</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">,</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>roleName<span style="color:#f92672">},</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">)</span>
	<span style="color:#f92672">&lt;/</span>select<span style="color:#f92672">&gt;</span>
</code></pre></div><p>引入Java Bean定义的属性作为参数，然后查询</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">RoleMapper  roleMapper<span style="color:#f92672">=</span>sqlSesision<span style="color:#f92672">.</span><span style="color:#a6e22e">getMapper</span><span style="color:#960050;background-color:#1e0010">（</span>RoleMapper<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">);</span>
RoleParams roleParams <span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> RoleParams<span style="color:#f92672">();</span>
roleParams<span style="color:#f92672">.</span><span style="color:#a6e22e">setRoleName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;1&#34;</span><span style="color:#f92672">);</span>
roleParams<span style="color:#f92672">.</span><span style="color:#a6e22e">setNote</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;1&#34;</span><span style="color:#f92672">);</span>
List<span style="color:#f92672">&lt;</span>Role<span style="color:#f92672">&gt;</span> roles<span style="color:#f92672">=</span>roleMapper<span style="color:#f92672">.</span><span style="color:#a6e22e">findRolesByBean</span><span style="color:#f92672">(</span>roleParams<span style="color:#f92672">);</span>
</code></pre></div><p><strong>4.混合使用</strong></p>
<p>在某些情况下可能需要混合使用几种方法来传递参数。举个例子，查询一个角色可以通过角色名称和备注进行查询，于此同时还需要支持分页，而分页的POJO实现如下：</p>
<pre><code>public class PageParams{
private int sttart;
private int limit;
/**setter and getter**/
}
</code></pre><p>这个时候接口设计如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> List<span style="color:#f92672">&lt;</span>Role<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">findByMix</span><span style="color:#f92672">(</span><span style="color:#a6e22e">@Param</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;params&#34;</span><span style="color:#f92672">)</span> RoleParams roleParams<span style="color:#f92672">,</span><span style="color:#a6e22e">@Param</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;page&#34;</span><span style="color:#f92672">)</span> PageParam PageParam<span style="color:#f92672">);</span>
</code></pre></div><p>这样不仅是可行的，也是合理的，当然MyBatis也为此做了支持，把映射文件修改为如下</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>select id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;findByMix&#34;</span>
	resultType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;role&#34;</span><span style="color:#f92672">&gt;</span>
	select id<span style="color:#f92672">,</span>role_name as roleName<span style="color:#f92672">,</span>note from t_role 
    where role_name like <span style="color:#a6e22e">concat</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">,</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>roleName<span style="color:#f92672">},</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">)</span>
    and note like <span style="color:#a6e22e">concat</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">,</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>roleName<span style="color:#f92672">},</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">)</span>
    limit <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">(</span>page<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">),</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">(</span>page<span style="color:#f92672">.</span><span style="color:#a6e22e">limit</span><span style="color:#f92672">)</span>
	<span style="color:#f92672">&lt;/</span>select<span style="color:#f92672">&gt;</span>
</code></pre></div><p>这样就能使用混合参数了，其中MyBatis对params和page这类Java Bean参数提供了EL（中间语言）支持，为编程带来了很多的便利。</p>
<p><strong>5.总结</strong></p>
<ul>
<li>使用map传递参数导致业务可读性的丧失，导致后续扩展和维护的困难，在实际的应用中要果断废弃这种方式。</li>
<li>使用@Param注解传递多个参数，受到参数个数的影响。当n&lt;=5时，这是最佳的传参方式，它比JavaBean更好，因为它更加直观；当n&gt;5时，多个参数将给调用带来困难，此时不推荐使用它。</li>
<li>当参数个数多于5个时，建议使用Java Bean方式。</li>
<li>对于使用混合参数的，要明确参数的合理性。</li>
</ul>
<p>5.2.4 使用resultMap映射结果集</p>
<p>自动映射和驼峰规则比较简单，无法定义多的属性，比如typeHandler 、级联等。为了支持复杂的映射，select元素提供了resultMap属性。先定义resultMap属性。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>mapper namespace<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.learn.ssm.chapter5.mapper.RoleMapper&#34;</span><span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;</span>resultMap id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;roleMap&#34;</span> type<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;role&#34;</span><span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;</span>id property<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;id&#34;</span> column<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;id&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;</span>result property<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;roleName&#34;</span> column<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;role_name&#34;</span><span style="color:#f92672">/</span> <span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;/</span>result<span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;</span>select id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;getRoleUserResultMap&#34;</span><span style="color:#f92672">&gt;</span>
parameterType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;long&#34;</span> resultMap<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;roleMap&#34;</span><span style="color:#f92672">&gt;</span>
select id<span style="color:#f92672">,</span>role_name<span style="color:#f92672">,</span>note from t_role where id<span style="color:#f92672">=</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>id<span style="color:#f92672">}</span>
<span style="color:#f92672">&lt;/</span>select<span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;/</span>mapper<span style="color:#f92672">&gt;</span>

</code></pre></div><ul>
<li>resultMap元素定义了一个roleMap，它的属性id代表它的标识，type代表使用哪个类 作为其映射的类，可以是别名或者全限定名，role是com.learn.ssm.chapter5.pojo.Role的别名。</li>
<li>它的子元素id代表resultMap的主键，而result代表其属性，id和result元素的属性property代表POJO的属性名称，而column代表SQL的列名。把POJO的属性和SQL的列名做对应，例如POJO的属性roleName，就用SQL的列名role_name建立映射关系。</li>
<li>在select元素中的属性resultMap制定了采用哪个resultMap作为其映射规则。</li>
</ul>
<h2 id="524-分页参数rowbounds">5.2.4 分页参数RowBounds</h2>
<p>MyBatis不仅支持分页，它还内置了一个专门处理分页的类——RowBounds。</p>
<p><strong>RowBounds源码</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">package</span> org.apache.ibatis.session<span style="color:#f92672">;</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RowBounds</span><span style="color:#f92672">{</span>
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> NO_ROW_OFFSET<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> NO_ROW_LIMIT<span style="color:#f92672">=</span>Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">;</span>
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> RowBounds DEFAULT <span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> RowBounds<span style="color:#f92672">();</span>
	
	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> offset<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> limit<span style="color:#f92672">;</span>
	
	<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">RowBounds</span><span style="color:#f92672">(){</span>
	<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">offset</span> <span style="color:#f92672">=</span> NO_ROW_OFFSET<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">limit</span> <span style="color:#f92672">=</span> NO_ROW_LIMIT<span style="color:#f92672">;</span>
	<span style="color:#f92672">}</span>
	
	<span style="color:#66d9ef">public</span> RowBounds<span style="color:#960050;background-color:#1e0010">（</span><span style="color:#66d9ef">int</span> offset<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> limit<span style="color:#f92672">){</span>
		<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">offset</span><span style="color:#f92672">=</span>offset<span style="color:#f92672">;</span>
		<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">limit</span><span style="color:#f92672">=</span>limit<span style="color:#f92672">;</span>
	<span style="color:#f92672">}</span>
	
	<span style="color:#75715e">/****setter and getter****/</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>offset 属性是偏移量，即从第几行开始读取记录。Limit是限制 条数，从源码可知，默认值为0和Java的最大整数（2147483647），使用它十分的简单，只要给接口增加一个RowBounds参数即可。</p>
<pre><code>public List&lt;Role&gt; findByRowBounds（@Param(&quot;roleName&quot;) String rolename,@Param(&quot;note&quot;) String note,RowBounds rowBounds）;
</code></pre><p>对于SQL而言</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>select id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;findByRowBounds&#34;</span>
	resultType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;role&#34;</span><span style="color:#f92672">&gt;</span>
	select id<span style="color:#f92672">,</span>role_name as roleName<span style="color:#f92672">,</span>note from t_role 
    where role_name like <span style="color:#a6e22e">concat</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">,</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>roleName<span style="color:#f92672">},</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">)</span>
    and note like <span style="color:#a6e22e">concat</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">,</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>roleName<span style="color:#f92672">},</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">)</span>
	<span style="color:#f92672">&lt;/</span>select<span style="color:#f92672">&gt;</span>
</code></pre></div><p>没有任何关于RowBounds参数的信息，它是MyBatis的一个附加参数，MyBatis会自动识别它，据此进行分页。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">SqlSession sqlSession <span style="color:#f92672">=</span><span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#66d9ef">try</span><span style="color:#f92672">{</span>
	sqlSerssion<span style="color:#f92672">=</span>SqlSessionFactoeyUtils<span style="color:#f92672">.</span><span style="color:#a6e22e">openSqlSession</span><span style="color:#f92672">();</span>
	RoleMapper roleMapper<span style="color:#f92672">=</span>sqlSession<span style="color:#f92672">.</span><span style="color:#a6e22e">getMapper</span><span style="color:#f92672">(</span>RoleMapper<span style="color:#f92672">.</span><span style="color:#a6e22e">classs</span><span style="color:#f92672">);</span>
	RowBounds rowBounds<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> RowBounds<span style="color:#f92672">(</span>0<span style="color:#f92672">,</span>20<span style="color:#f92672">);</span>
	List<span style="color:#f92672">&lt;</span>Role<span style="color:#f92672">&gt;</span> roleList <span style="color:#f92672">=</span>roleMapper<span style="color:#f92672">.</span><span style="color:#a6e22e">findByRowBounds</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;role_name&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;note&#34;</span><span style="color:#f92672">,</span>rowBounds<span style="color:#f92672">);</span>
	System<span style="color:#f92672">.</span><span style="color:#a6e22e">err</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>roleList<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">());</span>
<span style="color:#f92672">}</span><span style="color:#66d9ef">catch</span><span style="color:#f92672">(</span>Exception e<span style="color:#f92672">){</span>
	e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span><span style="color:#66d9ef">finally</span><span style="color:#f92672">{</span>
	<span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>sqlSession<span style="color:#f92672">!=</span><span style="color:#66d9ef">null</span><span style="color:#f92672">){</span>
	sqlSession<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">;</span>
	<span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>运行代码就可以限定查询返回至多20条记录的结果，而这里要注意RowBounds分页运行的场景，它之恶能运用于一些小数据量的查询。RowBounds分页的原理是执行SQL的查询后，按照偏移量和限制条数返回查询结果，所以对于大量更多数据查询，它的性能并不佳，此时可以通过分页插件去处理。</p>
<h1 id="53-insert元素插入语句">5.3 insert元素——插入语句</h1>
<h2 id="531-概述">5.3.1 概述</h2>
<p>执行select的基础是先插入数据，而插入数据依赖于insert语句。相对于select而言，insert语句就简单多了，在MyBatis中insert语句就简单多了，在MyBatis中insert语句可以配置以下属性。</p>
<p>insert语句的配置</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>idw</td>
<td>SQL编号，用于标识这条SQL</td>
<td>命名空间+id+databaseId唯一，否则MyBatis会抛出异常</td>
</tr>
<tr>
<td>parameterType</td>
<td>参数类型，同select元素</td>
<td>和select一样，可以是单个参数或者多个参数</td>
</tr>
<tr>
<td>parameterMap</td>
<td>参数的Map,即将废弃</td>
<td>本书不讨论它</td>
</tr>
<tr>
<td>flushCache</td>
<td>是否刷新缓存，可以配置true/false,为true时，插入时会刷新一级和二级缓存，否则不刷新</td>
<td>默认值为true</td>
</tr>
<tr>
<td>timeout</td>
<td>超时时间，单位为秒</td>
<td></td>
</tr>
<tr>
<td>statementType</td>
<td>STATEMENT、PRTEPARED活泼CALLABLE中的以恶搞。这回让MyBatis分别使用Statement、PreparedStatement（预编译）或CallableStatement(存储过程)</td>
<td>默认值为PREPARED</td>
</tr>
<tr>
<td>userGeneratedKeys</td>
<td>是否启JDBC的getGeneratedKeys方法来取出由数据库内部生成的主键。（比如MySQL和SQL Server这样的数据库表的自增主键）</td>
<td>默认值为false</td>
</tr>
<tr>
<td>keyProperty</td>
<td>（仅对insert和update有用）唯一标记一个属性，MyBatis会通过getGeneratedKeys的返回值，或者通过insert语句的selectKey子元素设置它的键值。如果是复合主键，要把每一个名称用逗号（，）隔开</td>
<td>默认值为unset。不能和keyColumn连用</td>
</tr>
<tr>
<td>keyColumn</td>
<td>（仅对insert和update有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像PostgreSQL）中是必须的，当主键列不是表中的第一列需要设置。如果是复合主键，需要把每一个名称用逗号（，）隔开</td>
<td>不能和keyProperty连用</td>
</tr>
<tr>
<td>datasbaseId</td>
<td>参见本书的4.9节</td>
<td>——</td>
</tr>
</tbody>
</table>
<p>MyBatis在执行完一条insert语句后，会返回一个整数表示其影响的记录数。</p>
<h2 id="532-简单的insert语句的应用">5.3.2 简单的insert语句的应用</h2>
<p>写一个SQL插入角色，这是一条最简单的插入语句。</p>
<p><strong>插入角色</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>insert id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;insertRole&#34;</span> parameterType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;role&#34;</span><span style="color:#f92672">&gt;</span>
insert into <span style="color:#a6e22e">t_role</span><span style="color:#f92672">(</span>role_name<span style="color:#f92672">,</span>note<span style="color:#f92672">)</span> values<span style="color:#f92672">(</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>roleName<span style="color:#f92672">},</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>note<span style="color:#f92672">})</span>
<span style="color:#f92672">&lt;</span>insert<span style="color:#f92672">&gt;</span>
</code></pre></div><ul>
<li>id 标识出这条SQL，结合命名空间让MyBatis能够找到它。</li>
<li>parameterType代表传入参数类型。</li>
</ul>
<p>没有配置的属性将采用默认值，这样就完成了一个角色的插入。</p>
<h2 id="533-主键回填">5.3.3 主键回填</h2>
<p>上面展示了最简单的插入语句，但是它并没有插入id列，因为MySQL中的表格采用自增主键，MySQL数据库会为该记录生成对应的主键。有时候还可能需要继续使用这个主键，用以关联其他业务，因此有时候把它取到是十分必要的，比如新增用户时，首先会插入用户表的记录，然后插入用户和角色关系表，插入用户和角色关系表，插入用户时如果没有办法取到用户的主键，那么就没有办法插入用户和角色关系表了，因此在这个时候要拿到对应的主键，以便后面的操作，MyBatis提供了这样的这次hi。</p>
<p>JDBC中的Statement对象在执行插入的SQL后，可以通过getGeneratedKeys方法获得数据库生成的主键（需要数据库驱动支持），这样便能达到获取主键的功能。在insert语句中有一个开关属性useGeneratedKeys，用来控制是否打开这个功能，它的默认值为false。当打开了这个开关，还要配置其属性keyProperty或keyColumn,告诉系统把生成的主键放入哪个属性中，如果存在多个主键，就要用逗号（，）将它们隔开。</p>
<p>返回主键</p>
<pre><code>&lt;insert id=&quot;insertRole&quot; parameterType=&quot;role&quot;
useGenenratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
insert into t_role(role_name,note) values(#{roleName},#{note})
&lt;/insert&gt;
</code></pre><p>useGeneratedKeys代表采用JDBC的Statement对象的getGeneratedKeys方法返回主键，而keyProperty则代表将用哪个POJO的属性去匹配这个主键，这里是id，说明它会用数据库生成的主键去赋值给这个POJO，测试主键回填的结果。</p>
<p>代码中设置了断点，在断点前并没有给role对象的id属性复制，而在执行InsertRole方法后，通过监控role对象，就可以发现MyBatis给这个对象的id赋了值，拿到这个值，就可以在业务代码中执行下一步的关联和操作了。</p>
<p><img src="https://gitee.com/zerealsong/blogimage/raw/master/img/20210424021927.jpg" alt="2021-04-2418 (Copy)"></p>
<h2 id="534-自定义主键">5.3.4 自定义主键</h2>
<p>有时候主键可能依赖于某些规则，比如取消角色表（t）的id递增规则，而将其规则为：</p>
<ul>
<li>当角色表记录 为空，id 设置为1。</li>
<li>当角色表记录不为空时，id设置为当前id加3。</li>
</ul>
<p>MyBatis对这样的场景也提供了支持，它主要依赖于selectKey元素进行支持，它允许自定义键值的生成规则。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>insert id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;insertRole&#34;</span> parameterType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;role&#34;</span><span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;</span>selectKey keyProperty <span style="color:#f92672">=</span><span style="color:#e6db74">&#34;id&#34;</span> resultType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;long&#34;</span> order<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;BEFORE&#34;</span><span style="color:#f92672">&gt;</span>
select <span style="color:#a6e22e">if</span> <span style="color:#f92672">(</span>max<span style="color:#f92672">(</span>id<span style="color:#f92672">)=</span><span style="color:#66d9ef">null</span><span style="color:#f92672">,</span>1<span style="color:#f92672">,</span>max<span style="color:#f92672">(</span>id<span style="color:#f92672">)+</span>3<span style="color:#f92672">)</span> from t_role
<span style="color:#f92672">&lt;/</span>selectKey<span style="color:#f92672">&gt;</span>
insert into <span style="color:#a6e22e">t_role</span><span style="color:#f92672">(</span>id<span style="color:#f92672">,</span>role_name<span style="color:#f92672">,</span>note <span style="color:#a6e22e">values</span><span style="color:#f92672">(</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>id<span style="color:#f92672">},</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>roleName<span style="color:#f92672">},</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>note<span style="color:#f92672">})</span>
<span style="color:#f92672">&lt;/</span>insert<span style="color:#f92672">&gt;</span>
</code></pre></div><p>上述代码定义了selectKeyyuasnu ,它的keyProperty指定了采用哪个属性作为POJO的主键。resultType告诉MyBatis将返回一个long型的结果集，而order设置为BEFORE,说明它将于当前定义的SQL前执行。通过这样就可以自定义主键的规则，可见MyBatis十分灵活。这里的order配置为BEFORE,说明它会在插入之前先执行生成主键的SQL，然后插入数据。如果有一些特殊需要，可以把它色湖之为AFTER，比如一些插入语句内部可能有嵌入索引调用，这样它就会在插入语句之后执行了。</p>
<h1 id="54----update元素和delete元素">5.4    update元素和delete元素</h1>
<p>因为update元素和delete元素比较简单，所以放在一起讨论。它们和insert的属性差不多，执行完也会返回一个整数，用以标识该SQL语句影响了数据库的记录行数。</p>
<pre><code>&lt;update id=&quot;updateRole&quot; ParameterType=“role&quot;&gt;
	update t_role set role_name=#{roleName},note=#{note}
	where id=#{id}
&lt;/update&gt;

&lt;delete id=&quot;deleteRole&quot; parameterType=&quot;long&quot;&gt;
delete from t_role where id=#{id}
&lt;/delete&gt;
</code></pre><p>我们遇到的场景大部分是类似这样的，比较简单，最后MyBatis会返回一个整数，标识对应的SQL执行后会影响了多少条数据库表里的记录。至于参数可以参考select元素的参数规则，在MyBatis中它们的规则是通用的。</p>
<h2 id="55-sql元素">5.5 sql元素</h2>
<p>sql元素的作用在于定义一条SQL的一部分，方便后面的SQL引用它，比如最典型的列名。通常要在select、insert等语句中反复编写它们，特别是那些字段比较多的表更是如此，而在MyBatis中，只需要使用sql元素编写一次便能在其他元素中引用它了。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">sql</span> id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;roleCols&#34;</span><span style="color:#f92672">&gt;</span>
id,role_name,note
<span style="color:#f92672">&lt;/</span><span style="color:#66d9ef">sql</span><span style="color:#f92672">&gt;</span>
</code></pre></div><p>通过sql元素进行定义，就可以通过include元素引入到各条SQL中了。这样的代码，在字段多的数据库表中可以重复使用，从而减少对其列名的重复编写。</p>
<pre><code>&lt;include refid=&quot;roleCols&quot;/&gt;
</code></pre><p>sql元素还支持变量传递</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>sql id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;roleCols&#34;</span><span style="color:#f92672">&gt;</span>
$<span style="color:#f92672">{</span>alias<span style="color:#f92672">}.</span><span style="color:#a6e22e">id</span><span style="color:#f92672">,</span>$<span style="color:#f92672">{</span>alias<span style="color:#f92672">}.</span><span style="color:#a6e22e">role_name</span><span style="color:#f92672">,</span>$<span style="color:#f92672">{</span>alias<span style="color:#f92672">}.</span><span style="color:#a6e22e">note</span>
<span style="color:#f92672">&lt;/</span>sql<span style="color:#f92672">&gt;</span>

<span style="color:#f92672">&lt;</span>select id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;getRole&#34;</span> parameterType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;long&#34;</span> resultType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;roleMap&#34;</span><span style="color:#f92672">&gt;</span>
select
<span style="color:#f92672">&lt;</span>include refid<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;roleCols&#34;</span><span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;</span>property name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;alias&#34;</span> value<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;r&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;/</span>include<span style="color:#f92672">&gt;</span>
from t_role r where id<span style="color:#f92672">=</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>id<span style="color:#f92672">}</span>
<span style="color:#f92672">&lt;/</span>select<span style="color:#f92672">&gt;</span>
</code></pre></div><p>在include元素中定义了一个命名为alias的变量，其值是SQL中表t_role的别名r，然后sql元素就能够使用这个变量名。</p>
<h1 id="56-参数">5.6 参数</h1>
<h2 id="561-概述">5.6.1 概述</h2>
<p>一些数据库字段返回为null,而MyBatis系统又检测不到使用何种jdbcType进行处理时，会发生异常的情况，这个时候执行对应的typeHandler进行处理，MyBatis就知道采取哪个typeHandler进行处理了。</p>
<p>MyBatis会更具javaType和jdbcType去检测使用哪个typeHandler。如果roleName是一个没有注册的类型，那么就会发生异常。因为MyBatis无法找到对应的typeHandler来转换数据类型。此时可以 自定义typeHandler,通过类似的办法指定，就不会抛出异常了。在一些因为数据库返回为null，存在可能抛出异常的情况下，也可以指定对应的jdbcType,从而让MyBatis能够探测到使用哪个typeHandler进行转换眼空指针异常，比如代码：</p>
<pre><code>#{age,javaType=int,jdbcType=NUMERIC,typeHandler=MyTypeHandler}
</code></pre><p>MyBatis也提供了游戏额对控制数值的精度支持，类似于以下代码：</p>
<p>#{width,javaType=double,jdbcType=NUMERIC,numericScale=2}</p>
<p>这样MyBatis就会控制这个精度，只保留数字的两位有效位。</p>
<h2 id="562-存储过程参数支持">5.6.2 存储过程参数支持</h2>
<p>MyBatis对存储过程也进行了支持，在存储过程中存在：输入（IN）参数、输出 （OUT）参数和输入输出（INOUT）参数3种类型。输入参数是外界需要传递给存储过程的；输出参数是存储过程经过处理后返回的；输入输出参数一方面外界需要课传递的给它，另一方面在最后存储过程中也会将它返回给调用者。</p>
<p>在MyBatis中提供对存储过程的良好支持，对于简单的输出参数（比如INT\VARCHAR\DECIMAL）可以使用POJO提供映射来完成。有时候存储过程会返回一些游标，而MyBatis也提供idbcType为CURSOR对此进行支持，不过先关注参数的定义。存储过程的参数类型有3种。</p>
<pre><code>#{id，mode=IN}
#{roleName,mode=OUT}
#{note,mode=INOUT}
</code></pre><p>其中，mode属性的3个配置选项对应3种存储过程的参数类型。</p>
<ul>
<li>IN:输入参数</li>
<li>OUT：输出参数</li>
<li>INOUT：输入输出参数</li>
</ul>
<h2 id="563--特殊字符串的替换和处理和">5.6.3  特殊字符串的替换和处理（#和$）</h2>
<p>​	在现实中，由于一些因素会造成构成SQL查询的列名发生变化，比如产品类型为大米，查询的列名是重量，而产品类型为灯具，查询的列名是数量，这时候需要构建动态列名。而对于表格也是这样的，比如为了减缓数据库表的压力，有些企业会将一张很大的数据库表按年份拆分，比如购买记录表。现实中由于记录比较多，可能为了方便等，这时往往需要构建动态表名。在MyBatis中，构建动态列名常常要传递类似于字符串的columns=“cool1,col2,col3&hellip;&ldquo;给SQL，让其组装成为SQL语句。如果不想被MyBatis像处理普通参数一样把它设为”col1,col2,col3&hellip;&quot;，那么可以写成select${columns} from t_tablename,这样MyBatis就不会转译columns，而不是作为SQL的参数进行设置了，而变为直出，这句SQL就会变为select col1,col2,col3&hellip;from t_tablename。</p>
<p>只是这样是对SQL而言是不安全的，MyBatis提供灵活性的同时，也需要自己去控制参数，以保证SQL运转的正确性和安全性。</p>
<h1 id="57-resultmap元素">5.7 resultMap元素</h1>
<p>resultMap的作用是定义映射规则、级联的更新、定制类型转化器等。resultMap定义的主要是一个结果集的映射关系，也就是SQL到JavaBean的映射关系定义，它也支持级联等特性。只是MyBatis现有的版本只支持resultMap查询，不支持更新或者保存，更不必说级联的更新、删除和修改了。</p>
<h2 id="571-resultmap元素的构成">5.7.1 resultMap元素的构成</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>resultMap<span style="color:#f92672">&gt;</span>
	<span style="color:#f92672">&lt;</span>constructor<span style="color:#f92672">&gt;</span>
	<span style="color:#f92672">&lt;</span>idArg<span style="color:#f92672">/&gt;</span>
	<span style="color:#f92672">&lt;</span>arg<span style="color:#f92672">/&gt;</span>
	<span style="color:#f92672">&lt;/</span>constructor<span style="color:#f92672">&gt;</span>
	<span style="color:#f92672">&lt;</span>id<span style="color:#f92672">/&gt;</span>
	<span style="color:#f92672">&lt;</span>result<span style="color:#f92672">/&gt;</span>
	<span style="color:#f92672">&lt;</span>association<span style="color:#f92672">/&gt;</span>
	<span style="color:#f92672">&lt;</span>collection<span style="color:#f92672">/&gt;</span>
	<span style="color:#f92672">&lt;</span>discriminator<span style="color:#f92672">/&gt;</span>
	<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">case</span><span style="color:#f92672">/&gt;</span>
	<span style="color:#f92672">&lt;/</span>discriminator<span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;/</span>resultMap<span style="color:#f92672">&gt;</span>
</code></pre></div><p>其中constructor元素用于配置构造方法。一个POJO可能不存在没有参数的构造方法，可以使用constructor进行配置。假设角色类RoleBean不存在没有参数的构造方法，它的构造方法声明为public RoleBean（Integer id ,String roleName),那么需要配置结果集。</p>
<pre><code>&lt;resultMap ......&gt;
&lt;constructor&gt;
&lt;idArg column=&quot;id&quot; javaType=&quot;int&quot;/&gt;
&lt;arg column=&quot;role_name&quot; javaType=&quot;string&quot;/&gt;
&lt;/constructor&gt;
......
&lt;/resultMap&gt;
</code></pre><p>这样MyBatis就会使用对应的构造方法来构造POJO了</p>
<p>id元素表示哪个列是主键，允许多个主键，多个主键则称为联合主键。result是配置POJO到SQL列名的映射关系。result元素和idArg元素的属性。如下表所示</p>
<table>
<thead>
<tr>
<th>元素名称</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>property</td>
<td>映射到列结果的字段和属性。如果POJO的属性匹配的是存在的且与给定SQL列名（column元素）相同的，那么MyBatis就会映射到POJO上</td>
<td>可以使用导航式的字段，比如访问一个学生对象需要访问学生证(selfcard)的发证日期(issueDate)，那么可以写成selfcard.issueDate</td>
</tr>
<tr>
<td>column</td>
<td>对应的是SQL的列</td>
<td>——</td>
</tr>
<tr>
<td>javaType</td>
<td>配置Java的类型</td>
<td>可以是特定的类完全限定名或者MyBatis上下文的别名</td>
</tr>
<tr>
<td>jdbcType</td>
<td>配置数据库类型</td>
<td>这是一个JDBC的类型，MyBatis已经做了限定，支持大部分常用的数据库类型</td>
</tr>
<tr>
<td>typeHandler</td>
<td>类型处理器</td>
<td>允许用特定的处理器来覆盖MyBatis默认的处理器。这就要指定jdbcType和javaType相互转化的规则</td>
</tr>
</tbody>
</table>
<p>此外还要association、collection和discriminator这些元素，关于级联的问题比较复杂。一条查询SQL执行后，就会返回结果，而结果可以使用map存储，也可以使用POJO存储。</p>
<h2 id="572-使用map存储结果集">5.7.2 使用map存储结果集</h2>
<p>一般而言，任何select语句都可以使用map存储。</p>
<pre><code>&lt;select id=&quot;findColorByNote&quot; parameterType=&quot;string&quot; resultType=&quot;map&quot;&gt;
	select id,color,note from t_color where note like concat('%',#{note},'%')
&lt;/select&gt;
</code></pre><p>使用map原则上是可以匹配所有结果集的，但是使用map接口就意味着可读性的下降，因为使用map时需要进一步了解map键值的构成和数据类型，所以这不是一种推荐的方式，更多时候会推荐使用POJO方式。</p>
<h2 id="573-使用pojo存储结果集">5.7.3 使用POJO存储结果集</h2>
<p>使用map方式就意味着可读性的丢失，POJO是最常用的方式。一方面可以使用自动映射，正如使用resultType属性一样，但是有时候需要更为复杂的映射或者级联，这个时候还可以使用select语句的 resultMap属性配置映射集合，只是使用前要配置类似的resultMap。</p>
<pre><code>&lt;resultMap id=&quot;roleResultMap&quot; type=&quot;com.learn.chapter4.pojo.Role&quot;&gt;
&lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;
&lt;result property=&quot;roleName&quot; column=&quot;role_name&quot;/&gt;
&lt;result peoperty=&quot;note&quot; column=&quot;note&quot;/&gt;
&lt;/resultMap&gt;
</code></pre><p>resultMap元素的属性id代表这个resultMap的标识，type代表着需要映射的POJO，这里可以使用MyBatis定义好的类的别名，也可以使用自定义的类的全限定名。</p>
<p>在映射关系中，id元素表示这个对象的主键，property代表着POJO的属性名称，column表示数据库SQL的列名，于是POJO就和数据库SQL的结果一一对应起来了。然后在映射文件中的select元素里做以下的配置，便可以使用resultMap了。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>select parameterType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;long&#34;</span> id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;getRole&#34;</span> resultMap<span style="color:#f92672">=</span><span style="color:#960050;background-color:#1e0010">&#34;</span>roleResultMap<span style="color:#f92672">&gt;</span>
select id<span style="color:#f92672">,</span>role_name<span style="color:#f92672">,</span>note from t_role where id<span style="color:#f92672">=</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>id<span style="color:#f92672">}</span>
<span style="color:#f92672">&lt;/</span>select<span style="color:#f92672">&gt;</span>
</code></pre></div><p>由此可见，SQL语句的列名和roleResultMap的column是一一对应的，使用XML配置的结果集，还可以配置typeHandler、javaType、jdbcType等更多内容，但是这条语句配置了resultMap就不能再配置resultType了。</p>
<h1 id="58-级联">5.8 级联</h1>
<p>级联是resultMap中的配置，它比较复杂，需要讨论的内容很多。</p>
<p>级联是一个数据库实体的概念。比如角色需要存在用户与之对应，这样就有角色用户表，一个角色可能有多个用户没这就是一对多的级联；除此之外，还有一对一的级联，比如身份证和公民是一对一的关系。再MYBatis中还有一种被称为鉴别器的级联，它是一种可以选择具体实现类的级联，比如要查找雇员及其体检表的信息，但是雇员有性别之分，而根据性别的不同，其体检表的项目也会不一样，比如男性体检表可能有前列腺的项目，而女性体检表可能有子宫的项目，那么体检表就应该分为男性和女性两种，从而根据性别区分关联。</p>
<p>级联不是必须的，级联的好处是获取关联数据十分便捷，但是级联过多会增加系统的复杂度，同时降低系统的性能，此增彼减，所以当级联的层级超过3层时，就不要考虑使用级联了，因为这样会造成多个对象的关联，导致系统的耦合、复杂和难以维护。再现实的使用过程中，要根据实际情况判断是否需要使用级联。</p>
<h2 id="581-mybatis中的级联">5.8.1 MyBatis中的级联</h2>
<p>MyBatis中的级联分为3种：</p>
<ul>
<li>鉴别器（discriminator）：它是一个根据某些条件决定采用具体实现类级联的方案，比如体检表要根据性别去区分。</li>
<li>一对一（association）：比如学生证和学生就是一种一对一的级联，雇员和工牌表也是一种一对一的级联。</li>
<li>一对多（collection）:比如班主任和学生就是一种一对多的级联。</li>
</ul>
<p>值得注意的是，MyBatis没有多对多的级联，因为多对多级联比较复杂，使用困难，而且可以通过两个一对多级联进行替换，所以MyBatis不支持多对多级联了。</p>
<p><img src="https://gitee.com/zerealsong/blogimage/raw/master/img/20210425204725.jpg" alt="扫描全能王 2021-04-25 20.44_4 (Copy)"></p>
<p>分析雇员级联模型：</p>
<ul>
<li>该模型是以雇员为中心的</li>
<li>雇员表和工牌表是一对一的级联关系</li>
<li>雇员表和员工任务表是一对多的级联关系</li>
<li>员工任务表和任务表是一对一的级联关系</li>
<li>每个雇员都会有一个体检表，随着雇员表字段性别取值的不同，会有不同的关联表。</li>
</ul>
<h2 id="582-建立pojo">5.8.2 建立POJO</h2>
<p>根据设计模型建立对应的POJO。首先看体检表，由于男性和女性体检表有多个字段重复，于是可以先设计一个父类，然后通过继承的方式来完成POJO</p>
<p><img src="https://gitee.com/zerealsong/blogimage/raw/master/img/20210425205255.jpg" alt="扫描全能王 2021-04-25 20.44_5 (Copy)"></p>
<p>其中MaleHealthForm和FemaleHealthForm是HealthForm的子类，由此可以得到3个关于体检表的POJO</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/************体检表父类**************/</span>
<span style="color:#f92672">package</span> com.ssm.chapter5.pojo<span style="color:#f92672">;</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HealthForm</span><span style="color:#f92672">{</span>
	<span style="color:#66d9ef">private</span> Long id<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> Long empId<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> String heart<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> String liver<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> String spleen<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> String lung<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> String kidney<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> String note<span style="color:#f92672">;</span>

	<span style="color:#75715e">/********setter and getter************/</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">/************女性体检表**************/</span>
<span style="color:#f92672">package</span> com.ssm.chapter5.pojo<span style="color:#f92672">;</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FemaleHealthForm</span> <span style="color:#66d9ef">extends</span> HealthForm<span style="color:#f92672">{</span>
	<span style="color:#66d9ef">private</span> String uterus<span style="color:#f92672">;</span>
	<span style="color:#75715e">/********setter and getter************/</span>
<span style="color:#f92672">}</span>


<span style="color:#75715e">/************男性体检表**************/</span>
<span style="color:#f92672">package</span> com.ssm.chapter5.pojo<span style="color:#f92672">;</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MaleHealthForm</span> <span style="color:#66d9ef">extends</span> HealthForm<span style="color:#f92672">{</span>
	<span style="color:#66d9ef">private</span> String prostate<span style="color:#f92672">;</span>
	<span style="color:#75715e">/********setter and getter************/</span>
<span style="color:#f92672">}</span>

</code></pre></div><p>显然这个关联关系是通过MyBatis的鉴别器（discriminator）去完成的。</p>
<p>接下来设计员工表、工牌表和任务表的POJO，它们是以员工表作为核心的，先完成工牌表和任务表的POJO</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/************工牌**************/</span>
<span style="color:#f92672">package</span> com.ssm.chapter5.pojo<span style="color:#f92672">;</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WorkCard</span><span style="color:#f92672">{</span>
	<span style="color:#66d9ef">private</span> Long id<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> Long empId<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> String realName<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> String department<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> String mobile<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> String position<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> String note<span style="color:#f92672">;</span>
	<span style="color:#75715e">/********setter and getter************/</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">/************任务**************/</span>
<span style="color:#f92672">package</span> com.ssm.chapter5.pojo<span style="color:#f92672">;</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Task</span><span style="color:#f92672">{</span>
	<span style="color:#66d9ef">private</span> Long id<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> String title<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> String context<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> String note<span style="color:#f92672">;</span>
	<span style="color:#75715e">/********setter and getter************/</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>还剩雇员表和雇员仍无表，它们有一定的关联，先从雇员任务表入手，雇员任务表是通过任务编号和任务进行一对一关联的，这里只考虑其自身和任务编号的关联，而雇员对它的关联则由雇员去维护，这样就可以得到雇员任务POJO</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/************雇员仍无POJO**************/</span>
<span style="color:#f92672">package</span> com.ssm.chapter5.pojo<span style="color:#f92672">;</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">EmployeeTask</span><span style="color:#f92672">{</span>
	<span style="color:#66d9ef">private</span> Long id<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> Long empId<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> Task task<span style="color:#f92672">=</span><span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> String taskName<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> String note<span style="color:#f92672">;</span>

	<span style="color:#75715e">/********setter and getter************/</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>属性task是一个Task类对象，由它进行关联任务信息。设置雇员表是关键。雇员根据性别分为男雇员和女雇员，它们会有不同的体检表记录 ，但是无论男、女都是雇员，所以先建立一个雇员类（Employee）。它由男雇员（MaleEmployee）和女雇员（FemaleEmployee）两个子类。在MyBatis中，这就是一个鉴别器，通过雇员类的字段性别（sex）来决定使用哪个具体的子类(MaleEmployee或者FemaleEmployee)初始化对象（Employee）。它与工牌表是一对一的关联关系，对于雇员仍无表是一对多的关系，这样就可以得到3个类。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/************雇员父类**************/</span>
<span style="color:#f92672">package</span> com.ssm.chapter5.pojo<span style="color:#f92672">;</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Employee</span><span style="color:#f92672">{</span>
	<span style="color:#66d9ef">private</span> Long id<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> String realName<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> SexEnum sex<span style="color:#f92672">=</span><span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> Date birthday<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> String mobile<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> String email<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> String position<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> String note<span style="color:#f92672">;</span>

	<span style="color:#75715e">/********setter and getter************/</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">/************男雇员类**************/</span>
<span style="color:#f92672">package</span> com.ssm.chapter5.pojo<span style="color:#f92672">;</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MaleEmpoyee</span> <span style="color:#66d9ef">extends</span> Employee<span style="color:#f92672">{</span>
	<span style="color:#66d9ef">private</span> MaleHealthForm maleHealthForm<span style="color:#f92672">=</span><span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
	<span style="color:#75715e">/********setter and getter************/</span>
<span style="color:#f92672">}</span>


<span style="color:#75715e">/************女雇员类**************/</span>
<span style="color:#f92672">package</span> com.ssm.chapter5.pojo<span style="color:#f92672">;</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FemaleEmpoyee</span> <span style="color:#66d9ef">extends</span> Employee
	<span style="color:#66d9ef">private</span> FemaleHealthForm femaleHealthForm<span style="color:#f92672">=</span><span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
	<span style="color:#75715e">/********setter and getter************/</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>MaleEmployee和FemaleEmployee都继承了Employee类，有着不同的体检表，Employee类是通过employeeTaskList属性和多个雇员任务进行一对多关联的，而工牌表是通过WorkCard进行一对一关联的，这样就完成了所有POJO的设计。</p>
<h2 id="583-配置映射文件">5.8.3 配置映射文件</h2>
<p>配置映射文件是级联的核心内容。这里对于Mapper的接口就不指出了，因为更具映射文件编写接口十分简单。从最简单的内容入手，最简单的内容无非是那些关联最少的POJO。4个 POJO中Task和WorkCard是相对独立的，所以它们的映射文件相对简单，它们和普通的Mapper并没有什么不同。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;**********</span>TaskMapper<span style="color:#f92672">.</span><span style="color:#a6e22e">xml</span><span style="color:#f92672">*******&gt;</span>
<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">？</span>xml version<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;1.0&#34;</span> encoding<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;UTF-8&#34;</span> <span style="color:#f92672">?&gt;</span>
<span style="color:#f92672">&lt;!</span>DOCTYPE mapper PUBLIC <span style="color:#e6db74">&#34;-//mybatis.org//DTD Mapper 3.0//EN&#34;</span>
<span style="color:#e6db74">&#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd&#34;</span><span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;</span>mapper namespace<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.ssm.chapter5.mapper.TaskMapper&#34;</span><span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;</span>select id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;getTask&#34;</span> parameterType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;long&#34;</span> resultTYpe<span style="color:#f92672">=</span><span style="color:#960050;background-color:#1e0010">”</span>com<span style="color:#f92672">.</span><span style="color:#a6e22e">ssm</span><span style="color:#f92672">.</span><span style="color:#a6e22e">chapter5</span><span style="color:#f92672">.</span><span style="color:#a6e22e">pojo</span><span style="color:#f92672">.</span><span style="color:#a6e22e">Task</span><span style="color:#f92672">&gt;</span>
select id<span style="color:#f92672">,</span>title<span style="color:#f92672">,</span>context<span style="color:#f92672">,</span>niote from t_task where id<span style="color:#f92672">=</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>id<span style="color:#f92672">}</span>
<span style="color:#f92672">&lt;/</span>select<span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;/</span>mapper<span style="color:#f92672">&gt;</span>

<span style="color:#f92672">&lt;**********</span>WorkCardMapper<span style="color:#f92672">.</span><span style="color:#a6e22e">xml</span><span style="color:#f92672">*******&gt;</span>
<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">？</span>xml version<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;1.0&#34;</span> encoding<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;UTF-8&#34;</span> <span style="color:#f92672">?&gt;</span>
<span style="color:#f92672">&lt;!</span>DOCTYPE mapper PUBLIC <span style="color:#e6db74">&#34;-//mybatis.org//DTD Mapper 3.0//EN&#34;</span>
<span style="color:#e6db74">&#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd&#34;</span><span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;</span>mapper namespace<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.ssm.chapter5.mapper.TaskMapper&#34;</span><span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;</span>select id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;getWorkCardByEmpId&#34;</span> parameterType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;long&#34;</span> resultTYpe<span style="color:#f92672">=</span><span style="color:#960050;background-color:#1e0010">”</span>com<span style="color:#f92672">.</span><span style="color:#a6e22e">ssm</span><span style="color:#f92672">.</span><span style="color:#a6e22e">chapter5</span><span style="color:#f92672">.</span><span style="color:#a6e22e">pojo</span><span style="color:#f92672">.</span><span style="color:#a6e22e">WorkCard</span><span style="color:#f92672">&gt;</span>
select id<span style="color:#f92672">,</span>emp_id as empId<span style="color:#f92672">,</span>real_name as realName<span style="color:#f92672">,</span>department<span style="color:#f92672">,</span>mobile<span style="color:#f92672">,</span>position<span style="color:#f92672">,</span>note FROM t_work_card
where emp_id<span style="color:#f92672">=</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>empId<span style="color:#f92672">}</span>
<span style="color:#f92672">&lt;/</span>select<span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;/</span>mapper<span style="color:#f92672">&gt;</span>
</code></pre></div><p>这样就完成了两张表的映射文件。雇员表通过任务编号（task_id）和任务表示关联，这是一个一对一的级联关系，使用association元素，雇员任务表一对一级联如下方代码</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">？</span>xml version<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;1.0&#34;</span> encoding<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;UTF-8&#34;</span> <span style="color:#f92672">?&gt;</span>
<span style="color:#f92672">&lt;!</span>DOCTYPE mapper PUBLIC <span style="color:#e6db74">&#34;-//mybatis.org//DTD Mapper 3.0//EN&#34;</span>
<span style="color:#e6db74">&#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd&#34;</span><span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;</span>mapper namespace<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.ssm.chapter5.mapper.EmployeeTaskMapper&#34;</span><span style="color:#f92672">&gt;</span>

<span style="color:#f92672">&lt;</span>resultMap type<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.ssm.chapter5.mapper.TaskMapper&#34;</span> id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;EmployeeTaskMapper&#34;</span><span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;</span>id column<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;id&#34;</span> property<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;id&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;</span>result column<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;emp_id&#34;</span> property<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;empId&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;</span>result column<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;task_name&#34;</span> property<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;taskName&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;</span>result column<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;note&#34;</span> property<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;note&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;</span>association property<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;task&#34;</span> column<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;task_id&#34;</span>
select<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.ssm.chapter5.mapper.TaskMapper.getTask&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;/</span>resultMap<span style="color:#f92672">&gt;</span>



<span style="color:#f92672">&lt;</span>select id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;getTaskByEmpId&#34;</span> resultMap<span style="color:#f92672">=</span><span style="color:#960050;background-color:#1e0010">”</span>com<span style="color:#f92672">.</span><span style="color:#a6e22e">ssm</span><span style="color:#f92672">.</span><span style="color:#a6e22e">chapter5</span><span style="color:#f92672">.</span><span style="color:#a6e22e">pojo</span><span style="color:#f92672">.</span><span style="color:#a6e22e">EmployeeTaskMapper</span><span style="color:#f92672">&gt;</span>
select id<span style="color:#f92672">,</span>emp_id <span style="color:#f92672">,</span>task_name<span style="color:#f92672">,</span>task_id<span style="color:#f92672">,</span>note from  t_employee_task
where emp_id<span style="color:#f92672">=</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>empId<span style="color:#f92672">}</span>
<span style="color:#f92672">&lt;/</span>select<span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;/</span>mapper<span style="color:#f92672">&gt;</span>
</code></pre></div><p>注意加粗的代码，association元素代表一对一级联的开始。property属性代表映射到POJO属性上。select配置是命名可见+SQLid的形式，这样便可以指向对于Mapper的SQL，MyBatis就会通过对应的SQL将数据查询回来。column代表SQL的列，用作参数传递给select属性指定的SQL，如果是多个参数，则需要用逗号隔开。</p>
<p>再研究体检表，它能拆分成男性雇员和女性雇员，所以就有两个简单的映射器</p>
<p><img src="https://gitee.com/zerealsong/blogimage/raw/master/img/20210425234620.jpg" alt="2021-04-2545 (Copy)"></p>
<p>这连个映射器都主要是通过雇员编号找到对应体检表的记录，为雇员查询时提供的体检表SQL。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">？</span>xml version<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;1.0&#34;</span> encoding<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;UTF-8&#34;</span> <span style="color:#f92672">?&gt;</span>
<span style="color:#f92672">&lt;!</span>DOCTYPE mapper PUBLIC <span style="color:#e6db74">&#34;-//mybatis.org//DTD Mapper 3.0//EN&#34;</span>
<span style="color:#e6db74">&#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd&#34;</span><span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;</span>mapper namespace<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.ssm.chapter5.mapper.EmployeeMapper&#34;</span><span style="color:#f92672">&gt;</span>

<span style="color:#f92672">&lt;</span>resultMap type<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.ssm.chapter5.mapper.Emplyee&#34;</span> id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;employee&#34;</span><span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;</span>id column<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;id&#34;</span> property<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;id&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;</span>result column<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;real_name&#34;</span> property<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;realName&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;</span>result column<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;sex&#34;</span> property<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;sex&#34;</span> typeHandler<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.ssm.chapter5.typeHandler.SexTypeHandler&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;</span>result column<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;birthday&#34;</span> property<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;birthday&#34;</span><span style="color:#f92672">/&gt;</span>
    <span style="color:#f92672">&lt;</span>result column<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;mobile&#34;</span> property<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;mobile&#34;</span><span style="color:#f92672">/&gt;</span>
    <span style="color:#f92672">&lt;</span>result column<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;email&#34;</span> property<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;email&#34;</span><span style="color:#f92672">/&gt;</span>
    <span style="color:#f92672">&lt;</span>result column<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;position&#34;</span> property<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;position&#34;</span><span style="color:#f92672">/&gt;</span>
    <span style="color:#f92672">&lt;</span>result column<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;note&#34;</span> property<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;note&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;</span>association property<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;workCard&#34;</span> column<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;id&#34;</span> select<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.ssm.chapter5.mapper.WorkCardMapper.getWorkCardByEmpId&#34;</span><span style="color:#f92672">/&gt;</span>
    <span style="color:#f92672">&lt;</span>collection property<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;employeeTaskList&#34;</span> column<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;id&#34;</span> select<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.ssm.chapter5.mapper.EmployeeTaskMapper.getEmplyeeTaskByEmpId&#34;</span><span style="color:#f92672">/&gt;</span>
    
    <span style="color:#f92672">&lt;</span>discriminator javaType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;long&#34;</span> column<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;sex&#34;</span><span style="color:#f92672">&gt;</span>
    <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">case</span> value<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;1&#34;</span>resultMap<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;maleHealthFormMapper&#34;</span><span style="color:#f92672">/&gt;</span>
        <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">case</span> value<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;2&#34;</span>resultMap<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;femaleHealthFormMapper&#34;</span><span style="color:#f92672">/&gt;</span>
    <span style="color:#f92672">&lt;/</span>discriminator<span style="color:#f92672">&gt;</span>
    <span style="color:#f92672">&lt;/</span>resultMap<span style="color:#f92672">&gt;</span>
    
    <span style="color:#f92672">&lt;</span>resultMap type<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.ssm.chapter5.mapper.FemaleEmplyee&#34;</span> id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;femaleHealthFormMapper&#34;</span> <span style="color:#66d9ef">extends</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;employee&#34;</span><span style="color:#f92672">&gt;</span>
    <span style="color:#f92672">&lt;</span>association property<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;femaleHealthForm&#34;</span> column<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;id&#34;</span> select<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.smm.chapter5.mapper.FemaleHealthFormMapper.getFemaleHealthForm&#34;</span><span style="color:#f92672">&gt;</span>
    <span style="color:#f92672">&lt;/</span>resultMap<span style="color:#f92672">&gt;</span>
    
       <span style="color:#f92672">&lt;</span>resultMap type<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.ssm.chapter5.mapper.MaleEmplyee&#34;</span> id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;maleHealthFormMapper&#34;</span> <span style="color:#66d9ef">extends</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;employee&#34;</span><span style="color:#f92672">&gt;</span>
    <span style="color:#f92672">&lt;</span>association property<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;maleHealthForm&#34;</span> column<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;id&#34;</span> select<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.smm.chapter5.mapper.FemaleHealthFormMapper.getMaleHealthForm&#34;</span><span style="color:#f92672">&gt;</span>
    <span style="color:#f92672">&lt;/</span>resultMap<span style="color:#f92672">&gt;</span>
    
    <span style="color:#f92672">&lt;</span>select id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;getEmployee&#34;</span> parameterType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;long&#34;</span> resultMap<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;employee&#34;</span><span style="color:#f92672">&gt;</span>
select id<span style="color:#f92672">,</span>real_name as realName <span style="color:#f92672">,</span>sex<span style="color:#f92672">,</span>birthday<span style="color:#f92672">,</span>mobile<span style="color:#f92672">,</span>email<span style="color:#f92672">,</span>position<span style="color:#f92672">,</span>note from  t_employee
where id<span style="color:#f92672">=</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>id<span style="color:#f92672">}</span>
<span style="color:#f92672">&lt;/</span>select<span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;/</span>mapper<span style="color:#f92672">&gt;</span>
    
</code></pre></div><p>association元素，对工牌进行一对一级联，这个再雇员任务表中已经分析过。</p>
<p>collection元素，一对多级联，其select元素指向SQL，将通过column制定的SQL字段作为参数进行传递，然后将结果返回给雇员POJO的属性employeeTaskList。</p>
<p>discriminator元素，鉴别器，它的属性column代表使用哪个字段进行鉴别，这里的是sex，而它的子元素case，则进行区分，类似于Java的switch&hellip;case语句。而resultMap属性表示采用哪个ResultMap去映射，比如sex=1，则使用maleHealthFormMapper进行映射。</p>
<p>而对于雇员体检表而言,id为employee的resultMap，被maleHealthFormMapper和femaleHealthFormMapper通过association元素去执行对应关联的字段和SQL。这样所有的POJO都有了关联，可以测试级联。</p>
<h2 id="584-n1问题">5.8.4 N+1问题</h2>
<p>雇员的管理者，它指向看到员工信息和员工任务信息，那么体检表和工牌的信息就是多余的。如果像上面那样取出所有属性，就会使数据库多执行几条毫无意义的SQL。如果需要再雇员信息系统里面加入一个关联信息，那么它再默认的情况下会指向SQL取出数据，而真实的需求往往只要完成雇员和雇员任务表 的级联就可以了，不需要把所有信息都加载进来，因为有些信息并不常用，加载它们会执行几条毫无用处的SQL，导致数据库资源的损耗和系统性能的下降。</p>
<p>假设限制有N个关联关系完成了级联，那么只要再加入一个关联关系，就编程了N+1个级联，所有的级联SQL都会被执行，显然会有很多并不是我们关心的数据被取出，这样会造成很大的资源浪费，这就是N+1问题，尤其是再那些需要高性能的互联网系统中，这往往是不被允许的。</p>
<p>为了应对N+!问题，MyBatis提供了延迟加载功能，即再一开始取雇员信息时，并不需要将工牌表、体检表、任务表的记录取出，而是将雇员信息和雇员任务表的信息取出。当我们提供雇员POJO访问工牌表时，体检表和任务表的记录才通过对应的SQL取出。</p>
<h2 id="585-延迟加载">5.8.5 延迟加载</h2>
<p>MyBatis支持延迟加载，我们希望一次性把常用的级联数据通过SQL直接查询出来，而对于那些不常用的级联数据不要取出，而是i等待要用时才取出，这些不常用的级联数据可以采用了延迟加载的功能。</p>
<p>在MyBatis的setting配置中4存在两个元素可以配置级联</p>
<table>
<thead>
<tr>
<th>配置项</th>
<th>作用</th>
<th>配置选项说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>lazyLoadingEnabled</td>
<td>延迟加载的全局开关。当开启时，所有关联对象大都会延迟加载。在特定关联关系中，可通过设置fetchType属性来覆盖该项的开关状态</td>
<td>true|false</td>
<td>false</td>
</tr>
<tr>
<td>aggresivelazyLoading</td>
<td>当启用时，对任意延迟属性的调用会使带有延迟加载属性的对象完整加载；反之，则每种属性按需加载</td>
<td>true|false</td>
<td>3.4.1之前为true， 之后为false</td>
</tr>
</tbody>
</table>
<p>lazyLoadingEnabled是一个开关，决定开不开启延迟加载，默认值为false，则不开启延迟加载。所以正如上面的例子，我们什么都没有配置时它就会把全部信息加载进来，所以当获取员工信息时，所以的信息都被加载进来。</p>
<p>lazyLoadingEnabled是相对好理解的，而aggresiveLazyLoading是不好理解的。注意，agressiveLazyLoading的默认值，从3.4.2的版本后默认值变为false，之前一直为true</p>
<p>aggressiveLazyLoading配置项是一个层级开关，当设置为true时，它是一个开启了层级开关的延迟加载，所以在实践中看到了层级的加载。当设为false时，而层级加载已经失效。</p>
<p>选项lazyLoadingEnabled决定是否开启延迟加载，而选项aggressiveLazyLoading则控制是否采用层级加载，但是它们都是全局性的配置，并不能解决我们的需求。加载雇员信息时，只加载雇员任务信息，因为层级加载会把工牌信息也加载进来。为了处理这个问题，在MyBatis中使用fetchType属性，它可以处理全局定义无法处理的问题，进行自定义，fetchType出现在级联元素（association\collection,注意discriminator没有这个属性可配置）中，它存在两个值：</p>
<p>eager,获得当前POJO后立即加载对应的数据</p>
<p>lazy，获取当前POJO后延迟加载对应的数据。</p>
<p>在保证lazyLoadingEnabled=true和aggresiveLazyLoading=false的前提下，对雇员的Mapper配置文件中关于雇员属性、雇员任务进行如下修改</p>
<p><img src="https://gitee.com/zerealsong/blogimage/raw/master/img/20210426122731.jpg" alt="2021-04-2626 (Copy)"></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>collection property<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;employeeTaskList&#34;</span> column<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;id&#34;</span> fetchType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;eager&#34;</span>
select<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.ssm.chapter5.mapper.EmployeeTaskMapper.getEmployeeTaskByEmpId&#34;</span><span style="color:#f92672">&gt;</span>
</code></pre></div><p>这个时候已经按照我们的要求加载了数据，先加载雇员信息，然后加载雇员任务信息，fetchType属性会忽略全局配置项lazyLoadingEnabled和aggresiveLazyLoading。</p>
<h2 id="586-另一个级联">5.8.6 另一个级联</h2>
<p>MyBatis还提供了另一个级联方式，它是基于SQL表连接的基础上，进行再次设计的，先定义一条SQL查询。这里的SQL我们通过left join语句，将一个雇员模型所有的信息关联出来，这样便可以通过一条SQL将所有信息都查询出来。对于列名，作了别名的处理，而在MyBatis中允许这样的SQL进行配置，来完成级联。 以下为级联的关键代码</p>
<pre><code>&lt;association property=&quot;workCard&quot; javaType=&quot;com.ssm.chapter5.pojo.WorkCard&quot; column=&quot;id&quot;&gt;
&lt;collection property=&quot;employeeTaskList&quot; ofType=&quot;com.ssm.chapter5.pojo.EmployeeTask&quot; column=&quot;id&quot;&gt;
&lt;association property=&quot;task&quot; javaType=&quot;com.ssm.chapter5.pojo.Task&quot; column=&quot;et_task_id&quot;&gt;
&lt;discrminator javaType=&quot;int&quot; column=&quot;sex&quot;&gt;
&lt;case value=&quot;1&quot; resultMap=&quot;maleHealthFormMapper2&quot;/
&lt;case value=&quot;2&quot; resultMap=&quot;femaleHealthFormMapper2&quot;/&gt;
&lt;/discriminator&gt;
&lt;association property=&quot;maleHealthForm&quot; column=&quot;id&quot; javaType=&quot;com.ssm.chapter5.pojo.MaleHealthForm&quot;&gt;
&lt;assocaiation property=&quot;femaleHealthForm&quot; column=&quot;id&quot; javaType=&quot;com.ssm.chapter5.pojo.FemaleHealthForm&quot;&gt;
</code></pre><ul>
<li>
<p>每一个级联元素中的属性id的配置和POJO实体配置的id一一对应，形成级联，比如上述的SQL的列et_task_id和Task实体的id是对应的，这是级联的关键所在。</p>
</li>
<li>
<p>在级联元素中，association是通过javaType的定义去声明实体映射的，而collection则是使用ofType进行声明的。</p>
</li>
<li>
<p>discriminator元素定义使用何种具体的resultMap进行级联，这里通过sex列进行判定。</p>
<p>这样完全可以消除 N+1问题，但是也会引发其他问题：首先，SQL会比较复杂；其次，所需要的配置比之前复杂得多 ；再次一次性将所有的数据取出会造成内存的浪费。这样的复杂SQL，同时也会给日后的维护工作带来一定的困难。这样的级联，一般用于那些比较简单且关联不多的场景下</p>
</li>
</ul>
<h2 id="587-多对多级联">5.8.7 多对多级联</h2>
<p>在现实中，有一种多对多的级联，而在程序中多对多的寄来你往往会被拆分为两个一对多级联来处理。现实中有许多用户，用户又归属于一些角色，这样一个用户可以对应多个角色又可以由多个用户担当，这个时候用户和角色是以一张用户角色表建立关联关系，这样用户和角色就是多对多的关系。</p>
<p>而现实中多对多的级联是相当复杂的，更多的都是拆分为两个一对多的关系，也就是一个角色对应多个用户和一个用户对应多个角色。</p>
<p>List类型的属性是专门做一对多的级联用的，使用collection元素去完成，得到两个mapper.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>collection property<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;userList&#34;</span> column<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;id&#34;</span>

fetchType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;lazy&#34;</span> select<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.ssm.chapter5.mapper2.UserMapper2.findUserByRoleId&#34;</span><span style="color:#f92672">/&gt;</span>
</code></pre></div><p>这里使用collection去关联，但是把fetchType都设置为了Lazy，这样就能够进行延迟加载。</p>
<p>一共有3条SQL被执行，因为调用了getUserList来获取用户信息，所以才有第二条SQL。在映射器中设置fetchTYpe为lazy，这样就不会立即加载数据进来，避免一些用不到的SQL被执行，只有调用了对应的方法它才会加载数据进来。</p>
<h1 id="59-缓存">5.9 缓存</h1>
<p>在MyBatis中允许使用缓存，缓存一般都放置在可高速读/写的存储器上，比如服务器的内存，它能够有效提高系统的性能。因为数据库在大部分场景下是把存储在磁盘上的数据索引出来。从硬件的角度分析，索引磁盘一个较为缓慢的过程，读取内存或者高速缓存处理器的速度要比读取磁盘快很多，其速度是读取硬盘的几十倍到上百倍，但是内存和高速缓存处理器的空间有限，所以一般只会把那些常用且命中率高的数据缓存起来，以便将来使用，而不缓存那些不常用且命中率低的数据缓存。因为命中率低，最后还是要磁盘内查找，并不能有效提高性能。</p>
<p>MyBatis分为一级缓存和二级缓存，同时也可以配置关于缓存的设置。</p>
<h2 id="591-一级缓存和二级缓存">5.9.1 一级缓存和二级缓存</h2>
<p>一级缓存是在SqlSession上的缓存，二级缓存是在SqlSessionFactory上的缓存，默认情况下，也就是没有任何配置的情况下，MyBatis系统会开启一级缓存，也就是对SqlSession层面的缓存，这个缓存不需要POJO对象可序列化（实现java.io.Serializable接口）。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Role role <span style="color:#f92672">=</span>roleMapper<span style="color:#f92672">.</span><span style="color:#a6e22e">getRole</span><span style="color:#f92672">(</span>1L<span style="color:#f92672">);</span>
Role role2 <span style="color:#f92672">=</span>roleMapper<span style="color:#f92672">.</span><span style="color:#a6e22e">getRole</span><span style="color:#f92672">(</span>1L<span style="color:#f92672">);</span>
</code></pre></div><p>虽然代码对同一对象进行了两次获取，但是实际只有一条SQL被执行，其原因是代码使用了同一个SqlSession对象获取数据。当一个SqlSession第一次通过SQL和参数获取对象后，它就会将其缓存起来 ，如果下次的SQL和参数都没有发生变化，并且缓存没有超时或者声明需要刷新时，那么它就会从缓存中获取数据，而不是通过SQL获取了。</p>
<p>注意commit（）方法的使用，必须提交，MyBatis才缓存对象到SqlsessionFactory,这样才有一级缓存存在。</p>
<p>如果SQL被执行了两次，这说明一级缓存是在SqlSession层面的，对于不同的SqlSession对象是不能共享的。为了使Sqlsession对象之间&lt;共享相同的缓存，有时候需要开启二级缓存，开启二级缓存简单，只要在映射文件上加入代码：</p>
<pre><code>&lt;cache/&gt;
</code></pre><p>这个时候MyBatis会序列化和反序列化对应的POJO，也就要求POJO是一个可序列化的对象，那么它就必须实现java.io.Serializable接口。对角色类对象进行缓存，那么就需要它实现Serializable接口。</p>
<p>如果Role类没有实现java.io.Serializable接口，那么MyBatis将会抛出异常，导致程序运行错误。在映射文件中配置了<!-- raw HTML omitted -->后，从日志中可以看到，不同的SqlSession在获取同一条记录，都只是发送过一次SQL获取数据。因为这个时候MyBatis将其保存在SqlSessionFactory层面，可以提供给各个SqlSession使用，只是它需要一个序列化和反序列化的过程而已，因此它需要实现Serializable接口。</p>
<h2 id="592-缓存配置项自定义和引用">5.9.2 缓存配置项、自定义和引用</h2>
<p>加入cache元素后，Mybatis就会将对应的命名空间内所有select元素SQL查询结果进行缓存，而其中的insert、delete和update语句在操作时会刷新缓存。</p>
<p>缓存要明确cache元素的配置项。可以使用自定义的缓存，只是实现类需要实现MyBatis的接口org.apache.ibatis.cache.Cache。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>取值</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>blocking</td>
<td>是否使用阻塞性缓存，在读写时它会加入JNI的锁进行操作</td>
<td>true|false，默认值false</td>
<td>可保证读写安全性，但加锁后性能不佳</td>
</tr>
<tr>
<td>readOnly</td>
<td>缓存内容是否只读</td>
<td>true|false，默认值false</td>
<td>如果为只读，则不会因为多个线程读写造成不一致性</td>
</tr>
<tr>
<td>eviction</td>
<td>缓存策略，分为：LRU最近最少使用的，移除最长时间不被使用的对象。FIFO先进先出：按对象进入缓存的顺序来移除它们 。 SOFT软引用：移除基于垃圾回收器状态和软引用规则的对象。WEAK弱引用：更积极移除基于垃圾收集器和弱引用规则的对象。</td>
<td>默认值是LRU</td>
<td>——</td>
</tr>
<tr>
<td>flushInterval</td>
<td>这是一个整数，它以毫秒为单位，比如1分钟刷新一次，则配置60000，默认值为60000.默认为null,也就是没有刷新时间，只有当执行update时，insert和delete语句才会刷新。</td>
<td>正整数</td>
<td>超过整数后缓存失效，不再读取缓存，而是执行SQL取回数据</td>
</tr>
<tr>
<td>type</td>
<td>自定义缓存类，要求实现接口org.apache.ibatis.cache.Cache</td>
<td>用于自定义缓存类</td>
<td>——</td>
</tr>
<tr>
<td>size</td>
<td>缓存对象个数</td>
<td>正整数，默认值1024</td>
<td>——</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">package</span> org.apache.ibatis.cache
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Cache</span><span style="color:#f92672">{</span>
<span style="color:#75715e">//获取缓存ID
</span><span style="color:#75715e"></span>String <span style="color:#a6e22e">getId</span><span style="color:#f92672">();</span>
<span style="color:#75715e">//保存对象，key为键，value为值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">putObject</span><span style="color:#f92672">(</span>Object key<span style="color:#f92672">,</span>Object value<span style="color:#f92672">);</span>
<span style="color:#75715e">//获取缓存数据，key为键
</span><span style="color:#75715e"></span>Object <span style="color:#a6e22e">getObject</span><span style="color:#f92672">(</span>Object key<span style="color:#f92672">);</span>
<span style="color:#75715e">//删除缓存，key为键
</span><span style="color:#75715e"></span>Object <span style="color:#a6e22e">removeObject</span><span style="color:#f92672">(</span>Object key<span style="color:#f92672">)</span>
<span style="color:#75715e">//清除缓存
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">clear</span><span style="color:#f92672">();</span>
<span style="color:#75715e">//获得缓存大小
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getSize</span><span style="color:#f92672">();</span>
<span style="color:#75715e">//获取读写锁，需要考虑多线程的场景
</span><span style="color:#75715e"></span>ReadWriteLock <span style="color:#a6e22e">getReadWriteLock</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>在现实中，我们可以使用Redis,MongoDB或者其他常用的缓存，假设存在一个Redis的缓存实现类com.ssm.chapter5.cache.RedisCache，那么可以这样配置它：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>cache type<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.ssm.chapter5.cache.RedisCache&#34;</span><span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;</span>property name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;host&#34;</span> value<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;localhost&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;/</span>cache<span style="color:#f92672">&gt;</span>
</code></pre></div><p>这样配置后，MyBatis会启用缓存，同时调用setHost 方法，去设置配置的内容。</p>
<p>上面的配置是通用的，对于一些语句也需要自定义。比如对于一些查询并不需要它进行任何缓存，这个时候可以通过配置改变它们：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>select <span style="color:#f92672">...</span> flushCache<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;false&#34;</span> useCache<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;true&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;</span>insert<span style="color:#f92672">...</span><span style="color:#a6e22e">flushCache</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;true&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;</span>update<span style="color:#f92672">...</span><span style="color:#a6e22e">flushCache</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;true&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;</span>delete<span style="color:#f92672">...</span><span style="color:#a6e22e">flushCache</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;true&#34;</span><span style="color:#f92672">/&gt;</span>
</code></pre></div><p>以上是默认的配置，我们可以更具需要去修改它们。flushCache代表是否刷新缓存，flushCache属性对于select、insert、update和delete都是有效的，而useCache属性则是select特有的，代表是否需要使用缓存。</p>
<p>这里都是在一个映射器内配置，比如RoleMapper.xml，那么其他的映射器是不能使用的，如果其他的映射器需要使用同样的配置，则可以引用缓存的配置：</p>
<pre><code>&lt;cache-ref namespace=&quot;com.ssm.chapter5.mapper.RoleMapper&quot;/&gt;
</code></pre><p>通过这样就可以引入对应映射器的cache元素的配置了。</p>
<h1 id="510-存储过程">5.10 存储过程</h1>
<p>Mybatis还能对存储过程进行完全支持。</p>
<p>首先存储过程是数据库的一个概念，它是数据库预先编译好，放在数据库内存中的一个程序片段，所以具备性能高，可重复使用的特性。它定义了3种类型的参数：输入参数、输出参数、输入输出参数。</p>
<ul>
<li>输入参数，是外界给的存储过程参数，在Java互联网中，也就是互联网系统给它的参数。</li>
<li>输出参数，是存储过程经过计算返回给程序的参数结果参数。</li>
<li>输入输出参数，是一开始作为参数传递给存储过程，而存储过程修改后将其返回的参数，比如那些商品的库存就是这样的。</li>
</ul>
<p>对于返回结果而言，一些常用的简易类型，比如整形、字符串OUT或者INOUT参数是Java程序比较好处理的，而存储过程还可能返回游标类型的参数，这需要我们处理，不过在MyBatis中，这些都可以轻松完成。</p>
<h2 id="5102-游标的使用">5.10.2 游标的使用</h2>
<p>在实际应用中，除了使用建议的输入输出参数，有时候也可能使用游标，MyBatis也对存储过程的游标提供了支持。如果把jdbcType声明为CURSOR，那么它就会使用ResultSet对象处理对应的结果，只要设置映射关系，MyBatis也对存储过程的游标提供了支持。如果把jdbcType声明为CURSOR，那么它就会使用ResultSet对象处理对应的结果，只要设置映射关系，MyBatis就会把结果集映射出来。</p>
<p>参数是和存储过程一一对应的，而游标是由roleList去存储的，只是这里需要为其提供映射关系，游标映射器。</p>
<pre><code>#{roleList ,mode=OUT,jdbcType=CURSOR,javaType=ResultSet,resultMap=roleMap}
</code></pre><p>先定义了resultMap元素，它定义了映射规则。而在存储过程的调用中，对于roleList,定义了jdbcType为CURSOR，这样就会把结果使用ResultSet对应能够映射为POJO，设置了resultMap，这样MyBatis就会采用配置的映射规则将其映射为POJO了。</p>

    </div>
    <div class="post-footer">
      
    </div>
    <div class="post-comment">
      
      


<span id="/post/ssm%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%98%A0%E5%B0%84%E5%99%A8/" class="leancloud_visitors" data-flag-title="SSM第五章-映射器">
    <span class="post-meta-item-text">文章阅读量 </span>
    <span class="leancloud-visitors-count">1000000</span>
    <p></p>
  </span>
<div id="vcomments"></div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script type="text/javascript">
  new Valine({
    el: '#vcomments' ,
    appId: 'cScQmclMsD4OOWCclCP1pNsz-gzGzoHsz',
    appKey: 'dtSaHLmdH3J4ICVVInYg9YFM',
    notify:  false ,
  verify:  false ,
  avatar:'mm',
    placeholder: '说点什么吧...',
    visitor:  true 
  });
</script>

    </div>
  </article>

    </main>
  </body>
</html>
