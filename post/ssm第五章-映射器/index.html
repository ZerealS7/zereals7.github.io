<!doctype html>
<html lang="en-us">
  <head>
    <title>SSM第五章-映射器 // Zereal-宋致远技术博客</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.72.0" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75，minimum-scale=0.75, maximum-scale=0.75, user-scalable=no" />
    <meta name="author" content="Zereal" />
    <meta name="description" content="" />
    <meta name="referrer" content="never"/>
    <link rel="stylesheet" href="https://zereals7.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="SSM第五章-映射器"/>
<meta name="twitter:description" content="映射器是MyBatis最复杂且最重要的组件。它由一个接口加上XML文件（或者注解）组成。在映射器中可以配置参数、各类的SQL语句、存储过程、缓存、级联等复杂的内容，并且通过简易的映射规则映射到指定的POJO或者其他对象上，映射器能有效消除JDBC底层的代码。
在MyBatis应用程序开发中，映射器的开发工作量占全部工作量的80%。在MyBatis中映射器的配置顶级元素不多，但是里面的一些细节，比如缓存、级联、#和￥字符的替换参数、存储过程需要我们进一步学习。
MyBatis的映射器也可以使用注解完成，但是它在企业应用不广，原因主要来自3个方面：其一，面对复杂性，SQL会显得无力，尤其是长SQL。其二，注解的可读性比较差。其三，在功能上，注解丢失了XML上下文相互引用的功能。
5.1 概述 parameterMap是MyBatis官方不推荐的元素，可能即将被删除。
5.2 select元素——查询语句 在映射器中select元素代表SQL的select语句，用于查询。在SQL中，select语句是用得最多的语句，在MyBatis中select元素也是用得最多的元素，使用的多就意味着强大和复杂。
   元素 说明 备注     id 它和Mapper的命名空间组合起来是唯一的，供MyBatis调用 如果命名空间和id结合起来不唯一，MyBatis将抛出异常   parameterType 可以给出类的全命名，也可以给出别名，但是别名必须是MyBatis内部定义或者自定义的 ——   parameterMap 即将废弃的元素，不讨论 ——   resultType 定义类的全路径，在允许自动匹配的情况下，结果集将通过JavaBean的规范映射：或定义为int、double、float、map等参数；也可以使用别名，但必须要符合别名的命名规范，且不能和resultMap同时使用 常用的参数之一，比如统计总条数数时可以把它的值设置为int   resultMap 它是映射集的引用，将执行强大的映射功能，我们可以使用resultType和resultMap其中的一个，resultMap能提供自定义映射规则的机会。 是MyBatis最复杂的元素，可以配置映射规则、级联、typeHandler   flushCache 它的作用是在调用SQL后，是否要求MyBatis清空之前查询本地缓存和二级缓存 取值为布尔值，true/false.默认值为false   useCache 启动二级缓存的开关，是否要求MyBatsi将此次结果缓存 取值为布尔值，true/false.默认值为true   timeout 设置超时参数，超时将抛出异常，单位为秒 默认值是数据库厂商提供的JDBC驱动所设置的秒数   fetchSize 获取记录的总条数设定 默认值是数据库厂商提供的JDBC驱动所设置的条数   statementType 告诉Mybatis使用哪个JDBC的Statement工作，取值为STATEMENT、PREPARED、CALLABLE 默认值为PREPARED   resultSetType 这是对JDBC的resultSet接口而言，它的值包括FORWARD_ONLY（游标允许向前访问）、SCROLL_SENSITIVE（双向滚动，但不及时更新，就是如果数据库里的数据修改过，并不再resultSet中反映出来）、SCROLL_INSENSITIVE（双向滚动，并及时跟踪数据库的更新，以便更改resultSet中的数据） 默认值是数据库厂商提供的JDBC驱动所设置的   databaseId 配置使用 提供多种数据库的支持   resultOrdered 这个设置仅适用于嵌套结果select语句，如果为true，就是假设包含了嵌套结果集或是分组了，当返回一个主结果行是，就不能引用前面结果集了。这就确保了在获取嵌套的结果集时不至于导致内存不够用。 取值为布尔值，true/false。默认值为false   resultSets 适用于多个结果集的情况，它将列出执行SQL后每个结果集的名称，每个名称之间用逗号分隔 很少使用    在实际工作中用得最多的是id、parameterType、resultType、resultMap，如果要设置缓存，还会使用到flushCache、useCache，其他的都是不常用的功能。这里主要讨论id、parameterType、resultType、resultMap及它们的映射规则。"/>

    <meta property="og:title" content="SSM第五章-映射器" />
<meta property="og:description" content="映射器是MyBatis最复杂且最重要的组件。它由一个接口加上XML文件（或者注解）组成。在映射器中可以配置参数、各类的SQL语句、存储过程、缓存、级联等复杂的内容，并且通过简易的映射规则映射到指定的POJO或者其他对象上，映射器能有效消除JDBC底层的代码。
在MyBatis应用程序开发中，映射器的开发工作量占全部工作量的80%。在MyBatis中映射器的配置顶级元素不多，但是里面的一些细节，比如缓存、级联、#和￥字符的替换参数、存储过程需要我们进一步学习。
MyBatis的映射器也可以使用注解完成，但是它在企业应用不广，原因主要来自3个方面：其一，面对复杂性，SQL会显得无力，尤其是长SQL。其二，注解的可读性比较差。其三，在功能上，注解丢失了XML上下文相互引用的功能。
5.1 概述 parameterMap是MyBatis官方不推荐的元素，可能即将被删除。
5.2 select元素——查询语句 在映射器中select元素代表SQL的select语句，用于查询。在SQL中，select语句是用得最多的语句，在MyBatis中select元素也是用得最多的元素，使用的多就意味着强大和复杂。
   元素 说明 备注     id 它和Mapper的命名空间组合起来是唯一的，供MyBatis调用 如果命名空间和id结合起来不唯一，MyBatis将抛出异常   parameterType 可以给出类的全命名，也可以给出别名，但是别名必须是MyBatis内部定义或者自定义的 ——   parameterMap 即将废弃的元素，不讨论 ——   resultType 定义类的全路径，在允许自动匹配的情况下，结果集将通过JavaBean的规范映射：或定义为int、double、float、map等参数；也可以使用别名，但必须要符合别名的命名规范，且不能和resultMap同时使用 常用的参数之一，比如统计总条数数时可以把它的值设置为int   resultMap 它是映射集的引用，将执行强大的映射功能，我们可以使用resultType和resultMap其中的一个，resultMap能提供自定义映射规则的机会。 是MyBatis最复杂的元素，可以配置映射规则、级联、typeHandler   flushCache 它的作用是在调用SQL后，是否要求MyBatis清空之前查询本地缓存和二级缓存 取值为布尔值，true/false.默认值为false   useCache 启动二级缓存的开关，是否要求MyBatsi将此次结果缓存 取值为布尔值，true/false.默认值为true   timeout 设置超时参数，超时将抛出异常，单位为秒 默认值是数据库厂商提供的JDBC驱动所设置的秒数   fetchSize 获取记录的总条数设定 默认值是数据库厂商提供的JDBC驱动所设置的条数   statementType 告诉Mybatis使用哪个JDBC的Statement工作，取值为STATEMENT、PREPARED、CALLABLE 默认值为PREPARED   resultSetType 这是对JDBC的resultSet接口而言，它的值包括FORWARD_ONLY（游标允许向前访问）、SCROLL_SENSITIVE（双向滚动，但不及时更新，就是如果数据库里的数据修改过，并不再resultSet中反映出来）、SCROLL_INSENSITIVE（双向滚动，并及时跟踪数据库的更新，以便更改resultSet中的数据） 默认值是数据库厂商提供的JDBC驱动所设置的   databaseId 配置使用 提供多种数据库的支持   resultOrdered 这个设置仅适用于嵌套结果select语句，如果为true，就是假设包含了嵌套结果集或是分组了，当返回一个主结果行是，就不能引用前面结果集了。这就确保了在获取嵌套的结果集时不至于导致内存不够用。 取值为布尔值，true/false。默认值为false   resultSets 适用于多个结果集的情况，它将列出执行SQL后每个结果集的名称，每个名称之间用逗号分隔 很少使用    在实际工作中用得最多的是id、parameterType、resultType、resultMap，如果要设置缓存，还会使用到flushCache、useCache，其他的都是不常用的功能。这里主要讨论id、parameterType、resultType、resultMap及它们的映射规则。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zereals7.github.io/post/ssm%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%98%A0%E5%B0%84%E5%99%A8/" />
<meta property="article:published_time" content="2021-04-22T18:36:47+08:00" />
<meta property="article:modified_time" content="2021-04-22T18:36:47+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://zereals7.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="Zereal" /></a>
      <h1>Zereal</h1>
      <p>Java coder</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/ZerealS7" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">SSM第五章-映射器</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Apr 22, 2021
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          3 min read
        </div></div>
    </header>
    <div class="post-content">
      <p>映射器是MyBatis最复杂且最重要的组件。它由一个接口加上XML文件（或者注解）组成。在映射器中可以配置参数、各类的SQL语句、存储过程、缓存、级联等复杂的内容，并且通过简易的映射规则映射到指定的POJO或者其他对象上，映射器能有效消除JDBC底层的代码。</p>
<p>在MyBatis应用程序开发中，映射器的开发工作量占全部工作量的80%。在MyBatis中映射器的配置顶级元素不多，但是里面的一些细节，比如缓存、级联、#和￥字符的替换参数、存储过程需要我们进一步学习。</p>
<p>MyBatis的映射器也可以使用注解完成，但是它在企业应用不广，原因主要来自3个方面：其一，面对复杂性，SQL会显得无力，尤其是长SQL。其二，注解的可读性比较差。其三，在功能上，注解丢失了XML上下文相互引用的功能。</p>
<h1 id="51-概述">5.1 概述</h1>
<p><img src="https://gitee.com/zerealsong/blogimage/raw/master/img/20210423145832.jpg" alt="2021-04-0654_4 (Copy)"></p>
<p>parameterMap是MyBatis官方不推荐的元素，可能即将被删除。</p>
<h1 id="52-select元素查询语句">5.2 select元素——查询语句</h1>
<p>在映射器中select元素代表SQL的select语句，用于查询。在SQL中，select语句是用得最多的语句，在MyBatis中select元素也是用得最多的元素，使用的多就意味着强大和复杂。</p>
<table>
<thead>
<tr>
<th align="center">元素</th>
<th align="center">说明</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">id</td>
<td align="center">它和Mapper的命名空间组合起来是唯一的，供MyBatis调用</td>
<td align="center">如果命名空间和id结合起来不唯一，MyBatis将抛出异常</td>
</tr>
<tr>
<td align="center">parameterType</td>
<td align="center">可以给出类的全命名，也可以给出别名，但是别名必须是MyBatis内部定义或者自定义的</td>
<td align="center">——</td>
</tr>
<tr>
<td align="center">parameterMap</td>
<td align="center">即将废弃的元素，不讨论</td>
<td align="center">——</td>
</tr>
<tr>
<td align="center">resultType</td>
<td align="center">定义类的全路径，在允许自动匹配的情况下，结果集将通过JavaBean的规范映射：或定义为int、double、float、map等参数；也可以使用别名，但必须要符合别名的命名规范，且不能和resultMap同时使用</td>
<td align="center">常用的参数之一，比如统计总条数数时可以把它的值设置为int</td>
</tr>
<tr>
<td align="center">resultMap</td>
<td align="center">它是映射集的引用，将执行强大的映射功能，我们可以使用resultType和resultMap其中的一个，resultMap能提供自定义映射规则的机会。</td>
<td align="center">是MyBatis最复杂的元素，可以配置映射规则、级联、typeHandler</td>
</tr>
<tr>
<td align="center">flushCache</td>
<td align="center">它的作用是在调用SQL后，是否要求MyBatis清空之前查询本地缓存和二级缓存</td>
<td align="center">取值为布尔值，true/false.默认值为false</td>
</tr>
<tr>
<td align="center">useCache</td>
<td align="center">启动二级缓存的开关，是否要求MyBatsi将此次结果缓存</td>
<td align="center">取值为布尔值，true/false.默认值为true</td>
</tr>
<tr>
<td align="center">timeout</td>
<td align="center">设置超时参数，超时将抛出异常，单位为秒</td>
<td align="center">默认值是数据库厂商提供的JDBC驱动所设置的秒数</td>
</tr>
<tr>
<td align="center">fetchSize</td>
<td align="center">获取记录的总条数设定</td>
<td align="center">默认值是数据库厂商提供的JDBC驱动所设置的条数</td>
</tr>
<tr>
<td align="center">statementType</td>
<td align="center">告诉Mybatis使用哪个JDBC的Statement工作，取值为STATEMENT、PREPARED、CALLABLE</td>
<td align="center">默认值为PREPARED</td>
</tr>
<tr>
<td align="center">resultSetType</td>
<td align="center">这是对JDBC的resultSet接口而言，它的值包括FORWARD_ONLY（游标允许向前访问）、SCROLL_SENSITIVE（双向滚动，但不及时更新，就是如果数据库里的数据修改过，并不再resultSet中反映出来）、SCROLL_INSENSITIVE（双向滚动，并及时跟踪数据库的更新，以便更改resultSet中的数据）</td>
<td align="center">默认值是数据库厂商提供的JDBC驱动所设置的</td>
</tr>
<tr>
<td align="center">databaseId</td>
<td align="center">配置使用</td>
<td align="center">提供多种数据库的支持</td>
</tr>
<tr>
<td align="center">resultOrdered</td>
<td align="center">这个设置仅适用于嵌套结果select语句，如果为true，就是假设包含了嵌套结果集或是分组了，当返回一个主结果行是，就不能引用前面结果集了。这就确保了在获取嵌套的结果集时不至于导致内存不够用。</td>
<td align="center">取值为布尔值，true/false。默认值为false</td>
</tr>
<tr>
<td align="center">resultSets</td>
<td align="center">适用于多个结果集的情况，它将列出执行SQL后每个结果集的名称，每个名称之间用逗号分隔</td>
<td align="center">很少使用</td>
</tr>
</tbody>
</table>
<p>在实际工作中用得最多的是id、parameterType、resultType、resultMap，如果要设置缓存，还会使用到flushCache、useCache，其他的都是不常用的功能。这里主要讨论id、parameterType、resultType、resultMap及它们的映射规则。</p>
<h2 id="521-简单的select元素的应用">5.2.1 简单的select元素的应用</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>select id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;countUserByFirstName&#34;</span> parameterType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;string&#34;</span> resultType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;int&#34;</span><span style="color:#f92672">&gt;</span>
select <span style="color:#a6e22e">count</span><span style="color:#f92672">(*)</span> total from t_user
where user_name like <span style="color:#a6e22e">concat</span><span style="color:#f92672">(</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">(</span>firstName<span style="color:#f92672">),</span><span style="color:#960050;background-color:#1e0010">‘</span><span style="color:#f92672">%</span><span style="color:#960050;background-color:#1e0010">’</span><span style="color:#f92672">)</span>
<span style="color:#f92672">&lt;/</span>select<span style="color:#f92672">&gt;</span>
</code></pre></div><ul>
<li>id配合Mapper的全限定名，联合成为一个唯一的标识，用于标识这条SQL。</li>
<li>parameterType表示这条SQL接受的参数类型，可以是MyBatis系统定义或者自定义的别名，比如int、string、float等，也可以是类的全限定名，比如com.learn.ssmchapter5.pojo.User</li>
<li>resultType表示这条SQL返回的结果类型，与parameterTYpe一样，可以是系统定义或者自定义的别名，也可以是类的全限定名。</li>
<li>#{firstName}是被传递进去的参数。</li>
</ul>
<p>只有这条SQL还不够，我们还需要给一个接口方法程序才能运行起来，比如SQL可以这样定义接口方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span>  Integer <span style="color:#a6e22e">countUserByFirstName</span><span style="color:#f92672">(</span>String firstName<span style="color:#f92672">);</span>
</code></pre></div><h2 id="522-自动映射和驼峰映射">5.2.2 自动映射和驼峰映射</h2>
<p>MyBatis提供了自动映射功能，在默认情况下自动映射是开启的，使用它的好处在于能有效减少大量的映射配置，从而减少工作量。</p>
<p>在setting元素中有两个可以配置的选项autoMappingBehavior和mapUnderscoreToCamelCase;它们是控制自动映射和驼峰映射的开关。一般而言，自动映射会使用得多一些，因为可以通过SQL别名机制处理一些细节，比较灵活，而驼峰映射则要求比较严苛，所以在实际中应用不算太广。</p>
<p>配置自动映射的autoMappingBehavior选项的取值范围是：</p>
<ul>
<li>NONE，不进行自动映射</li>
<li>PARTIAL,默认值，只对没有嵌套结果进行自动映射。</li>
<li>FULL，对所有的结果集进行自动映射，包括嵌套结果集。</li>
</ul>
<p>在默认情况下，使用默认的PARTIAL级别就可以了。为了实现自动映射，首先要给出POJO——Role .</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Role</span><span style="color:#f92672">{</span>
	<span style="color:#66d9ef">private</span> Long id<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> String roleName<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> String note<span style="color:#f92672">;</span>
	
	<span style="color:#75715e">/**setter and getter**/</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这是一个十分简单的POJO，它定义了3个属性及其setter和getter方法。如果编写SQL列名和属性名保持一致，那么它就会形成自动映射，比如通过角色编号（id)获取角色的信息。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>select id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;getRole&#34;</span> parameterType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;long&#34;</span>
	resultType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.learn.ssm.chapter5.pojo.Role&#34;</span><span style="color:#f92672">&gt;</span>
	select id<span style="color:#f92672">,</span>role_name as roleName<span style="color:#f92672">,</span>note from t_role where id<span style="color:#f92672">=</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>id<span style="color:#f92672">}</span>
	<span style="color:#f92672">&lt;/</span>select<span style="color:#f92672">&gt;</span>
</code></pre></div><p>原来的列名role_name被别名roleName代替了，这样就和POJO上的属性名称保持一致了。此时MyBatis就会将这个结果集 映射到POJO的属性roleName上，自动完成映射，而无须再进行 任何配置，明显减少了工作量。</p>
<p>如果系统都严格按照驼峰命名法（比如，数据库字段为role_name，则POJO属性名为roleName）,那么只要再配置项把mapUnderscoreToCamelCase设置为true即可。如果这样做上面的SQL可以改写成：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">select id<span style="color:#f92672">,</span>role_name<span style="color:#f92672">,</span>note from t_role where id<span style="color:#f92672">=</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>id<span style="color:#f92672">}</span>
</code></pre></div><p>MyBatis会严格按照驼峰命名的方式做自动映射，只是这样会要求数据字段和POJO属性名严格对应，降低了灵活性。 这也是实际工作中需要考虑的问题。</p>
<p>自动映射和驼峰映射都建立再SQL列名和POJO属性名的映射关系上，而现实中会更加复杂，比如可能有些字段有主表和从表关联的级联，又如typeHandler的复杂转换规则，此时resultType元素是无法满足这些需求的。如果需要更为强大的映射规则，则需要考虑使用resultMap,它是MyBatis中最复杂的元素。</p>
<h2 id="523-传递多个参数">5.2.3 传递多个参数</h2>
<p><strong>1.使用map接口传递参数</strong></p>
<p>再MyBatis中允许map接口通过键值对传递多个参数，把接口方法定义为：</p>
<pre><code>public List&lt;Role&gt; findRolesByMap（Map&lt;String,Object&gt; parameterMap）;
</code></pre><p>此时，传递给映射器的是一个map对象，使用它在SQL中设置对应的参数</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>select id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;findRolesByMap&#34;</span> parameterType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;map&#34;</span>
	resultType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;role&#34;</span><span style="color:#f92672">&gt;</span>
	select id<span style="color:#f92672">,</span>role_name as roleName<span style="color:#f92672">,</span>note from t_role 
    where role_name like <span style="color:#a6e22e">concat</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">,</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>roleName<span style="color:#f92672">},</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">)</span>
    and note like <span style="color:#a6e22e">concat</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">,</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>roleName<span style="color:#f92672">},</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">)</span>
	<span style="color:#f92672">&lt;/</span>select<span style="color:#f92672">&gt;</span>
</code></pre></div><p>注意，参数roleName和note，要求的是map的键,按以下的方法设置map参数，并传递。</p>
<pre><code>RoleMapper  roleMapper=sqlSesision.getMapper（RoleMapper.class);
Map&lt;String，Object&gt; parameterMap =new HashMap&lt;String,Object&gt;();
parameterMap.put(&quot;roleName&quot;,&quot;1&quot;);
parameterMap.put(&quot;note&quot;,&quot;1&quot;);
List&lt;Role&gt; roles=roleMapper.findRolesByMap(parameterMap);
</code></pre><p>在SQL中的参数标识将会被这里设置的参数所取代，这样就能够允许了。严格来说，map适用于几乎所有的场景，但是我们用得不多。原因有两个：首先，map是一个键值对应的集合，使用者要通过阅读它的键，才能明了器作用；其次，使用map不能限定其传递的数据类型，因此业务性质不强，可读性差，使用者要读懂代码才能知道需要传递什么参数给它，所有不推荐用这种方式传递多个参数。</p>
<p><strong>2.使用注解传递多个参数</strong></p>
<p>使用map传递多个参数的弊病——可读性差。为此MyBatis为开发者提供了一个注解@Param，可以通过它取定义映射器的参数名称，使用它可以得到更好的可读性。把接口方法定义为：</p>
<pre><code>public List&lt;Role&gt; findRolesByAnnotation(@Param(&quot;roleName&quot;)String rolename,
@Param(&quot;note&quot;)String note);
</code></pre><p>此时段代码的可读性大大提高了，使用者能明确参数roelName是角色名称，而note是备注，一目了然，这个时候需要修改映射文件的代码</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>select id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;findRolesByMap&#34;</span>
	resultType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;role&#34;</span><span style="color:#f92672">&gt;</span>
	select id<span style="color:#f92672">,</span>role_name as roleName<span style="color:#f92672">,</span>note from t_role 
    where role_name like <span style="color:#a6e22e">concat</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">,</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>roleName<span style="color:#f92672">},</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">)</span>
    and note like <span style="color:#a6e22e">concat</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">,</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>roleName<span style="color:#f92672">},</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">)</span>
	<span style="color:#f92672">&lt;/</span>select<span style="color:#f92672">&gt;</span>
</code></pre></div><p>注意，此时并不需要给出parameterType属性，让MyBatis自动探索便可以了。通过改写使可读性大大提高，使用者也方便了，但是会带来一个麻烦。如果SQL很复杂，拥有大于10个参数，那么接口方法的参数个数就多了，使用起来就很不容易，不过不必担心，MyBatis还提供传递JavaBean的形式。</p>
<p><strong>3.通过JavaBean传递多个参数</strong></p>
<p>先定义一个参数的POJO——RoeParams</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RoleParams</span><span style="color:#f92672">{</span>
	<span style="color:#66d9ef">private</span> String roleName<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> String note<span style="color:#f92672">;</span>
	<span style="color:#75715e">/**setter and gettter**/</span>
<span style="color:#f92672">}</span>

</code></pre></div><p>此时把接口方法定义为</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> List<span style="color:#f92672">&lt;</span>Role<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">findRolesByBean</span><span style="color:#f92672">(</span>RoleParams roleParam<span style="color:#f92672">);</span>
</code></pre></div><p>Java Bean的属性roleName代表角色名称，而note代表备注，按下面的方法修改映射文件：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>select id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;findRolesByMap&#34;</span> parameterType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.learn.ssm.chapter5.param.RoleParams&#34;</span>
	resultType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;role&#34;</span><span style="color:#f92672">&gt;</span>
	select id<span style="color:#f92672">,</span>role_name as roleName<span style="color:#f92672">,</span>note from t_role 
    where role_name like <span style="color:#a6e22e">concat</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">,</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>roleName<span style="color:#f92672">},</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">)</span>
    and note like <span style="color:#a6e22e">concat</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">,</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>roleName<span style="color:#f92672">},</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">)</span>
	<span style="color:#f92672">&lt;/</span>select<span style="color:#f92672">&gt;</span>
</code></pre></div><p>引入Java Bean定义的属性作为参数，然后查询</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">RoleMapper  roleMapper<span style="color:#f92672">=</span>sqlSesision<span style="color:#f92672">.</span><span style="color:#a6e22e">getMapper</span><span style="color:#960050;background-color:#1e0010">（</span>RoleMapper<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">);</span>
RoleParams roleParams <span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> RoleParams<span style="color:#f92672">();</span>
roleParams<span style="color:#f92672">.</span><span style="color:#a6e22e">setRoleName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;1&#34;</span><span style="color:#f92672">);</span>
roleParams<span style="color:#f92672">.</span><span style="color:#a6e22e">setNote</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;1&#34;</span><span style="color:#f92672">);</span>
List<span style="color:#f92672">&lt;</span>Role<span style="color:#f92672">&gt;</span> roles<span style="color:#f92672">=</span>roleMapper<span style="color:#f92672">.</span><span style="color:#a6e22e">findRolesByBean</span><span style="color:#f92672">(</span>roleParams<span style="color:#f92672">);</span>
</code></pre></div><p><strong>4.混合使用</strong></p>
<p>在某些情况下可能需要混合使用几种方法来传递参数。举个例子，查询一个角色可以通过角色名称和备注进行查询，于此同时还需要支持分页，而分页的POJO实现如下：</p>
<pre><code>public class PageParams{
private int sttart;
private int limit;
/**setter and getter**/
}
</code></pre><p>这个时候接口设计如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> List<span style="color:#f92672">&lt;</span>Role<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">findByMix</span><span style="color:#f92672">(</span><span style="color:#a6e22e">@Param</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;params&#34;</span><span style="color:#f92672">)</span> RoleParams roleParams<span style="color:#f92672">,</span><span style="color:#a6e22e">@Param</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;page&#34;</span><span style="color:#f92672">)</span> PageParam PageParam<span style="color:#f92672">);</span>
</code></pre></div><p>这样不仅是可行的，也是合理的，当然MyBatis也为此做了支持，把映射文件修改为如下</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>select id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;findByMix&#34;</span>
	resultType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;role&#34;</span><span style="color:#f92672">&gt;</span>
	select id<span style="color:#f92672">,</span>role_name as roleName<span style="color:#f92672">,</span>note from t_role 
    where role_name like <span style="color:#a6e22e">concat</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">,</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>roleName<span style="color:#f92672">},</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">)</span>
    and note like <span style="color:#a6e22e">concat</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">,</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>roleName<span style="color:#f92672">},</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">)</span>
    limit <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">(</span>page<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">),</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">(</span>page<span style="color:#f92672">.</span><span style="color:#a6e22e">limit</span><span style="color:#f92672">)</span>
	<span style="color:#f92672">&lt;/</span>select<span style="color:#f92672">&gt;</span>
</code></pre></div><p>这样就能使用混合参数了，其中MyBatis对params和page这类Java Bean参数提供了EL（中间语言）支持，为编程带来了很多的便利。</p>
<p><strong>5.总结</strong></p>
<ul>
<li>使用map传递参数导致业务可读性的丧失，导致后续扩展和维护的困难，在实际的应用中要果断废弃这种方式。</li>
<li>使用@Param注解传递多个参数，受到参数个数的影响。当n&lt;=5时，这是最佳的传参方式，它比JavaBean更好，因为它更加直观；当n&gt;5时，多个参数将给调用带来困难，此时不推荐使用它。</li>
<li>当参数个数多于5个时，建议使用Java Bean方式。</li>
<li>对于使用混合参数的，要明确参数的合理性。</li>
</ul>
<p>5.2.4 使用resultMap映射结果集</p>
<p>自动映射和驼峰规则比较简单，无法定义多的属性，比如typeHandler 、级联等。为了支持复杂的映射，select元素提供了resultMap属性。先定义resultMap属性。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>mapper namespace<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.learn.ssm.chapter5.mapper.RoleMapper&#34;</span><span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;</span>resultMap id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;roleMap&#34;</span> type<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;role&#34;</span><span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;</span>id property<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;id&#34;</span> column<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;id&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;</span>result property<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;roleName&#34;</span> column<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;role_name&#34;</span><span style="color:#f92672">/</span> <span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;/</span>result<span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;</span>select id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;getRoleUserResultMap&#34;</span><span style="color:#f92672">&gt;</span>
parameterType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;long&#34;</span> resultMap<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;roleMap&#34;</span><span style="color:#f92672">&gt;</span>
select id<span style="color:#f92672">,</span>role_name<span style="color:#f92672">,</span>note from t_role where id<span style="color:#f92672">=</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>id<span style="color:#f92672">}</span>
<span style="color:#f92672">&lt;/</span>select<span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;/</span>mapper<span style="color:#f92672">&gt;</span>

</code></pre></div><ul>
<li>resultMap元素定义了一个roleMap，它的属性id代表它的标识，type代表使用哪个类 作为其映射的类，可以是别名或者全限定名，role是com.learn.ssm.chapter5.pojo.Role的别名。</li>
<li>它的子元素id代表resultMap的主键，而result代表其属性，id和result元素的属性property代表POJO的属性名称，而column代表SQL的列名。把POJO的属性和SQL的列名做对应，例如POJO的属性roleName，就用SQL的列名role_name建立映射关系。</li>
<li>在select元素中的属性resultMap制定了采用哪个resultMap作为其映射规则。</li>
</ul>
<h2 id="524-分页参数rowbounds">5.2.4 分页参数RowBounds</h2>
<p>MyBatis不仅支持分页，它还内置了一个专门处理分页的类——RowBounds。</p>
<p><strong>RowBounds源码</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">package</span> org.apache.ibatis.session<span style="color:#f92672">;</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RowBounds</span><span style="color:#f92672">{</span>
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> NO_ROW_OFFSET<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> NO_ROW_LIMIT<span style="color:#f92672">=</span>Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">;</span>
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> RowBounds DEFAULT <span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> RowBounds<span style="color:#f92672">();</span>
	
	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> offset<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> limit<span style="color:#f92672">;</span>
	
	<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">RowBounds</span><span style="color:#f92672">(){</span>
	<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">offset</span> <span style="color:#f92672">=</span> NO_ROW_OFFSET<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">limit</span> <span style="color:#f92672">=</span> NO_ROW_LIMIT<span style="color:#f92672">;</span>
	<span style="color:#f92672">}</span>
	
	<span style="color:#66d9ef">public</span> RowBounds<span style="color:#960050;background-color:#1e0010">（</span><span style="color:#66d9ef">int</span> offset<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> limit<span style="color:#f92672">){</span>
		<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">offset</span><span style="color:#f92672">=</span>offset<span style="color:#f92672">;</span>
		<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">limit</span><span style="color:#f92672">=</span>limit<span style="color:#f92672">;</span>
	<span style="color:#f92672">}</span>
	
	<span style="color:#75715e">/****setter and getter****/</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>offset 属性是偏移量，即从第几行开始读取记录。Limit是限制 条数，从源码可知，默认值为0和Java的最大整数（2147483647），使用它十分的简单，只要给接口增加一个RowBounds参数即可。</p>
<pre><code>public List&lt;Role&gt; findByRowBounds（@Param(&quot;roleName&quot;) String rolename,@Param(&quot;note&quot;) String note,RowBounds rowBounds）;
</code></pre><p>对于SQL而言</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>select id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;findByRowBounds&#34;</span>
	resultType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;role&#34;</span><span style="color:#f92672">&gt;</span>
	select id<span style="color:#f92672">,</span>role_name as roleName<span style="color:#f92672">,</span>note from t_role 
    where role_name like <span style="color:#a6e22e">concat</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">,</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>roleName<span style="color:#f92672">},</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">)</span>
    and note like <span style="color:#a6e22e">concat</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">,</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>roleName<span style="color:#f92672">},</span><span style="color:#e6db74">&#39;%&#39;</span><span style="color:#f92672">)</span>
	<span style="color:#f92672">&lt;/</span>select<span style="color:#f92672">&gt;</span>
</code></pre></div><p>没有任何关于RowBounds参数的信息，它是MyBatis的一个附加参数，MyBatis会自动识别它，据此进行分页。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">SqlSession sqlSession <span style="color:#f92672">=</span><span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#66d9ef">try</span><span style="color:#f92672">{</span>
	sqlSerssion<span style="color:#f92672">=</span>SqlSessionFactoeyUtils<span style="color:#f92672">.</span><span style="color:#a6e22e">openSqlSession</span><span style="color:#f92672">();</span>
	RoleMapper roleMapper<span style="color:#f92672">=</span>sqlSession<span style="color:#f92672">.</span><span style="color:#a6e22e">getMapper</span><span style="color:#f92672">(</span>RoleMapper<span style="color:#f92672">.</span><span style="color:#a6e22e">classs</span><span style="color:#f92672">);</span>
	RowBounds rowBounds<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> RowBounds<span style="color:#f92672">(</span>0<span style="color:#f92672">,</span>20<span style="color:#f92672">);</span>
	List<span style="color:#f92672">&lt;</span>Role<span style="color:#f92672">&gt;</span> roleList <span style="color:#f92672">=</span>roleMapper<span style="color:#f92672">.</span><span style="color:#a6e22e">findByRowBounds</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;role_name&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;note&#34;</span><span style="color:#f92672">,</span>rowBounds<span style="color:#f92672">);</span>
	System<span style="color:#f92672">.</span><span style="color:#a6e22e">err</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>roleList<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">());</span>
<span style="color:#f92672">}</span><span style="color:#66d9ef">catch</span><span style="color:#f92672">(</span>Exception e<span style="color:#f92672">){</span>
	e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span><span style="color:#66d9ef">finally</span><span style="color:#f92672">{</span>
	<span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>sqlSession<span style="color:#f92672">!=</span><span style="color:#66d9ef">null</span><span style="color:#f92672">){</span>
	sqlSession<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">;</span>
	<span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>运行代码就可以限定查询返回至多20条记录的结果，而这里要注意RowBounds分页运行的场景，它之恶能运用于一些小数据量的查询。RowBounds分页的原理是执行SQL的查询后，按照偏移量和限制条数返回查询结果，所以对于大量更多数据查询，它的性能并不佳，此时可以通过分页插件去处理。</p>
<h1 id="53-insert元素插入语句">5.3 insert元素——插入语句</h1>
<h2 id="531-概述">5.3.1 概述</h2>
<p>执行select的基础是先插入数据，而插入数据依赖于insert语句。相对于select而言，insert语句就简单多了，在MyBatis中insert语句就简单多了，在MyBatis中insert语句可以配置以下属性。</p>
<p>insert语句的配置</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>idw</td>
<td>SQL编号，用于标识这条SQL</td>
<td>命名空间+id+databaseId唯一，否则MyBatis会抛出异常</td>
</tr>
<tr>
<td>parameterType</td>
<td>参数类型，同select元素</td>
<td>和select一样，可以是单个参数或者多个参数</td>
</tr>
<tr>
<td>parameterMap</td>
<td>参数的Map,即将废弃</td>
<td>本书不讨论它</td>
</tr>
<tr>
<td>flushCache</td>
<td>是否刷新缓存，可以配置true/false,为true时，插入时会刷新一级和二级缓存，否则不刷新</td>
<td>默认值为true</td>
</tr>
<tr>
<td>timeout</td>
<td>超时时间，单位为秒</td>
<td></td>
</tr>
<tr>
<td>statementType</td>
<td>STATEMENT、PRTEPARED活泼CALLABLE中的以恶搞。这回让MyBatis分别使用Statement、PreparedStatement（预编译）或CallableStatement(存储过程)</td>
<td>默认值为PREPARED</td>
</tr>
<tr>
<td>userGeneratedKeys</td>
<td>是否启JDBC的getGeneratedKeys方法来取出由数据库内部生成的主键。（比如MySQL和SQL Server这样的数据库表的自增主键）</td>
<td>默认值为false</td>
</tr>
<tr>
<td>keyProperty</td>
<td>（仅对insert和update有用）唯一标记一个属性，MyBatis会通过getGeneratedKeys的返回值，或者通过insert语句的selectKey子元素设置它的键值。如果是复合主键，要把每一个名称用逗号（，）隔开</td>
<td>默认值为unset。不能和keyColumn连用</td>
</tr>
<tr>
<td>keyColumn</td>
<td>（仅对insert和update有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像PostgreSQL）中是必须的，当主键列不是表中的第一列需要设置。如果是复合主键，需要把每一个名称用逗号（，）隔开</td>
<td>不能和keyProperty连用</td>
</tr>
<tr>
<td>datasbaseId</td>
<td>参见本书的4.9节</td>
<td>——</td>
</tr>
</tbody>
</table>
<p>MyBatis在执行完一条insert语句后，会返回一个整数表示其影响的记录数。</p>
<h2 id="532-简单的insert语句的应用">5.3.2 简单的insert语句的应用</h2>
<p>写一个SQL插入角色，这是一条最简单的插入语句。</p>
<p><strong>插入角色</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>insert id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;insertRole&#34;</span> parameterType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;role&#34;</span><span style="color:#f92672">&gt;</span>
insert into <span style="color:#a6e22e">t_role</span><span style="color:#f92672">(</span>role_name<span style="color:#f92672">,</span>note<span style="color:#f92672">)</span> values<span style="color:#f92672">(</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>roleName<span style="color:#f92672">},</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>note<span style="color:#f92672">})</span>
<span style="color:#f92672">&lt;</span>insert<span style="color:#f92672">&gt;</span>
</code></pre></div><ul>
<li>id 标识出这条SQL，结合命名空间让MyBatis能够找到它。</li>
<li>parameterType代表传入参数类型。</li>
</ul>
<p>没有配置的属性将采用默认值，这样就完成了一个角色的插入。</p>
<h2 id="533-主键回填">5.3.3 主键回填</h2>
<p>上面展示了最简单的插入语句，但是它并没有插入id列，因为MySQL中的表格采用自增主键，MySQL数据库会为该记录生成对应的主键。有时候还可能需要继续使用这个主键，用以关联其他业务，因此有时候把它取到是十分必要的，比如新增用户时，首先会插入用户表的记录，然后插入用户和角色关系表，插入用户和角色关系表，插入用户时如果没有办法取到用户的主键，那么就没有办法插入用户和角色关系表了，因此在这个时候要拿到对应的主键，以便后面的操作，MyBatis提供了这样的这次hi。</p>
<p>JDBC中的Statement对象在执行插入的SQL后，可以通过getGeneratedKeys方法获得数据库生成的主键（需要数据库驱动支持），这样便能达到获取主键的功能。在insert语句中有一个开关属性useGeneratedKeys，用来控制是否打开这个功能，它的默认值为false。当打开了这个开关，还要配置其属性keyProperty或keyColumn,告诉系统把生成的主键放入哪个属性中，如果存在多个主键，就要用逗号（，）将它们隔开。</p>
<p>返回主键</p>
<pre><code>&lt;insert id=&quot;insertRole&quot; parameterType=&quot;role&quot;
useGenenratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
insert into t_role(role_name,note) values(#{roleName},#{note})
&lt;/insert&gt;
</code></pre><p>useGeneratedKeys代表采用JDBC的Statement对象的getGeneratedKeys方法返回主键，而keyProperty则代表将用哪个POJO的属性去匹配这个主键，这里是id，说明它会用数据库生成的主键去赋值给这个POJO，测试主键回填的结果。</p>
<p>代码中设置了断点，在断点前并没有给role对象的id属性复制，而在执行InsertRole方法后，通过监控role对象，就可以发现MyBatis给这个对象的id赋了值，拿到这个值，就可以在业务代码中执行下一步的关联和操作了。</p>
<p><img src="https://gitee.com/zerealsong/blogimage/raw/master/img/20210424021927.jpg" alt="2021-04-2418 (Copy)"></p>
<h2 id="534-自定义主键">5.3.4 自定义主键</h2>
<p>有时候主键可能依赖于某些规则，比如取消角色表（t）的id递增规则，而将其规则为：</p>
<ul>
<li>当角色表记录 为空，id 设置为1。</li>
<li>当角色表记录不为空时，id设置为当前id加3。</li>
</ul>
<p>MyBatis对这样的场景也提供了支持，它主要依赖于selectKey元素进行支持，它允许自定义键值的生成规则。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>insert id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;insertRole&#34;</span> parameterType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;role&#34;</span><span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;</span>selectKey keyProperty <span style="color:#f92672">=</span><span style="color:#e6db74">&#34;id&#34;</span> resultType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;long&#34;</span> order<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;BEFORE&#34;</span><span style="color:#f92672">&gt;</span>
select <span style="color:#a6e22e">if</span> <span style="color:#f92672">(</span>max<span style="color:#f92672">(</span>id<span style="color:#f92672">)=</span><span style="color:#66d9ef">null</span><span style="color:#f92672">,</span>1<span style="color:#f92672">,</span>max<span style="color:#f92672">(</span>id<span style="color:#f92672">)+</span>3<span style="color:#f92672">)</span> from t_role
<span style="color:#f92672">&lt;/</span>selectKey<span style="color:#f92672">&gt;</span>
insert into <span style="color:#a6e22e">t_role</span><span style="color:#f92672">(</span>id<span style="color:#f92672">,</span>role_name<span style="color:#f92672">,</span>note <span style="color:#a6e22e">values</span><span style="color:#f92672">(</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>id<span style="color:#f92672">},</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>roleName<span style="color:#f92672">},</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>note<span style="color:#f92672">})</span>
<span style="color:#f92672">&lt;/</span>insert<span style="color:#f92672">&gt;</span>
</code></pre></div><p>上述代码定义了selectKeyyuasnu ,它的keyProperty指定了采用哪个属性作为POJO的主键。resultType告诉MyBatis将返回一个long型的结果集，而order设置为BEFORE,说明它将于当前定义的SQL前执行。通过这样就可以自定义主键的规则，可见MyBatis十分灵活。这里的order配置为BEFORE,说明它会在插入之前先执行生成主键的SQL，然后插入数据。如果有一些特殊需要，可以把它色湖之为AFTER，比如一些插入语句内部可能有嵌入索引调用，这样它就会在插入语句之后执行了。</p>
<h1 id="54----update元素和delete元素">5.4    update元素和delete元素</h1>
<p>因为update元素和delete元素比较简单，所以放在一起讨论。它们和insert的属性差不多，执行完也会返回一个整数，用以标识该SQL语句影响了数据库的记录行数。</p>
<pre><code>&lt;update id=&quot;updateRole&quot; ParameterType=“role&quot;&gt;
	update t_role set role_name=#{roleName},note=#{note}
	where id=#{id}
&lt;/update&gt;

&lt;delete id=&quot;deleteRole&quot; parameterType=&quot;long&quot;&gt;
delete from t_role where id=#{id}
&lt;/delete&gt;
</code></pre><p>我们遇到的场景大部分是类似这样的，比较简单，最后MyBatis会返回一个整数，标识对应的SQL执行后会影响了多少条数据库表里的记录。至于参数可以参考select元素的参数规则，在MyBatis中它们的规则是通用的。</p>
<h2 id="55-sql元素">5.5 sql元素</h2>
<p>sql元素的作用在于定义一条SQL的一部分，方便后面的SQL引用它，比如最典型的列名。通常要在select、insert等语句中反复编写它们，特别是那些字段比较多的表更是如此，而在MyBatis中，只需要使用sql元素编写一次便能在其他元素中引用它了。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">sql</span> id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;roleCols&#34;</span><span style="color:#f92672">&gt;</span>
id,role_name,note
<span style="color:#f92672">&lt;/</span><span style="color:#66d9ef">sql</span><span style="color:#f92672">&gt;</span>
</code></pre></div><p>通过sql元素进行定义，就可以通过include元素引入到各条SQL中了。这样的代码，在字段多的数据库表中可以重复使用，从而减少对其列名的重复编写。</p>
<pre><code>&lt;include refid=&quot;roleCols&quot;/&gt;
</code></pre><p>sql元素还支持变量传递</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>sql id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;roleCols&#34;</span><span style="color:#f92672">&gt;</span>
$<span style="color:#f92672">{</span>alias<span style="color:#f92672">}.</span><span style="color:#a6e22e">id</span><span style="color:#f92672">,</span>$<span style="color:#f92672">{</span>alias<span style="color:#f92672">}.</span><span style="color:#a6e22e">role_name</span><span style="color:#f92672">,</span>$<span style="color:#f92672">{</span>alias<span style="color:#f92672">}.</span><span style="color:#a6e22e">note</span>
<span style="color:#f92672">&lt;/</span>sql<span style="color:#f92672">&gt;</span>

<span style="color:#f92672">&lt;</span>select id<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;getRole&#34;</span> parameterType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;long&#34;</span> resultType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;roleMap&#34;</span><span style="color:#f92672">&gt;</span>
select
<span style="color:#f92672">&lt;</span>include refid<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;roleCols&#34;</span><span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;</span>property name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;alias&#34;</span> value<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;r&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;/</span>include<span style="color:#f92672">&gt;</span>
from t_role r where id<span style="color:#f92672">=</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">{</span>id<span style="color:#f92672">}</span>
<span style="color:#f92672">&lt;/</span>select<span style="color:#f92672">&gt;</span>
</code></pre></div><p>在include元素中定义了一个命名为alias的变量，其值是SQL中表t_role的别名r，然后sql元素就能够使用这个变量名。</p>
<h1 id="56-参数">5.6 参数</h1>
<h2 id="561-概述">5.6.1 概述</h2>
<p>一些数据库字段返回为null,而MyBatis系统又检测不到使用何种jdbcType进行处理时，会发生异常的情况，这个时候执行对应的typeHandler进行处理，MyBatis就知道采取哪个typeHandler进行处理了。</p>
<p>MyBatis会更具javaType和jdbcType去检测使用哪个typeHandler。如果roleName是一个没有注册的类型，那么就会发生异常。因为MyBatis无法找到对应的typeHandler来转换数据类型。此时可以</p>

    </div>
    <div class="post-footer">
      
    </div>
    <div class="post-comment">
      
      


<span id="/post/ssm%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%98%A0%E5%B0%84%E5%99%A8/" class="leancloud_visitors" data-flag-title="SSM第五章-映射器">
    <span class="post-meta-item-text">文章阅读量 </span>
    <span class="leancloud-visitors-count">1000000</span>
    <p></p>
  </span>
<div id="vcomments"></div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script type="text/javascript">
  new Valine({
    el: '#vcomments' ,
    appId: 'cScQmclMsD4OOWCclCP1pNsz-gzGzoHsz',
    appKey: 'dtSaHLmdH3J4ICVVInYg9YFM',
    notify:  false ,
  verify:  false ,
  avatar:'mm',
    placeholder: '说点什么吧...',
    visitor:  true 
  });
</script>

    </div>
  </article>

    </main>
  </body>
</html>
