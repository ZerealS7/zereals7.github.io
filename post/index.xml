<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Zereal-宋致远技术博客</title>
    <link>https://zereals7.github.io/post/</link>
    <description>Recent content in Posts on Zereal-宋致远技术博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 26 Apr 2021 00:21:44 +0800</lastBuildDate>
    
	<atom:link href="https://zereals7.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java日志的使用</title>
      <link>https://zereals7.github.io/post/java%E6%97%A5%E5%BF%97%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 26 Apr 2021 00:21:44 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/java%E6%97%A5%E5%BF%97%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>ava日志：日志就是记录程序的运行轨迹，方便查找关键信息，也方便快速定位解决问题。
常用的日志框架：Log4j 、Slf4j 、Logback 。
在JDK 1.3及以前，Java打日志依赖System.out.println(), System.err.println()或者e.printStackTrace()，Debug日志被写到STDOUT流，错误日志被写到STDERR流。这样打日志有一个非常大的缺陷，即无法定制化，且日志粒度不够细。于是， Gülcü 于2001年发布了Log4j，后来成为Apache 基金会的顶级项目。Log4j 在设计上非常优秀，对后续的 Java Log 框架有长久而深远的影响，它定义的Logger、Appender、Level等概念如今已经被广泛使用。Log4j 的短板在于性能，在Logback 和 Log4j2 出来之后，Log4j的使用也减少了。
Slf4j 也是现在主流的日志门面框架，使用 Slf4j 可以很灵活的使用占位符进行参数占位，简化代码，拥有更好的可读性。
Logback 是 Slf4j 的原生实现框架，同样也是出自 Log4j 一个人之手，但拥有比 log4j 更多的优点、特性和更做强的性能，现在基本都用来代替 log4j 成为主流。
日志级别
日志级别详解 日志级别	描述 OFF	关闭：最高级别，不输出日志。 FATAL	致命：输出非常严重的可能会导致应用程序终止的错误。 ERROR	错误：输出错误，但应用还能继续运行。 WARN	警告：输出可能潜在的危险状况。 INFO	信息：输出应用运行过程的详细信息。 DEBUG	调试：输出更细致的对调试应用有用的信息。 TRACE	跟踪：输出更细致的程序运行轨迹。 ALL	所有：输出所有级别信息。
日志优先级别标准顺序为：ALL &amp;lt; TRACE &amp;lt; DEBUG &amp;lt; INFO &amp;lt; WARN &amp;lt; ERROR &amp;lt; FATAL &amp;lt; OFF
什么时候打日志：
当你遇到问题的时候，只能通过debug功能来确定问题，你应该考虑打日志，良好的系统，是可以通过日志进行问题定为的。 当你碰到if…else 或者 switch这样的分支时，要在分支的首行打印日志，用来确定进入了哪个分支 经常以功能为核心进行开发，你应该在提交代码前，可以确定通过日志可以看到整个流程 项目开发中打日志的基本格式：</description>
    </item>
    
    <item>
      <title>SSM第五章-映射器</title>
      <link>https://zereals7.github.io/post/ssm%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%98%A0%E5%B0%84%E5%99%A8/</link>
      <pubDate>Thu, 22 Apr 2021 18:36:47 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/ssm%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%98%A0%E5%B0%84%E5%99%A8/</guid>
      <description>映射器是MyBatis最复杂且最重要的组件。它由一个接口加上XML文件（或者注解）组成。在映射器中可以配置参数、各类的SQL语句、存储过程、缓存、级联等复杂的内容，并且通过简易的映射规则映射到指定的POJO或者其他对象上，映射器能有效消除JDBC底层的代码。
在MyBatis应用程序开发中，映射器的开发工作量占全部工作量的80%。在MyBatis中映射器的配置顶级元素不多，但是里面的一些细节，比如缓存、级联、#和￥字符的替换参数、存储过程需要我们进一步学习。
MyBatis的映射器也可以使用注解完成，但是它在企业应用不广，原因主要来自3个方面：其一，面对复杂性，SQL会显得无力，尤其是长SQL。其二，注解的可读性比较差。其三，在功能上，注解丢失了XML上下文相互引用的功能。
5.1 概述 parameterMap是MyBatis官方不推荐的元素，可能即将被删除。
5.2 select元素——查询语句 在映射器中select元素代表SQL的select语句，用于查询。在SQL中，select语句是用得最多的语句，在MyBatis中select元素也是用得最多的元素，使用的多就意味着强大和复杂。
   元素 说明 备注     id 它和Mapper的命名空间组合起来是唯一的，供MyBatis调用 如果命名空间和id结合起来不唯一，MyBatis将抛出异常   parameterType 可以给出类的全命名，也可以给出别名，但是别名必须是MyBatis内部定义或者自定义的 ——   parameterMap 即将废弃的元素，不讨论 ——   resultType 定义类的全路径，在允许自动匹配的情况下，结果集将通过JavaBean的规范映射：或定义为int、double、float、map等参数；也可以使用别名，但必须要符合别名的命名规范，且不能和resultMap同时使用 常用的参数之一，比如统计总条数数时可以把它的值设置为int   resultMap 它是映射集的引用，将执行强大的映射功能，我们可以使用resultType和resultMap其中的一个，resultMap能提供自定义映射规则的机会。 是MyBatis最复杂的元素，可以配置映射规则、级联、typeHandler   flushCache 它的作用是在调用SQL后，是否要求MyBatis清空之前查询本地缓存和二级缓存 取值为布尔值，true/false.默认值为false   useCache 启动二级缓存的开关，是否要求MyBatsi将此次结果缓存 取值为布尔值，true/false.默认值为true   timeout 设置超时参数，超时将抛出异常，单位为秒 默认值是数据库厂商提供的JDBC驱动所设置的秒数   fetchSize 获取记录的总条数设定 默认值是数据库厂商提供的JDBC驱动所设置的条数   statementType 告诉Mybatis使用哪个JDBC的Statement工作，取值为STATEMENT、PREPARED、CALLABLE 默认值为PREPARED   resultSetType 这是对JDBC的resultSet接口而言，它的值包括FORWARD_ONLY（游标允许向前访问）、SCROLL_SENSITIVE（双向滚动，但不及时更新，就是如果数据库里的数据修改过，并不再resultSet中反映出来）、SCROLL_INSENSITIVE（双向滚动，并及时跟踪数据库的更新，以便更改resultSet中的数据） 默认值是数据库厂商提供的JDBC驱动所设置的   databaseId 配置使用 提供多种数据库的支持   resultOrdered 这个设置仅适用于嵌套结果select语句，如果为true，就是假设包含了嵌套结果集或是分组了，当返回一个主结果行是，就不能引用前面结果集了。这就确保了在获取嵌套的结果集时不至于导致内存不够用。 取值为布尔值，true/false。默认值为false   resultSets 适用于多个结果集的情况，它将列出执行SQL后每个结果集的名称，每个名称之间用逗号分隔 很少使用    在实际工作中用得最多的是id、parameterType、resultType、resultMap，如果要设置缓存，还会使用到flushCache、useCache，其他的都是不常用的功能。这里主要讨论id、parameterType、resultType、resultMap及它们的映射规则。</description>
    </item>
    
    <item>
      <title>SSM第四章-MyBatis配置</title>
      <link>https://zereals7.github.io/post/ssm%E7%AC%AC%E5%9B%9B%E7%AB%A0-mybatis%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 19 Apr 2021 01:38:36 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/ssm%E7%AC%AC%E5%9B%9B%E7%AB%A0-mybatis%E9%85%8D%E7%BD%AE/</guid>
      <description>4.1 概述 MyBatis配置文件不复杂
配置文件元素
&amp;lt;configuration&amp;gt;配置&amp;lt;properties/&amp;gt;属性&amp;lt;setting/s&amp;gt;设置&amp;lt;typeAliases/&amp;gt;类型别名&amp;lt;typeHandlers/&amp;gt;类型处理器&amp;lt;objectFactory/&amp;gt;对象工厂&amp;lt;plugins&amp;gt;插件&amp;lt;environments&amp;gt;配置环境&amp;lt;environment&amp;gt;环境变量&amp;lt;transactionManager&amp;gt;事务管理器&amp;lt;dataSource&amp;gt;数据源&amp;lt;/environment&amp;gt;&amp;lt;/environments&amp;gt;&amp;lt;databaseIdProvider/&amp;gt;数据库厂商标识&amp;lt;mappers&amp;gt;映射器&amp;lt;/configuration&amp;gt;需要注意配置的顺序不能颠倒。顺序错了，启动阶段就会发生异常，导致程序无法运行。
4.2 properties属性 properties属性可以给系统配置一些运行参数，可以放在XML文件或者 properties文件中，而不是放在Java编码中，这样的好处在于方便参数修改，不会引起代码重新编译。
可以使用元素 properties下的 propertie子元素定义。比如通过
,可以定义数据库的驱动，然后可以通过${database.driver},定义一次，到处引用。如果属性参数有成百上千个，可以使用properties文件。
使用properties文件是比较普遍的方法，一方面这个文件十分简单，其逻辑就是键值对应，我们可以配置多个键值放在一个properties文件中，也可以把多个键值对放在多个properties文件中，这些都是允许的，它方便日后维护和修改。
在MyBatis中通过properties的属性resource来引入properties文件。
&amp;lt;properties resource=&amp;#34;jdbc.properties&amp;#34;/&amp;gt; 也可以按${database.username}的方法引入properties文件的属性参数到MyBatis配置文件中。这个时候通过维护properties文件就可以维护我们的配置内容了。
在真实的生产环境中，数据库的用户密码是对开发人员和其他人员保密的。运维人员为了保密，一般都需要把用户和密码经过加密成为密文后，配置到properties文件中。对于开发人员及其他人员而言，就不知道其真实的用户密码了，数据库也不可能用以及加密的字符串去连接，此时往往需要通过解密才能得到真实的用户和密码了。现在假设系统已经为提供了这样的一个CodeUtils.decode(str)进行解密，那么我们在创建SqlSessionFactory前，就需要把用户名和密码解密，然后把解密后的字符串重置到properties属性中。
首先使用Resources对象读取了一个jdbc.properties配置文件，然后获取了它原来配置的用户和密码，进行解密并重置，最后使用SqlSessionFactoryBuilder的build方法，传递多个properties参数来完成。这将覆盖之前配置的密文，这样就能连接数据库了，同时也满足了运维人员对数据库用户和密码安全的要求。
总结：以上是MyBatis使用properties的3种方式。这3种方式是有优先级的，最优先的是使用程序传递的方式，其次是使用properties文件的方式，最后使用子元素的方式。MyBatis会根据优先级来覆盖原先配置的属性值。
建议采用properties文件的方式，因为管理它简单易行，而且可以从XML文件中剥离出来独立维护。
4.3 settings设置 settings是MyBatis中最复杂的配置，它能深刻影响MyBatis底层的运行，但大部分情况下使用默认值便可以运行，所以大部分情况下不需要大量配置它，只需要修改一些常用的规则即可，比如自动映射、驼峰命名映射、级联规则、是否启动缓存、执行器类型等。
settings的配置项很多，但是真正用到的不会太多，我们把常用的配置项研究清楚就可以了，比如关于缓存的CacheEnabled,关于级联的LazyloadingEnabled和aggressiveLazyLoading,关于自动映射的autoMappingBehavior和mapUnderscoreToCamelCase,关于执行器类型的defaultExecutorType等。
4.4 typeAliases别名 由于类的全限定名很长，需要大量使用的时候，写那么长的名称不方便。在MyBatis中允许定义一个简写来代表这个类，这就是别名，别名分为系统定义别名和自定义别名。在MyBatis中别名由类TypeAliasRegistry去定义。注意，在MyBatis中别名不区分大小写。
MyBatis也提供了用户自定义别名的规则。我们可以通过TypeAliasRegistry类的registerAlias方法注册，也可以采用配置文件或者扫描方式来自定义它。
使用配置文件定义很简单：
&amp;lt;typeAliases&amp;gt; &amp;lt;typeAliases alias=&amp;#34;role&amp;#34; type=&amp;#34;com.leartn.ssmchapter4.pojo.Role&amp;#34;/&amp;gt; &amp;lt;typeAliases alias=&amp;#34;user&amp;#34; type=&amp;#34;com.learn.ssm.chapter4.pojo.User&amp;#34;/&amp;gt; &amp;lt;/typeAliases&amp;gt; 这样就可以定义一个别名了。如果由很多类需要定义别名，那么用这样的方式进行配置可就不那么轻松了。MyBatis还支持扫描别名。比如上面的两个类都在包com.learn.ssm.chapter4.pojo之下，那么就可以定义为：
&amp;lt;typeAliases&amp;gt; &amp;lt;package name=&amp;#34;com.learn.ssm.chapter4.pojo&amp;#34;/&amp;gt; &amp;lt;typeAliases&amp;gt; 这样MyBatis将扫描这个包里面的类，将其第一个字母变为小写作为其别名，比如类Role的别名会变成role，而User的别名会变成user。使用这样的规则有时候会出现重名，这个时候可以使用MyBatis提供的直接@Alias来进行区分。
这样就能够避免因为别名重名导致的扫描失败的问题。
4.5 typeHandler类型转换器 在JDBC中，需要在PreparedStatement对象中设置那些已经预编译过的SQL语句的参数。执行SQL后，会通过ResultSet对象获取得到数据库的数据，而这些MyBatis是根据数据的类型typeHandler来实现的。在typeHandler中，分为jdbcType和javaType,其中jdbcType用于定义数据库类型，而javaType用于定义Java类型，那么typeHandler的作用就是承担jdbcType和iavaType之间的相互转换。在很多情况下我们并不需要去配置typeHandler、jdbcType、javaType,因为MyBatis会探测应该使用什么类型的typeHandler进行处理，但是有些场景无法探测到。对于那些需要使用自定义枚举的场景，或者数据库使用特殊数据类型的场景，可以使用自定义的typeHandler去处理类型之间的转换问题。
和别名一样，在MyBatis中存在系统定义typeHandler和自定义typeHandler。MyBatis会根据javaType和数据库的jdbcType来决定采用哪个typeHandler处理这些转换规则。系统提供的typeHandler能覆盖大部分场景的要求，但是有些情况下是不够的，比如我们由特殊的转换规则，枚举类就是这样。
总之，typeHandler负责jdbcType和javaType之间的相互转换。
在大部分的情况下无须显式地声明jdbcType和javaType，或者用typeHandler去指定对应的typeHandler来实现数据类型转换，因为MyBatis系统会自己探测。有时候需要修改一些转换规则，比如枚举类往往需要自己去编写规则。
typeHandler继承了BaseTypeHandler
 BaseTypeHandler是个抽象类，需要子类去实现其定义的4个抽象方法，而它本身实现类typeHandler接口的4个方法。 getResult方法，非空结果集是通过getNullableResult方法获取的。如果判断为空，则返回null。 setParameter方法，当参数parameter和jdbcType同时为空时，MyBatis将抛出异常，如果能明确jdbcType,则会进行空设置；如果参数不为空，那么它将采用setNonNullParameter方法设置参数。 getNullableResult方法用于存储过程。  MyBatis使用最多的typeHandler之一——StringTypeHandler。它用于字符串转换。它实现类BaseTypeHandler的4个抽象方法。</description>
    </item>
    
    <item>
      <title>SSM第三章-MyBatis核心组件</title>
      <link>https://zereals7.github.io/post/mybatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Fri, 16 Apr 2021 21:47:55 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/mybatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</guid>
      <description>3.1 持久层的概念和MyBatis的特点 持久层可以将业务数据存储到磁盘，具备长期存储能力，只要磁盘不损坏，在断电或者其他情况下，重新开启系统仍然可以读取这些数据。一般执行持久任务的都是数据库系统，持久层可以使用巨大的磁盘空间，也比较廉价，缺点就是慢，当然慢是针对内存而言的，在一般系统中运行是不存在问题的，比如内部管理系统，但是在互联网的秒杀场景下，每秒需要执行成千上万次数据操作，慢是不能承受的，极有可能导致宕机，在这样的场景下考虑使用Redis处理。
MyBatis最大的成功来自于三点
 不屏蔽SQL，意味着可以更为精确的定位SQL语句，可以对其进行优化和改造，这有利于互联网系统性能的提高，符合互联网需要性能优化的特点。 提供强大、灵活的映射机制，方便Java开发者使用。提供动态SQL的功能，允许我们根据不同条件组装SQL，这个功能远比其他工具或者Java编码的可读性和可维护性高得多，满足各种应用系统的同时也满足了需求经常变化的互联网应用的要求。 在MyBatis中，提供了使用Mapper的接口编程，只要一个接口和一个XML就能创建映射器，进一步简化我们的工作，使得很多框架API在MyBatis中消失，开发者更集中于业务逻辑。  3.2 准备MyBatis环境 网上复制相关依赖
3.3 MyBatis核心组件 MyBatis的核心组件分为4个部分
 SqlSessionFactoryBuilder(构造器)：它会根据配置或者代码来生成SqlSessionFactory,采用的是分布构建的Builder模式。 SqlSessionFactory（工厂接口）：依靠它来生成SqlSession，使用的是工厂模式。 SqlSession(会话)：一个既可以发送SQL执行返回结果，也可以获取Mapper的接口。在现有的技术中，我们会让其在业务逻辑代码中消失，而使用的是MyBatis提供的SQL Mapper接口编程技术，它能提高代码的可读性和可维护性。 SQL Mapper（映射器）：MyBatis新设计的组件存在的组件，它由一个Java接口和XML文件构成，需要给出对应的SQL和映射规则。它负责发送SQL去执行，并返回结果。  无论是映射器还是SqlSession都可以发送SQL到数据库执行。
3.4 SqlSessionFactory（工厂接口） 使用MyBatis首先是使用配置或者代码去生产SqlSessionFactory，而MyBatis提供了构造器SqlSessionFactoryBuilder。它提供了一个类org.apache.ibatis.session.Configuration作为引导，采用的是Builder模式。具体的分步是在Configuration类里面完成的。
在MyBatis中，可以通过读取皮质的XML文件的形式生成SqlSessionFactory，也可以通过Java代码的形式取生产SqlSessionFactory。推荐使用XML的形式，因为代码的方式在需要修改的时候会比较麻烦。当配置了XML或者提供代码后，MyBatis会读取配置文件，通过Configuration类对象构建整个MyBatis的上下文。SqlSessionFactory是一个接口，在MyBatis中存在两个实现类：SqlSessionManager和DefaultSqlSessionFactory,一般而言，具体是由DefaultSqlSessionFactory去实现的，而SqlSessionManager使用在多线程的环境中，它的具体实现依靠DefaultSqlSessionFactory。
每个基于MyBatis的应用都是以一个SqlSessionFacrory的实例为中心的，而SqlSessionFactory唯一的作用就是生产MyBatis的核心接口对象SqlSession,所以它的责任是唯一的。我们往往采用单例模式处理它，使用配置文件和Java代码两种形式去生成SqlSessionFactory的方法。
3.4.1 使用XML构建SqlSessionFactory 首先，在MyBatis中的XML分为两类，一类是基础配置文件，通常只有一个，主要是配置一些最基本的上下文参数和运行环境；另一类是映射文件，它可以配置映射关系，SQL、参数等信息。
基础配置文件：
元素定义了别名，可以代替全限定名。
元素的定义，这里描述的是数据库。它里面的元素是配置事务管理器，这里采用的是MyBatis的JDBC管理器方式。然后采用元素配置数据库，其中属性 type=“POOLED”代表采用MyBatis内部提供的连接池方式。
元素代表引入的那些映射器。
通过XML构建SqlSessionFactory
SqlSessionFactory SqlSessionFactory=null； String resource =&amp;#34;mybatis-config.xml&amp;#34;; InputStream inputStream; try{ inputStream =Resources.getResourceAsStream(resource); SqlSessionFactory= new SqlSessionFactoryBuilder().build(inputStream); }catch(IOException e){ e.printStarkTrace(); } 首先读取mybatis-config.xml,然后通过SqlSessionFactoryBuilder的Builder方法去创建SqlSessionFactory。整个过程比较简单，而里面的步骤还是比较烦琐的，只是MyBatis采用了Builder模式为开发者隐藏了这些细节。这样一个SqlSessionFactory就被创建出来了。
推荐采用XML创建的形式，信息在配置文件中，有利于我们日后的维护和修改，避免了重新编译代码。
3.4.2 使用代码创建SqlSessionFactory 代码冗长，如果发生系统修改，那么有可能需要重新编译代码才能继续，所以不是一个很好的方式。除非有特殊的需要，比如在配置文件中，需要配置加密过的数据库用户名和密码，需要我们在生产SqlSessionFactory前解密为明文的时候，才会考虑使用这样的方式。
3.5 SqlSession 在MyBatis中，SqlSession是其核心接口。在MyBatis中有两个实现类，DefaultSqlSession和SqlSessionManager。DefaultSqlSession是单线程使用的，而SqlSessionManager在多线程环境下使用。SqlSession的作用类似于一个JDBC中的Connection对象，代表着一个连接资源的启用。具体而言，有三个作用。
 获取Mapper接口 发送SQL给数据库 控制数据库事务  创建SqlSession
SqlSession sqlSession =SqlSessionFactory.</description>
    </item>
    
    <item>
      <title>SSM第二章-Java设计模式</title>
      <link>https://zereals7.github.io/post/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 15 Apr 2021 00:24:01 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>2.1 Java反射技术 Java反射技术应用广泛，它能够配置：类的全限定名、方法和参数，完成对象的初始化，甚至是反射某些方法。这样就可以大大增强Java的可配置性，Spring IOC的基本原理他也是如此，当然Spring IOC的代码要复杂得多。
2.1.1 通过反射构建对象 在Java中允许通过反射配置信息构建对象。
这里的代码就是生成一个对象，然后将其返回。下面这行代码的目的就是给类加载器注册了一个类对象，使用反射的方式也十分简单。
object=(ReflectServiceImpl)Class.forName(&amp;quot;com.learn.ssm.chapter2.reflect.ReflectServiceImpl&amp;quot;).newInstance();
这是一个构建方法，没有任何参数的类的反射生成，所以还剩下一个问题，即如果一个类的所有构建方法都至少存在一个参数，如何用反射构建它。其实，只要少排位改变就可以。
使用如下代码发生你和生成对象：
`object=(ReflectServiceImpl2)Class.forName(&amp;#34;com.learn.ssm.chapter2.reflect.ReflectServiceImpl2&amp;#34;).getConstructor(String.class).newInstance(&amp;#34;张三&amp;#34;)；` 先通过forName加载到类的加载器。然后通过getConstructor方法，它的参数可以是多个，这里定义为String.class，意为有且只有一个参数类型为String的方法。通过这个方法可以对重名方法进行排除，此时再用newInstance方法生成对象，只是newInstance方法也多了一个参数“张三&amp;quot;而已。实际就等于object=new ReflectServiceImpl2(&amp;ldquo;张三&amp;rdquo;)，只是这里用反射机制来生成这个对象而已。
反射的优点是只要配置就可以生成对象，可以接触程序的耦合度，比较灵活。反射的缺点是运行比较慢。但是大部分情况下为了灵活度，降低程序的耦合度，我们还是会使用反射的，比如Spring IOC容器。
2.1.2 反射方法 在使用反射方法前要获取方法对象，得到了方法才能去反射。
当有具体的对象target，而不知道具体是哪个类时，也可以使用getClass方法找到全限定类名
target.getClass().getMethod(&amp;#34;sayHello&amp;#34;,String.class); 代替它，其中第一个参数是方法名称，第二个参数是参数类型，是一个列表，多个参数可以继续编写多个类型，这样便能获得反射的方法对象。
反射方法是运用
returnObj=method.invoke(target,&amp;#34;张三&amp;#34;)； 代码完成的。
第一个参数为target，就是确定用哪个对象调用方法，而”张三“是参数，这行就等于target.sayhello(&amp;ldquo;张三&amp;rdquo;)；。
如果存在多个参数，可以写成Method.invoke(target，obj1,obj2,obj3&amp;hellip;..),这些要根据对象的具体方法来确定。
对象在反射机制生成后，反射了方法，我们完全可以通过配置完成对象和方法的反射，大大增强了Java的可配置性和可扩展性，其中Spring IOC就是一个典型的样例。
2.2 动态代理模式和责任链模式 动态代理的意义在于生成一个代理对象（占位），来代理真实对象，从而控制真实对象的访问。
代理模式举例：假设你的公司是一家软件公司，你是一位软件工程师。客户带着需求找公司不不会直接和你谈，而是找商务谈，此时客户会认为商务就代表公司。
显然客户是通过商务区访问软件工程师的，那么商务(代理对象)的意义是什么呢？商务可以进行谈判，比如项目启动前的商务谈判，软件的价格、交付、进度的事件节点等，或者项目完成后的商务追讨应收账款等。商务也有可能在开发软件之前谈判失败，此时商务就会根据公司规则去结束和客户的合作关系，这些都不用软件工程师来处理。因此，代理的作用就是，在真实对象访问之前或之后加入对应的逻辑，或者根据其他规则控制是否使用真实对象，显然这个例子里商务控制了客户对软件工程师的访问。
商务和软件工程师是代理和被代理的关系，客户是经过商务去访问软件工程师的。此时客户就是程序中的调用者，商务就是代理对象，软件工程师就是真实对象。我们需要在调用者调用对象之前产生一个代理对象，而这个代理对象需要和真实对象建立代理关系，所以代理必须分为两个步骤：
 代理对象和真实对象建立代理关系 实现代理对象的代理逻辑方法  在Java中有多种动态代理技术，比如JDK、CGLIB、Javassist、ASM，其中最常用的动态代理技术有两种：一种是JDK动态代理，这是JDK自带的功能；另一种是CGLIB,这是第三方提供的一个技术。目前，SPring 常用JDK和CGLIB，而MyBatis还使用了Javassist，无论使用哪种代理其技术，理念相似。
在JDK动态代理中，我们必须使用接口，而CGLIB不需要，所以使用CGLIB会更简单一些。
AOP的实现方式：动态代理。与静态代理对比，动态代理是在runtime动态生成Java代理类，由代理类完成对具体方法的封装，实现AOP的功能。
2.2.1 JDK动态代理 JDK动态代理是java.lang.reflect.*包提供的方式，它必须借助一个接口才能产生代理对象，所以先定义接口。
然后提供实现类来实现接口。有了接口和实现类，此时可以开始动态代理了。按照我们之前的分析，先要建立起代理对象和真实服务对象的关系，然后实现代理逻辑，所以一共 分为两个步骤。
在JDK动态代理中，要实现代理逻辑类必须去实现java.lang.reflect.InvocationHandler接口，它里面定义了一个invoke方法,并提供接口数组用于下挂代理对象。
***第一步，建立代理对象和真实对象的关系。***这里是使用了bind方法去完成的，方法里面首先用类的属性target保存了真实对象，然后 通过如下代码建立并生成代理对象。
其中newProxyInstance方法包含3个参数
第一个是类加载器，我们采用了target本身的类加载器。
第二个是把生成的动态代理对象下挂在哪些接口下，这个写法就是放在target实现的接口下。
第三个是定义实现方法逻辑的代理类，this表示当前对象，它必须实现InvocationHandler接口的invoke方法，它就是代理逻辑方法的现实方法。
​
***第二步，实现代理逻辑方法。***invoke方法可以实现代理逻辑，invoke方法的三个参数如下：
 Proxy,代理对象，就是bind方法生成的对象。 method，当前调度的方法。 args，调度方法的参数。  当我们使用了代理对象调度方法后，它就会进入到invoke方法里面。
Object obj =method.invoke(target,args); 这行代码相当于调度真实对象的方法，只是通过反射实现而已。
类比之前的例子，proxy相当于商务对象，target相当于软件工程师对象，bind方法是建立商务和软件工程师代理关系的方法。而invoke就是商务逻辑，它将控制软件工程师的访问。
测试JDK动态代理</description>
    </item>
    
    <item>
      <title>SSM第一章-入门和Redis</title>
      <link>https://zereals7.github.io/post/ssm/</link>
      <pubDate>Wed, 14 Apr 2021 21:56:15 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/ssm/</guid>
      <description>1.1 Spring框架 1.1.1 Spring IOC简介 IOC是一个容器，在Spring中，它会认为一切Java资源都是Java Bean,容器的目标就是管理这些Bean和它们之间的关系。
各个Java Bean之间会存在一定的依赖关系，容器能够对其进行管理。SPringIOC管理对象和依赖关系，采用的不是认为主动创建，而是SPring IOC自己通过描述创建的。
当需要某个实现类，可以通过配置实现依赖的注入 。这是一种被动的行为，控制权在IOC容器，它会根据描述找到使用者需要的资源。
当需要使用某个实现类时，通过配置信息就可以完成了。不需要用new来创建对象，依赖关系也可以通过配置完成，从而即插即拔地管理它们之间的关系。
总结：你不需要去找资源，只要向SPring IOC容器描述所需资源，SPring IOC自己会找到你需要的资源，这就是SPring IOC的理念。这样就把Bean之间的依赖关系解耦了，更容易写出结构清晰的程序。除此之外，SPring IOC还提供对Java Bean生命周期的管理，可以延迟加载，可以在其生命周期内定义一些行为等，更加方便有效地使用和管理Java资源，这就是SPring IOC的魅力。
1.1.2 SPring AOP IOC的目标时为了管理Java Bean,而Bean是Java面向对象的基础设计。但是，有些情况面向对象没办法处理。举个例子，生产部门的订单、生产部门、财务部门三者符合OOP的设计理念。订单发出，生产部门审批通过准备付款，但是财务部门发现订单的价格超支了，需要取消当你孤单。显然超支限定已经不只是影响财务部门了，还会影响生产部门之前所做的审批，需要把它们作废。我们把预算超支这个条件称为切面，它影响了订单、生产部门、财务部门三个OOP对象。在现实中，这样的切面条件跨越了3个甚至更多的对象，并且影响了它们的协作。所以只用OOP并不完善，还需要面向切面的编程，通过它去管理在切面上的某些对象的协作。
Spring AOP常用于数据库事务的编程，在默认的情况下，只要Spring接收到了异常信息，它会将数据库的事务回滚，从而保证数据的一致性。Spring提供了隔离级别和传播行为去控制复杂的事务。
1.2 MyBatis简介 MyBatis优势在于灵活，他几乎可以代替JDBC，同时提供了接口编程。目前MyBatis的数据访问层DAO是不需要实现类的，只需要一个接口和XML，或是注解。MyBatis提供自动映射，动态SQL、级联、缓存、注解、代码和SQL分离等特性。同时也可以对SQL进行优化。一位内具有封装少、映射多样化、支持存储过程、可以进行SQL优化等特点。
1.2.1 Hibernate简介 在MyBatis或者HIberNate中使用注解或者XML都是可以的。MyBatis中注解方式会受到一定的限制，所以MyBatis通常用XML方式实现映射关系。
我们把POJO对象和数据表相互映射的框架称为对象关系映射ORM。MyBatis和HIbernate都是ORM框架，只是Hibernate完全面向POJO，而前者不是。Hibernate基本不需要编写SQL就可以通过映射关系来操作数据库，是一种全表映射，而MyBatis不同，需要提供SQL去运行。
没有SQL是因为Hibernate会根据映射关系来生成对应的SQL。
1.2.2 Mybatis 在移动互联网时代，Mybatis是互联网Java持久框架的首选，与HIbernate消除SQL不同，MyBatis不屏蔽SQL。不屏蔽SQL的优势在于，程序员可以自己制定SQL规则，无须HIbernate自动生成规则，这样能够更加精确地定义SQL，从而优化性能。它更符合移动互联网、大数据、高并发、高性能、高响应的要求。
与HIbernate一样，MyBatis需要一个映射文件把POJO和数据库的表对应起来。
resultMap元素用于定义映射规则，Mybatis在满足一定规则下，完成自动映射。
mapper元素中的namespace属性，要和一个接口的全限定类名保持一致。里面的SQL的id也要和接口定义的方法保持完全一致。
定义了MyBatis的映射文件，就不再需要定义一个实现类。
Mybatis需要提供接口和SQL，意味着它的工作量会比HIbernate大，但是由于自定义SQL、映射关系，所以其灵活性、可优化性就超过了HIbernate。
1.2.3 HIbernate和MyBatis的区别 两者的增删查改对于业务逻辑层来说大同小异，对于映射层而言HIbernate的配置不需要接口和SQL，相反MyBatis是需要的。对于HIbernate而言，不需要编写大量的SQL就可以完全映射，同时提供了日志、缓存、级联等特性（级联比Mybatis强大）等特性，此外还提供了HQL对POJO操作，使用十分方便，但也有致命的缺陷。
由于无须SQL，当多表关联超过3个的时候，通过HIbernate的级联会造成太多的性能丢失，又或者我现在访问财务的表，然后它会关联财产信息表，财产又分为机械、原料等，显然机械和原料的字段不一样，这样关联的字段只能根据特定的条件变化而变化，而HIbernate无法支持这样的变化。遇到存储过程HIbernate只能作罢。
Mybatis可以自由书写SQL、支持动态SQL、处理列表、动态生成表名、支持存储过程。这样可以灵活定义查询语句，满足各类需求和性能优化的需要，这些在互联网系统中十分重要.
Mybatis也有缺陷。首先，要编写SQL和映射规则，其工作量稍微大于HIbernate。其次，支持的工具有限，不能像HIbernate那样有许多的插件可以帮助生成映射代码和关联关系，而即使使用生成工具，往往也需要开发者进一步简化，Mybatis通过手工编码，工作量相对大些。
所以对于性能要求不太苛刻的系统，比如管理系统、ERP等推荐HIbernate；而对于性能要求高、响应快、灵活的系统则推荐使用Mybatis。
1.3 Spring MVC简介 SPring MVC结构层次清晰，类比较简单，并且与SPring的核心IOC和AOP无缝对接。
MVC模式把应用程序分成不同的方面，同时提供这些元素的松耦合。
Model，封装了应用程序的数据和由它们组成的POJO
View，负责把模型数据渲染到视图上，将数据以一定的形式展现给用户。
Controller，负责处理用户请求，并建立适当的模型把它传递给试图渲染。
在SpringMVC中可以定义逻辑视图，通过其提供的试图解析器能够很方便地找到对应的视图进行渲染，或者使用其消息转换的功能，比如在Controller的方法内加入注解@ResponseBody后，SPring MVC就可以通过其消息转换系统，将数据转换为JSON，提供给前端Ajax请求使用。
SpriingMVC包括控制器、视图解析器、视图等重要内容。
1.4 最流行的NoSQL-Redis Redis是当前互联网最为流行的NoSQL。NoSQL在互联网系统中的作用很大，因为它可以在很大程度上提高互联网系统的性能。它具备一定持久层的功能，也可以作为一种缓存工具。对于NOSQL数据库而言，作为持久层，它存储的是半结构化的，这意味着计算机在读入内存中有更少的规则，读入速度更快。对于那些结构化、多范式规则的数据库系统而言，它更具性能优势。作为缓存，它可以支持大数据存入内存中，只要命中率高，就能快速响应，因为在内存中的数据读写比数据库读写磁盘的速度快几十上百倍。
Redis具有以下特点：
1、响应快速：Redis响应非常快，每秒课执行大约110000个写入操作，或者81000个读操作，其速度远超数据库。如果存入一些常用的数据，就能有效提高系统的性能。
2、支持6种数据结构：包括字符串、哈希结构、列表、集合、可排序集合和基数。比如对于字符串可以存入一些Java基础数据类型，哈希可以存储对象，列表可以存储List对象等。这使得在应用中很容易根据在自己的需要选择存储的数据类型，方便开发。既可以满足存储各种数据结构体的需要，又因为数据类型少，使得规则就少，需要的判断和裸机就少，这样读写速度就更快。
3、操作都是原子的：所有Redis的操作都是原子的，从而确保当两个客户同时访问Redis服务器时，得到的是更新后的值。在需要高并发的场合可以考虑使用Redis的事务，处理一些需要锁的事务。
4、MultiUtility工具：Redis可以在如缓存、消息传递队列中使用（支持“发布+订阅”的消息模式），在应用程序如Web应用程序会话、网站页面点击数等任何短暂的数据中使用。</description>
    </item>
    
    <item>
      <title>操作系统-进程与线程</title>
      <link>https://zereals7.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Sat, 10 Apr 2021 12:05:23 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</guid>
      <description>计算机上所有可运行的软件，通常也包括操作系统，被组织成若干顺序进程，简称进程。一个进程就是一个正在执行程序的实例，包括程序计数器，寄存器和变量的当前值。
从概念上来说，每个进程有自己的虚拟CPU。实际上真正的CPU在各进程间来回切换。
1、进程的创建 操作系统需要有一种方式来创建进程。
4种主要事件导致进程的创建：1、系统初始化 2、正在运行的程序执行了创建进程的系统调用 3、用户请求创建一个新进程 4、一个批处理作业的初始化
启动操作系统时，有些是前台进程，也就是与用户交互并且替他们完成工作的那些进程。其他的是后台进程，这些进程与特定的用户没有关系，却具有某些专门的功能。在大型系统中通常有很多守护进程，他们停留在后台，在请求到达时被唤醒。
从技术上看，新进程都是由于一个已存在的进程执行了一个用于创建进程的系统调用而创建的。这个进程可以是一个运行的用户进程、一个由键盘或鼠标启动的系统或者一个批处理管理进程。这个进程所做的工作是，执行一个用来创建新进程的系统调用。这个系统调用通知操作系统创建一个新进程，并且直接或间接地指定该进程中运行的程序。
UNIX系统中，只有一个系统调用可以用来创建新进程：fork。这个系统调用会创建一个与调用进程相同的副本。在调用了fork后，父进程和子进程拥有相同的内存映像、同样的环境字符串和同样的打开文件。
子进程接着执行execve或一个类似的系统调用，以修改其内存映像并运行一个新的程序。
当一个用户在shell中键入命令sort时，shell就创建一个子进程，然后，这个子进程执行sort。之所以要安排两步建立进程，是为了在fork之后但在execve之前允许该进程处理其文件描述符，这样可以完成对标准输入文件、标准输出文件和标准错误文件的重定向。
进程创建后，父进程和子进程有各自不同的地址空间。如果其中某个进程在其他地址空间修改了一个字，这个修改对其他进程而言是不可见的。在UNIX中。子进程的初始地址空间是父进程的一个副本，但是涉及两个不同的地址空间，不可写的内存区是共享的。某些UNIX的实现使程序正文在两者间共享，因为它不能被修改。或者，子进程共享父进程的所有内存，单这种情况下内存通过写时复制共享，这意味着一旦两者之一想要修改部分内存，则这块内存首先被明确的复制，以确保修改发生在私有内存区域。再次强调，可写的内存时不可以共享的。但是，对于一个新创建的进程而言，确实有可能共享其创建者的其他资源，诸如打开的文件等。在windows中，从一开始父进程的地址空间和子进程的地址空间就是不同的。
2、进程的终止 进程在创建之后，它开始运行，完成其工作。但永恒是不存在的，进程也一样。迟早这个新的进程会终止，通常由下列条件引起。
1、正常退出 2、出错退出 3、严重错误 4、被其他进程杀死
多数进程是由于完成了他们的工作而终止。
3、进程的层次结构 某些系统中，当进程创建了另一个进程后，父进程和子进程就以谋者形式继续保持关联。子进程自身可以创建更多的进程，组成一个进程的层次结构。进程只有一个父进程，但是可以有多个子进程。
在UNIX中，进程和它所有子进程以及后裔共同组成一个进程组。当用户从键盘发出一个信号时，该信号被送给当前与键盘相关进程组的所有成员。每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被该信号杀死。
一个称为init的特殊进程出现在启动映像中。当它开始运行时，读入一个说明终端数量的文件。接着，为每个终端创建一个新进程。这些进程等待用户登录。如果有一个用户登录成功，该登录进程就执行一个shell准备接收命令。所接受的这些命令会启动更多的进程，一次类推。这样在整个系统中，所有进程都属于以init为根的一棵树。
windows中没有进程层次的概念，所有进程都是地位相同的。唯一类似于进程层次的暗示是在创建进程的时候，父进程得到一个特别的令牌（称为句柄），该句柄可以用来控制子进程。但是它有权把这个令牌传送给某个其他进程，这样就不存在进程层次了。在UNIX中，进程不能剥夺其子线程的继承权。
4、进程的状态 每个进程是一个独立的实体，有自己的程序计数器和内部状态，但是，进程之间经常需要相互作用。一个进程的输出结果可能作为另一个进程的输入。进程有三种状态：1.运行态。该时刻进程实际占用CPU，啥都不缺。2.就绪态，可运行，但因为其他进程正在运行而暂时停止，缺CPU。3、阻塞态，除非某种外部事件发生，否则进程不能运行，缺资源，缺CPU。
前两中状态进程都可以运行，只是第二种状态暂时没有CPU分配给它。第三种状态与前两种状态不同，处于该状态的进程不能运行，即使CPU空闲也不行。
在操作系统发现进程不能运行下去时发生转换1.在某些系统，进程可以执行一个诸如pause的系统调用来进入阻塞状态。在其他系统，包括UNIX中，当一个进程从管道设备文件读取数据时，如果没有有效的输入存在，则进程会被自动阻塞。
转换2和3时由进程调度程序引起的，进程调度程序是操作系统的一部分，进程甚至感觉不到调度程序的存在。
当进程等待的一个外部事件发生时（如一些输入到达），则发生转换4.如果此时没有其他进程运行，则立即触发3转换3，该进程便开始运行。否则该进程将处于就绪态，等待CPU空闲并且轮到它运行。
操作系统的最底层是调度程序，在它上面有许多进程。所有关于中断处理、启动进程和停止进程的具体细节都隐藏在调度程序中。实际上，调度程序是一段非常短小的程序。操作系统的其他部分被简单地组织成进程的形式。不过，很少有真实的系统是以这样的理想方式构造的。
5、进程的实现 为了实现进程模型，操作系统维护者一张进程表（一个结构数组）。每个进程占用一个进程表项（进程控制块）。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开的文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。
![2021-04-1025 (Copy)](C:/Users/Zereal/Desktop/2021-04-1025 (Copy).jpg)
在了解进程表后，就可以对在单个CPU上如何维持多个顺序进程的错觉做更多的阐述。与每一IO类关联的是一个称作中断向量的位置（靠近内存底部的固定区域）。它包含中断服务程序的入口地址。
假设当一个磁盘中断发生时，用户进程3正在运行，则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈，计算机随后跳转到中断向量所指示的地址。这些是硬件完成的所有操作，然后软件，特别是中断服务例程就接管一切剩余的工作。
所有的中断都从保存寄存器开始，对于当前进程而言，通常是保存在进程表项中。
随后会从堆栈中删除由中断硬件机制存入堆栈的那部分信息，并将堆栈指针指向一个由进程处理程序所使用的临时堆栈。
一个进程在执行过程中可能被中断数千次，但关键是每次中断后，被中断的进程都返回到与中断发生前完全相同的状态。</description>
    </item>
    
    <item>
      <title>操作系统——引论</title>
      <link>https://zereals7.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Fri, 02 Apr 2021 18:22:48 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
      <description>完全基于《现代操作系统》第四版，摘取精华，掺杂个人理解。适用于自学党，和想要系统学习操作系统的人。
一、引论 1.为什么要有操作系统？操作系统的任务是什么？ 需求：现代计算机系统的组成极为复杂（处理器，主存，磁盘，输入输出设备&amp;hellip;）,应用程序员没有精力去掌握系统的所有细节。而且，管理这些部件并加以使用，是一件挑战性极强的工作。
所以计算机需要安装一层软件——操作系统。来满足这些需求。（注意：操作系统是系统软件，非应用软件）
任务：为用户程序提供一个更好、更简单、更清晰的计算机模型（操作系统）来实现对计算机所有设备的管理。
一言以蔽之，就是封装硬件运行和管理的细节，服务于上层的应用程序。
抽象是管理复杂性的一个关键，操作系统的任务就是创建好的抽象，并实现和管理它所创建的抽象对象。隐藏硬件，呈现给程序以及程序员良好/清晰/优雅/一致的抽象。
2.用户与操作系统交互的方式——用户接口程序 1.基于文本的——shell（命令行）
2.基于图标的——GUI（图形用户接口）
它们都属于用户接口程序，处于用户态程序中的最低层次。用户可以通过它们运行其他程序，如Web浏览器/音乐播放器等，这些程序也在大量使用操作系统。
3.操作系统内核态和用户态的区别 软件的最基础部分——操作系统，运行在内核态（也称管态，核心态）。核心态下，操作系统具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令。（为所欲为）
所以是有危险性的。
所以在用户态下，只使用了一部分机器指令，尤其是那些影响机器控制以及和IO操作有关系的指令，在用户态中的程序是禁止的。
4.操作系统所处的位置 由底层向上：硬件（裸机）——操作系统（软件，运行在内核态）——用户接口程序（软件，属于用户态最底层，靠近操作系统）——应用程序（软件，用户态）
总之，操作系统运行在裸机（纯硬件）之上，为其他所有软件提供基础的运行环境。
与普通软件的区别：操作系统软件不能被修改，受硬件保护，防止用户试图对其进行修改。
然而，在嵌入式系统（没有内核态）或解释系统（如基于Java的操作系统，它采用解释方式而非硬件方式区分组件）中，上述区别是模糊的。
操作系统一般比用户程序大型，复杂和长寿。（Linux和Windows内核源码都超过了500万行）
5.操作系统的实际用户——应用程序 应用程序直接与操作系统及其抽象打交道，而用户与用户接口所提供的抽象打交道（命令行shell或GUI）。虽然用户接口不同，但是操作系统下面的抽象是相同的。
6.操作系统是资源管理者——把潜在的混乱有序化 资源管理多路复用资源：在时间（CPU时间片）和空间（分割内存）上复用。
操作系统会分配CPU和内存，并协调管理使其有序，以提高运行的效率。
7.操作系统的历史 第一代：真空管和穿孔卡片 ——第二代：晶体管和批处理系统——第三代：集成电路和多道程序设计——第四代：个人计算机——第五代：移动计算机
8.处理器基础知识 CPU是计算机的大脑，它从内存中取出指令并且执行之。
三大流程：取指（从内存中）/解码（确定其类型和操作数）/执行
每个CPU都有特有的指令集，所以x86不能执行ARM程序，反之亦然。而且访存取指的时间比执行指令花费的时间长得多。因此。所有CPU的内部都有一些用来保存关键变量和临时数据的寄存器。
8.1 CPU中的寄存器介绍 除了用来保存变量和临时结果的通用寄存器外，还有一些程序员可见的专用寄存器。其中之一是程序计数器，它保存了将要取出的下一条指令的内存地址。
在取完指令后，程序计数器被更新以指向后继的指令。
另一个寄存器是堆栈指针，它指向内存中当前栈的顶端。该栈包含了每个执行过程的栈帧。一个过程的栈帧中保存了有关的输入参数、局部变量以及那些没有保存在寄存器中的临时变量。
当然还有程序状态字(PSW)寄存器。这个寄存器包含了条件码位、CPU优先级、模式（用户态或内核态），以及各种其他控制位。用户程序通常读入整个PSW，但是只对其中少量字段写入。在系统调用和I/O中，PSW的作用很重要。
操作系统必须知晓所有的寄存器。在时间多路复用CPU中，操作系统经常会中止正在运行的某个程序并再启动另一个程序，每次停止一个正在运行着的程序时，操作系统必须保存所有的寄存器值。这样在稍后该程序被再次运行时，可以把这些寄存器重新装入。
为了改善性能，现代CPU有同时取出多条指令的机制。例如，一个CPU可以有单独的取指单元、解码单元和执行单元，于是当它执行指令N时，可以对指令N+1进行解码，并且可以在内存读取指令N+2。这样的机制称为流水线。
一旦一条指令被取进流水线中，它就必须被执行完毕，即便前一条取出的指令是条件转移，它也必须被执行完毕。
还有更先进的**超标量CPU，有多个取指，解码，执行单元。**只要有一个执行单元空闲，就检查保持缓冲区中是否还有可处理的指令，如果有就把指令从缓冲区中移出并执行之。这种设计程序的指令经常不按顺序执行。多数情况下，硬件负责保证这种运算的结果与顺序执行指令时的结果相同，但是，仍然有部分令人烦恼的复杂情形被强加给操作系统处理（暂不讨论）。
在PSW中有一个二进制位控制CPU的内核态和用户态两种模式。内核态中运行的CPU可以执行指令集中的每一条指令，并且使用硬件的每种功能。值得一提的是，在台式机和服务器中，操作系统在内核态下运行，而在大多数嵌入式系统中，一部分操作系统运行在内核态，其余部分则运行在用户态。
相反**，用户程序在用户态下运行，仅允许执行指令集的一个子集和访问所有功能的一个子集**。一般而言，在用户态中有关IO和内存保护的所有指令是禁止的。当然，将PSW中的模式位设置成内核态也是禁止的。
为了从操作系统中获得服务，用户程序必须使用系统调用以陷入内核并调用操作系统。
只有TRAP指令能把用户态切换成内核态，并启用操作系统。在有关工作完成后，系统调用后面的指令把控制权返还给用户程序。
8.2 多线程和多核芯片 多线程允许CPU保持两个不同的线程状态，然后在纳秒级的时间尺度内来回切换。多线程不提供真正的并行处理。在同一时刻只有一个进程在运行，但是线程的切换时间则减少到纳秒数量级。
**GPU擅长处理大量并行的简单计算，比如在图像应用中渲染多边形。它们不太能胜任串行任务，并且很难编程。**虽然GPU对操作系统很有用（比如加密或者处理网络传输） ，但操作系统本身不太可能运行在GPU上。
8.3存储器 速度由快到慢：寄存器——高速缓存（Cache）——主存（RAM）——磁盘。每位成本也是由高到低。
缓存有利于改善性能。RAM具有电易失性，ROM则非易失。此外ROM速度快且便宜，用于启动计算机的引导加载模块就存放在ROM中。另外，一些I/O卡也采用ROM处理底层设备控制。
EEPROM和闪存也是非易失性的，与ROM相反，他们可以擦除和重写。不过重写比写入RAM要更高数量级的时间。
闪存速度介于RAM和磁盘之间。另外，与磁盘存储器不同，如果闪存擦除的次数过多，就被磨损了。
还有一类存储器是CMOS，它是易失性的。许多计算机利用CMOS存储器保持当前时间和日期。CMOS存储器和递增时间的时钟电路由一块小电池驱动，即使计算机没有上电，时间也可以正确的更新。CMOS存储器还可以保持配置参数。如哪一个是启动磁盘等。之所以采用CMOS是因为它电能消耗非常少，一块原装电池往往能使用数年。CMOS电池没电后，计算机将会不知道由哪个磁盘启动。
磁盘同RAM相比，每个二进制位的成本低了两个数量级。而且通常容量也大几个数量级。唯一的问题是访问数据时间大约慢了三个数量级。低速的原因是因为磁盘是一种机械装置。
磁盘有一个或多个金属盘片，以较高的速度旋转。信息写在磁盘一系列同心圆上。在任意一个给定臂的位置，每个磁头可以读取一段环形区域，称为磁道。把一个给定臂位置上的所有磁道合并起来，组成了一个柱面。
每个磁道划分为若干扇区，典型大小为512字节。现代磁盘中，较外的柱面拥有更多的扇区。机械臂从一个柱面移动到相邻的柱面大概需要1ms。而随机移到一个柱面的典型时间为5-10ms，具体时间取决于驱动器的转速。一旦所需要的扇区移到磁头之下，就开始读写。
固态硬盘没有可以移动的机械臂，是属于闪存，和磁盘同样具有非易失性。
虚拟内存机制：将程序放在磁盘上，将主存作为缓存，用来保存最频繁使用的部分程序。这种机制需要快速的映像内存地址，以便把程序生成的地址转换成为有关字节在RAM中的物理地址。这种映像由CPU中一个叫内存管理单元（MMU）的部件来完成。
缓存和MMU的出现对系统的性能有着重要的影响。在多道程序系统中，从一个程序切换到另一个程序，称为上下文切换。有必要对来自缓存的修改过的块进行写回磁盘的操作。并修改MMU中的映像寄存器。而上下文切换的代价很高，程序员应该努力避免这些操作。
8.4 I/O设备 I/O设备一般包括两个部分，设备控制器和设备本身。
控制器是插在电路板上的一块芯片和一组芯片，这块电路板物理地控制设备，从操作系统接受命令。控制器中一般存在一个小的嵌入式计算机。控制器的任务是为操作系统提供接口。
设备本身也有一个接口，但是功能比较简单。设备本身有个相对简单的接口，接口既不能做很多工作，又已经被标准化。实际的接口隐藏在控制器中。操作系统看到的是对控制器的接口，这个接口可能和设备接口有很大的差别。</description>
    </item>
    
  </channel>
</rss>