<!doctype html>
<html lang="en-us">
  <head>
    <title>Java核心技术第四章笔记-对象和类 // Zereal-宋致远技术博客</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.72.0" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75，minimum-scale=0.75, maximum-scale=0.75, user-scalable=no" />
    <meta name="author" content="Zereal" />
    <meta name="description" content="" />
    <meta name="referrer" content="never"/>
    <link rel="stylesheet" href="https://zereals7.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java核心技术第四章笔记-对象和类"/>
<meta name="twitter:description" content="面向对象
Java是完全面向对象的。面向对象的抽象是由对象组成的。
每个对象包含对用户公开的特定功能部分和隐藏的实现部分。程序中的很多对象来自标准库，还有一些是自定义的。
从根本上说，只要对象满足要求，就不必关心其功能的具体实现过程。在OOP中，不必关心对象的具体实现，只要满足用户的需求即可。
对于一些规模较小的问题，将其分解为过程开发比较理想。而面向对象更加适用于解决规模较大的问题。要想实现一个WEB浏览器大约需要2000个过程。这些过程可能需要对一些全局数据进行操作。采用面向对象的设计风格，可能大约100个类，每个类平均包含20个方法。后者更易于程序员掌握，也容易找到bug。假设给定对象的数据出错了，访问过这个数据项的20个方法中查找错误要比在2000个过程中查找容易得多。
类
类是构造对象的模板和蓝图。我们可以将类想象成制作小甜饼的切割机，将对象想象为小甜饼。由类构造对象的过程为创建类的实例。
用Java编写的所有代码都位于某个类的内部。标准的Java库提供了几千个类，可以用于用户界面设计、日期、日历和网络程序设计。尽管如此，还是需要在Java程序中创建一些自己的类，解决实际问题。
封装是与对象有关的一个重要概念。从形式上看，封装不过是将数据和行为组合在以恶个包中，并对对象的使用这隐藏了数据的实现方式。对象中的数据称为称为实例域，操纵数据的过程称为方法。每个特定的类实例都有一组特定的实例域值。这些值的集合就是这个对象的当前状态。无论合适，只要向对象发送一个消息，它的状态就有可能发生改变。
实现封装的关键在于绝对不能让类中的方法直接访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。封装给对象赋予了黑盒特征，这是提高重用性和可靠性的关键。
这意味着一个类可以全面地改变存储数据的方式，只要仍旧使用同样的方法操作数据，其他对象就不会知道或介意所发生的变化。
对象
要想使用OOP，一定要清楚对象的三个主要特性
 对象的行为——可以对对象施加哪些操作，或可以对对象施加哪些方法？ 对象的状态——当是加急那些方法时，对象如何响应？ 对象标识——如何辨别具有相同行为与状态的不同对象？  每个对象都保存着描述当前特征的信息。这就是对象的状态。对象的状态可能会随着时间而发生改变。但这种改变不会是自发的。对象状态的改变必须通过调用方法实现。如果不经过方法调用就可以改变对象状态，只能说明封装性遭到了破坏。
但是，对象的状态并不能完全描述一个对象。每个对象都有一个唯一的身份。
需要注意，作为一个类的实例，每个对象的标识永远是不同的，状态常常也存在着差异。
对象的这些关键特性在彼此之间相互影响着。例如，对象的状态影响它的行为（如果一个订单“已送货”或已付款，就应该拒绝调用而具有增删订单中条目的方法。反过来，如果订单是“空的”，即还没有加入预定的物品，这个订单就不应该进入已送货状态）
识别类
识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。
类之间的关系
 依赖——如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类 聚合——聚合关系意味着类A的对象包含类B的对象 继承——类A扩展类B，类A不但包含从类B继承的方法，还会有一些额外的功能。  对象与对象变量
要想使用对象，必须首先构造对象，并指定其初始状态。然后、对对象应用方法。
构造器是一种特殊的方法，用来构造并初始化对象。
构造器的名字应该与类名相同。因此Date类的构造器名为Date。
new Date（）
这个表达式构造了一个新对象。这个对象被初始化为当前的日期和时间
如果需要的话，也可以将这个对象传递给一个方法：
System.out.println(new Date()); Date类中有一个toString方法。这个方法将返回日期的字符串描述
String s =new Date().toString();一定要认识到：一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。
在Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个引用。
可以显式地将对象变量设置为null，表明这个对象变量目前没有引用任何对象。
局部变量不会自动地初始化为null，而必须通过调用new或将它们设置为null进行初始化
更改器方法与访问器方法
更改器方法是访问并修改对象的方法，与只访问对象而不修改对象的方法是访问器方法。
关键字public意味着任何类的任何方法都可以调用
关键字private确保只有类自身的方法能够访问
为了保证封装性，建议将实例域标记为private
构造器与类同名。在构造类的对象时，构造器会允许，以便将实例域初始化为所希望的状态。
构造器与其他方法有一个重要的不同。它总是伴随着new操作符的执行被调用。不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。
务必记住！
 构造器与类同名 每个类可以有一个以上的构造器 构造器可以有0个、1个或多个参数 构造器没有返回值 构造器总是伴随着new操作一起调用  注意，不要再构造器中定义与实例域重名的局部变量。如
public Employee(String n,double s,...){String name = n;// Errordouble salary =s;//Error}隐式参数与显式参数"/>

    <meta property="og:title" content="Java核心技术第四章笔记-对象和类" />
<meta property="og:description" content="面向对象
Java是完全面向对象的。面向对象的抽象是由对象组成的。
每个对象包含对用户公开的特定功能部分和隐藏的实现部分。程序中的很多对象来自标准库，还有一些是自定义的。
从根本上说，只要对象满足要求，就不必关心其功能的具体实现过程。在OOP中，不必关心对象的具体实现，只要满足用户的需求即可。
对于一些规模较小的问题，将其分解为过程开发比较理想。而面向对象更加适用于解决规模较大的问题。要想实现一个WEB浏览器大约需要2000个过程。这些过程可能需要对一些全局数据进行操作。采用面向对象的设计风格，可能大约100个类，每个类平均包含20个方法。后者更易于程序员掌握，也容易找到bug。假设给定对象的数据出错了，访问过这个数据项的20个方法中查找错误要比在2000个过程中查找容易得多。
类
类是构造对象的模板和蓝图。我们可以将类想象成制作小甜饼的切割机，将对象想象为小甜饼。由类构造对象的过程为创建类的实例。
用Java编写的所有代码都位于某个类的内部。标准的Java库提供了几千个类，可以用于用户界面设计、日期、日历和网络程序设计。尽管如此，还是需要在Java程序中创建一些自己的类，解决实际问题。
封装是与对象有关的一个重要概念。从形式上看，封装不过是将数据和行为组合在以恶个包中，并对对象的使用这隐藏了数据的实现方式。对象中的数据称为称为实例域，操纵数据的过程称为方法。每个特定的类实例都有一组特定的实例域值。这些值的集合就是这个对象的当前状态。无论合适，只要向对象发送一个消息，它的状态就有可能发生改变。
实现封装的关键在于绝对不能让类中的方法直接访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。封装给对象赋予了黑盒特征，这是提高重用性和可靠性的关键。
这意味着一个类可以全面地改变存储数据的方式，只要仍旧使用同样的方法操作数据，其他对象就不会知道或介意所发生的变化。
对象
要想使用OOP，一定要清楚对象的三个主要特性
 对象的行为——可以对对象施加哪些操作，或可以对对象施加哪些方法？ 对象的状态——当是加急那些方法时，对象如何响应？ 对象标识——如何辨别具有相同行为与状态的不同对象？  每个对象都保存着描述当前特征的信息。这就是对象的状态。对象的状态可能会随着时间而发生改变。但这种改变不会是自发的。对象状态的改变必须通过调用方法实现。如果不经过方法调用就可以改变对象状态，只能说明封装性遭到了破坏。
但是，对象的状态并不能完全描述一个对象。每个对象都有一个唯一的身份。
需要注意，作为一个类的实例，每个对象的标识永远是不同的，状态常常也存在着差异。
对象的这些关键特性在彼此之间相互影响着。例如，对象的状态影响它的行为（如果一个订单“已送货”或已付款，就应该拒绝调用而具有增删订单中条目的方法。反过来，如果订单是“空的”，即还没有加入预定的物品，这个订单就不应该进入已送货状态）
识别类
识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。
类之间的关系
 依赖——如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类 聚合——聚合关系意味着类A的对象包含类B的对象 继承——类A扩展类B，类A不但包含从类B继承的方法，还会有一些额外的功能。  对象与对象变量
要想使用对象，必须首先构造对象，并指定其初始状态。然后、对对象应用方法。
构造器是一种特殊的方法，用来构造并初始化对象。
构造器的名字应该与类名相同。因此Date类的构造器名为Date。
new Date（）
这个表达式构造了一个新对象。这个对象被初始化为当前的日期和时间
如果需要的话，也可以将这个对象传递给一个方法：
System.out.println(new Date()); Date类中有一个toString方法。这个方法将返回日期的字符串描述
String s =new Date().toString();一定要认识到：一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。
在Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个引用。
可以显式地将对象变量设置为null，表明这个对象变量目前没有引用任何对象。
局部变量不会自动地初始化为null，而必须通过调用new或将它们设置为null进行初始化
更改器方法与访问器方法
更改器方法是访问并修改对象的方法，与只访问对象而不修改对象的方法是访问器方法。
关键字public意味着任何类的任何方法都可以调用
关键字private确保只有类自身的方法能够访问
为了保证封装性，建议将实例域标记为private
构造器与类同名。在构造类的对象时，构造器会允许，以便将实例域初始化为所希望的状态。
构造器与其他方法有一个重要的不同。它总是伴随着new操作符的执行被调用。不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。
务必记住！
 构造器与类同名 每个类可以有一个以上的构造器 构造器可以有0个、1个或多个参数 构造器没有返回值 构造器总是伴随着new操作一起调用  注意，不要再构造器中定义与实例域重名的局部变量。如
public Employee(String n,double s,...){String name = n;// Errordouble salary =s;//Error}隐式参数与显式参数" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/" />
<meta property="article:published_time" content="2021-05-05T23:11:17+08:00" />
<meta property="article:modified_time" content="2021-05-05T23:11:17+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://zereals7.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="Zereal" /></a>
      <h1>Zereal</h1>
      <p>Java coder</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/ZerealS7" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Java核心技术第四章笔记-对象和类</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          May 5, 2021
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          2 min read
        </div></div>
    </header>
    <div class="post-content">
      <p><strong>面向对象</strong></p>
<p>Java是完全面向对象的。面向对象的抽象是由对象组成的。</p>
<p>每个对象包含对用户公开的特定功能部分和隐藏的实现部分。程序中的很多对象来自标准库，还有一些是自定义的。</p>
<p>从根本上说，只要对象满足要求，就不必关心其功能的具体实现过程。在OOP中，不必关心对象的具体实现，只要满足用户的需求即可。</p>
<p>对于一些规模较小的问题，将其分解为过程开发比较理想。而面向对象更加适用于解决规模较大的问题。要想实现一个WEB浏览器大约需要2000个过程。这些过程可能需要对一些全局数据进行操作。采用面向对象的设计风格，可能大约100个类，每个类平均包含20个方法。后者更易于程序员掌握，也容易找到bug。假设给定对象的数据出错了，访问过这个数据项的20个方法中查找错误要比在2000个过程中查找容易得多。</p>
<p><strong>类</strong></p>
<p>类是构造对象的模板和蓝图。我们可以将类想象成制作小甜饼的切割机，将对象想象为小甜饼。由类构造对象的过程为创建类的实例。</p>
<p>用Java编写的所有代码都位于某个类的内部。标准的Java库提供了几千个类，可以用于用户界面设计、日期、日历和网络程序设计。尽管如此，还是需要在Java程序中创建一些自己的类，解决实际问题。</p>
<p>封装是与对象有关的一个重要概念。从形式上看，封装不过是将数据和行为组合在以恶个包中，并对对象的使用这隐藏了数据的实现方式。对象中的数据称为称为实例域，操纵数据的过程称为方法。每个特定的类实例都有一组特定的实例域值。这些值的集合就是这个对象的当前状态。无论合适，只要向对象发送一个消息，它的状态就有可能发生改变。</p>
<p>实现封装的关键在于绝对不能让类中的方法直接访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。封装给对象赋予了黑盒特征，这是提高重用性和可靠性的关键。</p>
<p>这意味着一个类可以全面地改变存储数据的方式，只要仍旧使用同样的方法操作数据，其他对象就不会知道或介意所发生的变化。</p>
<p><strong>对象</strong></p>
<p>要想使用OOP，一定要清楚对象的三个主要特性</p>
<ul>
<li>对象的行为——可以对对象施加哪些操作，或可以对对象施加哪些方法？</li>
<li>对象的状态——当是加急那些方法时，对象如何响应？</li>
<li>对象标识——如何辨别具有相同行为与状态的不同对象？</li>
</ul>
<p>每个对象都保存着描述当前特征的信息。这就是对象的状态。对象的状态可能会随着时间而发生改变。但这种改变不会是自发的。对象状态的改变必须通过调用方法实现。如果不经过方法调用就可以改变对象状态，只能说明封装性遭到了破坏。</p>
<p>但是，对象的状态并不能完全描述一个对象。每个对象都有一个唯一的身份。</p>
<p>需要注意，作为一个类的实例，每个对象的标识永远是不同的，状态常常也存在着差异。</p>
<p>对象的这些关键特性在彼此之间相互影响着。例如，对象的状态影响它的行为（如果一个订单“已送货”或已付款，就应该拒绝调用而具有增删订单中条目的方法。反过来，如果订单是“空的”，即还没有加入预定的物品，这个订单就不应该进入已送货状态）</p>
<p><strong>识别类</strong></p>
<p>识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。</p>
<p><strong>类之间的关系</strong></p>
<ul>
<li>依赖——如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类</li>
<li>聚合——聚合关系意味着类A的对象包含类B的对象</li>
<li>继承——类A扩展类B，类A不但包含从类B继承的方法，还会有一些额外的功能。</li>
</ul>
<p><strong>对象与对象变量</strong></p>
<p>要想使用对象，必须首先构造对象，并指定其初始状态。然后、对对象应用方法。</p>
<p>构造器是一种特殊的方法，用来构造并初始化对象。</p>
<p>构造器的名字应该与类名相同。因此Date类的构造器名为Date。</p>
<p>new Date（）</p>
<p>这个表达式构造了一个新对象。这个对象被初始化为当前的日期和时间</p>
<p>如果需要的话，也可以将这个对象传递给一个方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Date<span style="color:#f92672">());</span>
</code></pre></div><p>Date类中有一个toString方法。这个方法将返回日期的字符串描述</p>
<pre><code>String s =new Date().toString();
</code></pre><p>一定要认识到：一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。</p>
<p>在Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个引用。</p>
<p>可以显式地将对象变量设置为null，表明这个对象变量目前没有引用任何对象。</p>
<p>局部变量不会自动地初始化为null，而必须通过调用new或将它们设置为null进行初始化</p>
<p><strong>更改器方法与访问器方法</strong></p>
<p>更改器方法是访问并修改对象的方法，与只访问对象而不修改对象的方法是访问器方法。</p>
<p>关键字public意味着任何类的任何方法都可以调用</p>
<p>关键字private确保只有类自身的方法能够访问</p>
<p>为了保证封装性，建议将实例域标记为private</p>
<p>构造器与类同名。在构造类的对象时，构造器会允许，以便将实例域初始化为所希望的状态。</p>
<p>构造器与其他方法有一个重要的不同。它总是伴随着new操作符的执行被调用。不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。</p>
<p><strong>务必记住！</strong></p>
<ul>
<li>构造器与类同名</li>
<li>每个类可以有一个以上的构造器</li>
<li>构造器可以有0个、1个或多个参数</li>
<li>构造器没有返回值</li>
<li>构造器总是伴随着new操作一起调用</li>
</ul>
<p>注意，不要再构造器中定义与实例域重名的局部变量。如</p>
<pre><code>public Employee(String n,double s,...){
	String name = n;// Error
	double salary =s;//Error
}
</code></pre><p><strong>隐式参数与显式参数</strong></p>
<p>方法用于操作对象以及存取它们的实例域。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> raiseSalary<span style="color:#960050;background-color:#1e0010">（</span><span style="color:#66d9ef">double</span> byPercent<span style="color:#960050;background-color:#1e0010">）</span>
<span style="color:#f92672">{</span>

<span style="color:#66d9ef">double</span> raise<span style="color:#f92672">=</span>salary <span style="color:#f92672">*</span>byPercent<span style="color:#f92672">/</span>100<span style="color:#f92672">;</span>

salary <span style="color:#f92672">+=</span>raise<span style="color:#f92672">;</span>

<span style="color:#f92672">}</span>
</code></pre></div><p>上面的方法有两个参数。第一个参数是隐式参数，是出现在方法名前的Employee类对象。第二个参数位于方法名后面括号中的数值，这是一个显式参数。（有些人把隐式参数称为方法的调用的目标或接收者）。</p>
<p>可以看到，显式参数是明显地列在方法名后面括号中的数值，这是一个显式参数。</p>
<p>在每一个方法中，关键字this表示隐式参数。（表示调用这个方法的对象）</p>
<p>例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> raiseSalary<span style="color:#960050;background-color:#1e0010">（</span><span style="color:#66d9ef">double</span> byPercent<span style="color:#960050;background-color:#1e0010">）</span>
<span style="color:#f92672">{</span>

<span style="color:#66d9ef">double</span> raise<span style="color:#f92672">=</span><span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">salary</span> <span style="color:#f92672">*</span>byPercent<span style="color:#f92672">/</span>100<span style="color:#f92672">;</span>

<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">salary</span> <span style="color:#f92672">+=</span>raise<span style="color:#f92672">;</span>

<span style="color:#f92672">}</span>
</code></pre></div><p>有些程序员更偏爱这样的风格，因为这样可以将实例域与局部变量明显区分开来</p>
<p>在Java中，所有方法必须在类的内部定义，但并不表示它们是内联方法。是否将某个方法设置为内联方法是Java虚拟机的任务。即时编译器会监视调用那些简洁、经常被调用、没有被重载以及可以优化的方法。</p>
<p><strong>封装的优点</strong></p>
<p>典型的访问器方法。由于只返回实例域值。因此又被称为域访问器。</p>
<p>有些适合，需要获得或设置实例域的值，需要提供下面三项内容</p>
<ul>
<li>一个私有的数据域</li>
<li>一个公有的域访问器方法</li>
<li>一个公有的域更改器方法</li>
</ul>
<p>这样做要比提供一个简单的公有数据域复杂些，担忧明显的好处：</p>
<p>首先，可以改变内部实现，除了该类的方法之外，不会影响其他代码。</p>
<p>更改器方法可以执行错误检查，然而直接对域进行赋值将不会进行这些处理。</p>
<p>注意不要编写返回可变对象的访问器方法，这样破坏了封装性。如果需要返回一个可变对象的引用，一个首先对它进行克隆。如果需要返回一个可变数据域的拷贝，就应该使用克隆。</p>
<p><strong>基于类的访问权限</strong></p>
<p>方法可以访问所调用对象的私有数据。一个方法可以访问所属类的所有对象的私有数据。</p>
<p><strong>私有方法</strong></p>
<p>尽管大多数方法都被设计为公有的，但在某些特殊情况下，也可能将它们设计为私有的。优势，可能希望将一个计算代码划分成若干个独立的房租胡方法。通常在，这些赋值方法比一个称为公有接口的一部分，这是由于它们往往域当前的实现机制，非常紧密，或者需要一个特别的协议以及一个特别的调用次序。最好将这样的方法设计为private即可。</p>
<p>在Java中，为了实现一个私有的方法，只需要将关键字public改为private即可。</p>
<p>只要方法是私有的，类的设计者就可以确信；它不会被外部的其他类操作调用，可以将其删去，如果方法是公有的，就不能将其删去，因为其他代码很可能依赖它。</p>
<p><strong>final实例域</strong></p>
<p>可以将实例域定义为final，但是必须进行初始化。也就是说，在每一个构造器执行之后，要确保这个域的值被设置，并且在后面的操作中，不能再对它进行修改。</p>
<p>final修饰符大都应用于基本类型域、或不可变类的域（如果类中的每个方法都不会改变其对象，这种类就是不可变的类。例如String）。</p>
<p>对于可变的类，使用final修饰符可能会造成混乱。</p>
<p>例如</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> StringBuilder evalutions<span style="color:#f92672">;</span>

evalutions <span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> StringBuilder<span style="color:#f92672">();</span>
</code></pre></div><p>final关键字只是表示存储再evalutions变量中的对象引用不会再指示其他StringBuilder对象。不过这个对象可以更改：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">giveGoldStar</span><span style="color:#f92672">(){</span>
 evalutions<span style="color:#f92672">.</span><span style="color:#a6e22e">append</span><span style="color:#f92672">(</span>LocalDatje<span style="color:#f92672">.</span><span style="color:#a6e22e">now</span><span style="color:#f92672">()+</span><span style="color:#e6db74">&#34;:Gold star!\n&#34;</span><span style="color:#f92672">)</span>

<span style="color:#f92672">}</span>
</code></pre></div><p><strong>静态域</strong>（域就是数据与变量）</p>
<p>如果将域定义为static，每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。静态域即使没有实例对象也存在，它属于类，而不属于任何独立的对象。</p>
<p><strong>静态常量</strong></p>
<p>静态变量使用得比较少，静态常量却使用得比较多。例如</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Math</span><span style="color:#f92672">{</span>
<span style="color:#f92672">...</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">double</span> PI<span style="color:#f92672">=</span>3<span style="color:#f92672">.</span><span style="color:#a6e22e">1415926</span>
<span style="color:#f92672">...</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>在程序中，可以使用Math.PI的形式获得这个常量。如果关键字static被省略，PI就变成了Math类的一个实例域。需要通过Math类的对象访问PI，并且每一个Math类的对象访问PI拷贝。</p>
<p>另一个多次使用的静态常量是System.out。它在System类中声明：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">System</span><span style="color:#f92672">{</span>
<span style="color:#f92672">...</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> PrintStream out <span style="color:#f92672">=...;</span>
<span style="color:#f92672">...</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>虽然前面提到，由于每个类对象都可以对公有域进行修改，所有最好不要将域设计为public。然而，公有常量（final域）却没问题。因为out被声明为final,所以，不允许再将其他打印流赋给它。</p>
<p><strong>静态方法</strong></p>
<p>静态方法是一种不能向对象实施操作的方法。例如，Math类的pow方法就是一种静态方法。</p>
<p>表达式</p>
<pre><code>Math.pow（x,a）
</code></pre><p>计算幂X的a次方。再运算时，不能使用任何Math对象。换句话说，没有隐式的参数。</p>
<p>可以认为静态方法是没有this参数的方法（在一个非静态的方法中，this参数表示这个方法的隐式参数）</p>
<p>静态方法不能访问实例域，因为它不饿能操作对象。但是静态方法可以访问自身类中的静态域。</p>
<p>为了避免造成混淆，建议通过类名而不是对象调用静态方法。</p>
<p>在下面两种情况下使用静态方法：</p>
<ul>
<li>一个方法不需要访问对象状态，其所需参数都是通过显式参数提供（如Math.pow）</li>
<li>一个方法只需要访问类的静态域</li>
</ul>
<p><strong>工厂方法</strong></p>
<p>类似LocalDate和NumberFormat的类使用静态工厂方法来构造对象。</p>
<p>为什么NumberFormat类不利用构造器完成这些操作呢？有两个原因</p>
<ul>
<li>无法命名构造器。构造器的名字必须与类名相同。</li>
<li>当使用构造器时，无法改变所构造的对象类型。而Factory方法将返回一个DecimalFormat类对象，这是NumberFormat的子类。</li>
</ul>
<p><strong>main方法</strong></p>
<p>需要注意，不需要使用对象调用静态方法。例如，不需要构造Math类对象就可以调用Math.pow。</p>
<p>同理，main方法也是一个静态方法。</p>
<p>main方法不对任何对象进行操作。事实上，在启动程序时还没有任何一个对象。静态的main方法将执行并创建程序所需要的对象。</p>
<p>每一个类都可以有一个main方法。这是一个常用于对类进行单元测试的技巧。</p>
<p><strong>方法参数</strong></p>
<p>Java程序设计语言总是采用按值调用。也就是说，方法得到的时所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。如</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">double</span> percent <span style="color:#f92672">=</span>10<span style="color:#f92672">;</span>
harry<span style="color:#f92672">.</span><span style="color:#a6e22e">raiseSalary</span><span style="color:#f92672">(</span>percent<span style="color:#f92672">);</span>
</code></pre></div><p>调用这个方法之后，percent值还是10.</p>
<p>局部变量方法结束后不再使用。</p>
<p>方法参数有两种基本类型：</p>
<ul>
<li>基本数据类型</li>
<li>对象引用</li>
</ul>
<p>Java程序对对象采用的不是引用调用，实际上，对象引用是按值传递的。</p>
<p>一个方法不能修改一个基本数据类型的参数。（即数值型或布尔型）</p>
<p>一个方法可以改变对象参数的状态。</p>
<p>一个方法不能让对象参数引用一个新的对象。</p>
<p>如果传入的是对象类型的参数，则可以通过对象引用的拷贝修改所引用的对象状态。</p>
<p><strong>对象构造</strong></p>
<p>Java提供了多种编写构造器的机制。以下是对这些机制的详细介绍</p>
<p><em><strong>1.重载</strong></em></p>
<p>有些类有多个构造器。例如，可以如下构造一个空的StringBuilder对象：</p>
<pre><code>StringBuilder messages=new StringBuilder();
</code></pre><p>或者，可以指定一个初始字符串：</p>
<pre><code>StringBuilder todoList=new StringBuilder(&quot;To do:\n&quot;);
</code></pre><p>这种特征叫做重载。如果多个方法有相同的名字、不同的参数，便产生了重载。编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。如果编译器找不到匹配的参数，就会产生编译时错误，因为根本不存在匹配，或者没有一个比其他的更好。（这个过程被称为重载接续）</p>
<p>Java允许重载任何方法，而不只是构造器方法。</p>
<p>因此要完整的描述与i个方法需要指出方法名以及参数类型。这叫做方法的签名。</p>
<p>返回类型不是方法签名的一部分。也就是说，不能有两个名字相同、参数类型也相同却返回不同类型值的方法。</p>
<p>方法名加方法参数唯一确定一个方法</p>
<p><em><strong>2.默认域初始化</strong></em></p>
<p>如果在构造器中没有显式地给域赋予初值，呢么就会被自动地赋为默认值：数值为0、布尔值为false、对象引用为null。</p>
<p>必须明确地初始化方法中的局部变量。但是，如果没有初始化类中的域，将会被自动初始化为默认值（0、false或null）。这是域和局部变量的主要不同点。</p>
<p><em><strong>3.无参数构造器</strong></em></p>
<p>很多类都包含一个无参数的构造函数，对象由无参数构造器函数创建时，其状态会设置为适当的默认值。</p>
<p>如果在编写一个类时没有编写构造器，那么系统就会提供一个无参数构造器。这个构造器将所有的实例域设置为默认值。于是，实例域中的数值型数据设置为0，布尔值数据设置为false，所有对象变量将设置为null。</p>
<p>如果类中提供了至少一个构造器，但是没有提供无参数的构造器，则在构造对象时如果没有提供参数就会被视为不合法。（有参构造会覆盖无参构造）。</p>
<p>要想同时使用有参无参，就把它们都进行定义。否则要不就是有参，又不没有定义就是无参。</p>
<p><em><strong>4.显式域初始化</strong></em></p>
<p>通过重载类的构造器方法，可以采用多种形式设置类的实例域的初始状态。确保不管怎样调用构造器，每个实例域都可以被设置为一个有意义的初值</p>
<p>在执行构造器之前，先进行赋值操作。当一个类的所有构造器都希望把相同的值赋予某个特定的实例域时，特别有用。</p>
<p>初始值不一定是常量值。可以调用方法对域进行初始化。每个雇员有一个id域，可与i使用下列方法进行初始化：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Employee</span><span style="color:#f92672">{</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> nextId<span style="color:#f92672">;</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> id<span style="color:#f92672">=</span>assignId<span style="color:#f92672">();</span>
<span style="color:#f92672">...</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">assignId</span><span style="color:#f92672">(){</span>
<span style="color:#66d9ef">int</span> r<span style="color:#f92672">=</span> nextId<span style="color:#f92672">;</span>
nextId<span style="color:#f92672">++;</span>
<span style="color:#66d9ef">return</span> r<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
<span style="color:#f92672">...</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><em><strong>5.参数名</strong></em></p>
<p>在编写很小的构造器时，常常在参数命名上出现错误。比如说参数用单个字符命名。这样做有一个缺陷：”只有阅读代码才能够了解参数n和参数s的含义。有些程序员在每个参数前面加上一个前缀&rsquo;a&rsquo;:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Employee</span> <span style="color:#f92672">(</span>String aName<span style="color:#f92672">,</span><span style="color:#66d9ef">double</span> aSalary<span style="color:#f92672">)</span>
<span style="color:#f92672">{</span>
	name<span style="color:#f92672">=</span>aName<span style="color:#f92672">;</span>
	salary<span style="color:#f92672">=</span>aSalary<span style="color:#f92672">;</span>	
<span style="color:#f92672">}</span>
</code></pre></div><p>还有一种常用的技巧，参数变量用同样的名字将实例域屏蔽起来。例外，如果将参数命名为salary，salary将引用这个参数，而不是实例域。但是，可以采用this.salary的形式访问实例域。this指示隐式参数，也就是所构造的对象。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Employee</span><span style="color:#f92672">(</span>String name<span style="color:#f92672">,</span><span style="color:#66d9ef">double</span> salary<span style="color:#f92672">)</span>
<span style="color:#f92672">{</span>
	<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">name</span><span style="color:#f92672">=</span>name<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">salary</span><span style="color:#f92672">=</span>salary<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><em><strong>6.调用另一个构造器</strong></em></p>
<p>关键字this引用方法的隐式参数。然而这个关键字还有另外一个含义。</p>
<p>如果构造器的第一个语句形如this（&hellip;）,这个构造器将调用同一个类的另一个构造器</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Employee</span><span style="color:#f92672">(</span><span style="color:#66d9ef">double</span> s<span style="color:#f92672">)</span>

<span style="color:#f92672">{</span>

<span style="color:#66d9ef">this</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Employee #&#34;</span><span style="color:#f92672">+</span>nextId<span style="color:#f92672">,</span>s<span style="color:#f92672">);</span>

nextId<span style="color:#f92672">++;</span>

<span style="color:#f92672">}</span>

</code></pre></div><p>当调用new Emplyee(60000)时，Employee(double)构造器将调用Employee（String,double）构造器。</p>
<p>采用这种方式使用this关键字非常有用，这样对公共的构造器代码部分值编写一部分即可。</p>
<p>不能用类名调用构造器，只能使用this调用，最后会返回一个新的构造对象（方法体里面的对象）。</p>
<p><em><strong>7.初始化块</strong></em></p>
<p>有两种初始化数据域的方法：</p>
<ul>
<li>在构造器中设置值</li>
<li>在声明中赋值</li>
</ul>
<p>实际上，Java还有第三种机制，称为初始化块。在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行。</p>

    </div>
    <div class="post-footer">
      
    </div>
    <div class="post-comment">
      
      


<span id="/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/" class="leancloud_visitors" data-flag-title="Java核心技术第四章笔记-对象和类">
    <span class="post-meta-item-text">文章阅读量 </span>
    <span class="leancloud-visitors-count">1000000</span>
    <p></p>
  </span>
<div id="vcomments"></div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script type="text/javascript">
  new Valine({
    el: '#vcomments' ,
    appId: 'cScQmclMsD4OOWCclCP1pNsz-gzGzoHsz',
    appKey: 'dtSaHLmdH3J4ICVVInYg9YFM',
    notify:  false ,
  verify:  false ,
  avatar:'mm',
    placeholder: '说点什么吧...',
    visitor:  true 
  });
</script>

    </div>
  </article>

    </main>
  </body>
</html>
