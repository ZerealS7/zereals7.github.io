<!doctype html>
<html lang="en-us">
  <head>
    <title>Java核心技术第四章笔记-对象和类 // Zereal-宋致远技术博客</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.72.0" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75，minimum-scale=0.75, maximum-scale=0.75, user-scalable=no" />
    <meta name="author" content="Zereal" />
    <meta name="description" content="" />
    <meta name="referrer" content="never"/>
    <link rel="stylesheet" href="https://zereals7.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java核心技术第四章笔记-对象和类"/>
<meta name="twitter:description" content="面向对象
Java是完全面向对象的。面向对象的抽象是由对象组成的。
每个对象包含对用户公开的特定功能部分和隐藏的实现部分。程序中的很多对象来自标准库，还有一些是自定义的。
从根本上说，只要对象满足要求，就不必关心其功能的具体实现过程。在OOP中，不必关心对象的具体实现，只要满足用户的需求即可。
对于一些规模较小的问题，将其分解为过程开发比较理想。而面向对象更加适用于解决规模较大的问题。要想实现一个WEB浏览器大约需要2000个过程。这些过程可能需要对一些全局数据进行操作。采用面向对象的设计风格，可能大约100个类，每个类平均包含20个方法。后者更易于程序员掌握，也容易找到bug。假设给定对象的数据出错了，访问过这个数据项的20个方法中查找错误要比在2000个过程中查找容易得多。
类
类是构造对象的模板和蓝图。我们可以将类想象成制作小甜饼的切割机，将对象想象为小甜饼。由类构造对象的过程为创建类的实例。
用Java编写的所有代码都位于某个类的内部。标准的Java库提供了几千个类，可以用于用户界面设计、日期、日历和网络程序设计。尽管如此，还是需要在Java程序中创建一些自己的类，解决实际问题。
封装是与对象有关的一个重要概念。从形式上看，封装不过是将数据和行为组合在以恶个包中，并对对象的使用这隐藏了数据的实现方式。对象中的数据称为称为实例域，操纵数据的过程称为方法。每个特定的类实例都有一组特定的实例域值。这些值的集合就是这个对象的当前状态。无论合适，只要向对象发送一个消息，它的状态就有可能发生改变。
实现封装的关键在于绝对不能让类中的方法直接访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。封装给对象赋予了黑盒特征，这是提高重用性和可靠性的关键。
这意味着一个类可以全面地改变存储数据的方式，只要仍旧使用同样的方法操作数据，其他对象就不会知道或介意所发生的变化。
对象
要想使用OOP，一定要清楚对象的三个主要特性
 对象的行为——可以对对象施加哪些操作，或可以对对象施加哪些方法？ 对象的状态——当是加急那些方法时，对象如何响应？ 对象标识——如何辨别具有相同行为与状态的不同对象？  每个对象都保存着描述当前特征的信息。这就是对象的状态。对象的状态可能会随着时间而发生改变。但这种改变不会是自发的。对象状态的改变必须通过调用方法实现。如果不经过方法调用就可以改变对象状态，只能说明封装性遭到了破坏。
但是，对象的状态并不能完全描述一个对象。每个对象都有一个唯一的身份。
需要注意，作为一个类的实例，每个对象的标识永远是不同的，状态常常也存在着差异。
对象的这些关键特性在彼此之间相互影响着。例如，对象的状态影响它的行为（如果一个订单“已送货”或已付款，就应该拒绝调用而具有增删订单中条目的方法。反过来，如果订单是“空的”，即还没有加入预定的物品，这个订单就不应该进入已送货状态）
识别类
识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。
类之间的关系
 依赖——如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类 聚合——聚合关系意味着类A的对象包含类B的对象 继承——类A扩展类B，类A不但包含从类B继承的方法，还会有一些额外的功能。  对象与对象变量
要想使用对象，必须首先构造对象，并指定其初始状态。然后、对对象应用方法。
构造器是一种特殊的方法，用来构造并初始化对象。
构造器的名字应该与类名相同。因此Date类的构造器名为Date。
new Date（）
这个表达式构造了一个新对象。这个对象被初始化为当前的日期和时间
如果需要的话，也可以将这个对象传递给一个方法：
System.out.println(new Date()); Date类中有一个toString方法。这个方法将返回日期的字符串描述
String s =new Date().toString();一定要认识到：一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。
在Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个引用。
可以显式地将对象变量设置为null，表明这个对象变量目前没有引用任何对象。
局部变量不会自动地初始化为null，而必须通过调用new或将它们设置为null进行初始化
更改器方法与访问器方法
更改器方法是访问并修改对象的方法，与只访问对象而不修改对象的方法是访问器方法。
关键字public意味着任何类的任何方法都可以调用
关键字private确保只有类自身的方法能够访问
为了保证封装性，建议将实例域标记为private
构造器与类同名。在构造类的对象时，构造器会允许，以便将实例域初始化为所希望的状态。
构造器与其他方法有一个重要的不同。它总是伴随着new操作符的执行被调用。不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。
务必记住！
 构造器与类同名 每个类可以有一个以上的构造器 构造器可以有0个、1个或多个参数 构造器没有返回值 构造器总是伴随着new操作一起调用  注意，不要再构造器中定义与实例域重名的局部变量。如
public Employee(String n,double s,...){String name = n;// Errordouble salary =s;//Error}隐式参数与显式参数"/>

    <meta property="og:title" content="Java核心技术第四章笔记-对象和类" />
<meta property="og:description" content="面向对象
Java是完全面向对象的。面向对象的抽象是由对象组成的。
每个对象包含对用户公开的特定功能部分和隐藏的实现部分。程序中的很多对象来自标准库，还有一些是自定义的。
从根本上说，只要对象满足要求，就不必关心其功能的具体实现过程。在OOP中，不必关心对象的具体实现，只要满足用户的需求即可。
对于一些规模较小的问题，将其分解为过程开发比较理想。而面向对象更加适用于解决规模较大的问题。要想实现一个WEB浏览器大约需要2000个过程。这些过程可能需要对一些全局数据进行操作。采用面向对象的设计风格，可能大约100个类，每个类平均包含20个方法。后者更易于程序员掌握，也容易找到bug。假设给定对象的数据出错了，访问过这个数据项的20个方法中查找错误要比在2000个过程中查找容易得多。
类
类是构造对象的模板和蓝图。我们可以将类想象成制作小甜饼的切割机，将对象想象为小甜饼。由类构造对象的过程为创建类的实例。
用Java编写的所有代码都位于某个类的内部。标准的Java库提供了几千个类，可以用于用户界面设计、日期、日历和网络程序设计。尽管如此，还是需要在Java程序中创建一些自己的类，解决实际问题。
封装是与对象有关的一个重要概念。从形式上看，封装不过是将数据和行为组合在以恶个包中，并对对象的使用这隐藏了数据的实现方式。对象中的数据称为称为实例域，操纵数据的过程称为方法。每个特定的类实例都有一组特定的实例域值。这些值的集合就是这个对象的当前状态。无论合适，只要向对象发送一个消息，它的状态就有可能发生改变。
实现封装的关键在于绝对不能让类中的方法直接访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。封装给对象赋予了黑盒特征，这是提高重用性和可靠性的关键。
这意味着一个类可以全面地改变存储数据的方式，只要仍旧使用同样的方法操作数据，其他对象就不会知道或介意所发生的变化。
对象
要想使用OOP，一定要清楚对象的三个主要特性
 对象的行为——可以对对象施加哪些操作，或可以对对象施加哪些方法？ 对象的状态——当是加急那些方法时，对象如何响应？ 对象标识——如何辨别具有相同行为与状态的不同对象？  每个对象都保存着描述当前特征的信息。这就是对象的状态。对象的状态可能会随着时间而发生改变。但这种改变不会是自发的。对象状态的改变必须通过调用方法实现。如果不经过方法调用就可以改变对象状态，只能说明封装性遭到了破坏。
但是，对象的状态并不能完全描述一个对象。每个对象都有一个唯一的身份。
需要注意，作为一个类的实例，每个对象的标识永远是不同的，状态常常也存在着差异。
对象的这些关键特性在彼此之间相互影响着。例如，对象的状态影响它的行为（如果一个订单“已送货”或已付款，就应该拒绝调用而具有增删订单中条目的方法。反过来，如果订单是“空的”，即还没有加入预定的物品，这个订单就不应该进入已送货状态）
识别类
识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。
类之间的关系
 依赖——如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类 聚合——聚合关系意味着类A的对象包含类B的对象 继承——类A扩展类B，类A不但包含从类B继承的方法，还会有一些额外的功能。  对象与对象变量
要想使用对象，必须首先构造对象，并指定其初始状态。然后、对对象应用方法。
构造器是一种特殊的方法，用来构造并初始化对象。
构造器的名字应该与类名相同。因此Date类的构造器名为Date。
new Date（）
这个表达式构造了一个新对象。这个对象被初始化为当前的日期和时间
如果需要的话，也可以将这个对象传递给一个方法：
System.out.println(new Date()); Date类中有一个toString方法。这个方法将返回日期的字符串描述
String s =new Date().toString();一定要认识到：一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。
在Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个引用。
可以显式地将对象变量设置为null，表明这个对象变量目前没有引用任何对象。
局部变量不会自动地初始化为null，而必须通过调用new或将它们设置为null进行初始化
更改器方法与访问器方法
更改器方法是访问并修改对象的方法，与只访问对象而不修改对象的方法是访问器方法。
关键字public意味着任何类的任何方法都可以调用
关键字private确保只有类自身的方法能够访问
为了保证封装性，建议将实例域标记为private
构造器与类同名。在构造类的对象时，构造器会允许，以便将实例域初始化为所希望的状态。
构造器与其他方法有一个重要的不同。它总是伴随着new操作符的执行被调用。不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。
务必记住！
 构造器与类同名 每个类可以有一个以上的构造器 构造器可以有0个、1个或多个参数 构造器没有返回值 构造器总是伴随着new操作一起调用  注意，不要再构造器中定义与实例域重名的局部变量。如
public Employee(String n,double s,...){String name = n;// Errordouble salary =s;//Error}隐式参数与显式参数" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/" />
<meta property="article:published_time" content="2021-05-05T23:11:17+08:00" />
<meta property="article:modified_time" content="2021-05-05T23:11:17+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://zereals7.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="Zereal" /></a>
      <h1>Zereal</h1>
      <p>Java coder</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/ZerealS7" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Java核心技术第四章笔记-对象和类</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          May 5, 2021
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          3 min read
        </div></div>
    </header>
    <div class="post-content">
      <p><strong>面向对象</strong></p>
<p>Java是完全面向对象的。面向对象的抽象是由对象组成的。</p>
<p>每个对象包含对用户公开的特定功能部分和隐藏的实现部分。程序中的很多对象来自标准库，还有一些是自定义的。</p>
<p>从根本上说，只要对象满足要求，就不必关心其功能的具体实现过程。在OOP中，不必关心对象的具体实现，只要满足用户的需求即可。</p>
<p>对于一些规模较小的问题，将其分解为过程开发比较理想。而面向对象更加适用于解决规模较大的问题。要想实现一个WEB浏览器大约需要2000个过程。这些过程可能需要对一些全局数据进行操作。采用面向对象的设计风格，可能大约100个类，每个类平均包含20个方法。后者更易于程序员掌握，也容易找到bug。假设给定对象的数据出错了，访问过这个数据项的20个方法中查找错误要比在2000个过程中查找容易得多。</p>
<p><strong>类</strong></p>
<p>类是构造对象的模板和蓝图。我们可以将类想象成制作小甜饼的切割机，将对象想象为小甜饼。由类构造对象的过程为创建类的实例。</p>
<p>用Java编写的所有代码都位于某个类的内部。标准的Java库提供了几千个类，可以用于用户界面设计、日期、日历和网络程序设计。尽管如此，还是需要在Java程序中创建一些自己的类，解决实际问题。</p>
<p>封装是与对象有关的一个重要概念。从形式上看，封装不过是将数据和行为组合在以恶个包中，并对对象的使用这隐藏了数据的实现方式。对象中的数据称为称为实例域，操纵数据的过程称为方法。每个特定的类实例都有一组特定的实例域值。这些值的集合就是这个对象的当前状态。无论合适，只要向对象发送一个消息，它的状态就有可能发生改变。</p>
<p>实现封装的关键在于绝对不能让类中的方法直接访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。封装给对象赋予了黑盒特征，这是提高重用性和可靠性的关键。</p>
<p>这意味着一个类可以全面地改变存储数据的方式，只要仍旧使用同样的方法操作数据，其他对象就不会知道或介意所发生的变化。</p>
<p><strong>对象</strong></p>
<p>要想使用OOP，一定要清楚对象的三个主要特性</p>
<ul>
<li>对象的行为——可以对对象施加哪些操作，或可以对对象施加哪些方法？</li>
<li>对象的状态——当是加急那些方法时，对象如何响应？</li>
<li>对象标识——如何辨别具有相同行为与状态的不同对象？</li>
</ul>
<p>每个对象都保存着描述当前特征的信息。这就是对象的状态。对象的状态可能会随着时间而发生改变。但这种改变不会是自发的。对象状态的改变必须通过调用方法实现。如果不经过方法调用就可以改变对象状态，只能说明封装性遭到了破坏。</p>
<p>但是，对象的状态并不能完全描述一个对象。每个对象都有一个唯一的身份。</p>
<p>需要注意，作为一个类的实例，每个对象的标识永远是不同的，状态常常也存在着差异。</p>
<p>对象的这些关键特性在彼此之间相互影响着。例如，对象的状态影响它的行为（如果一个订单“已送货”或已付款，就应该拒绝调用而具有增删订单中条目的方法。反过来，如果订单是“空的”，即还没有加入预定的物品，这个订单就不应该进入已送货状态）</p>
<p><strong>识别类</strong></p>
<p>识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。</p>
<p><strong>类之间的关系</strong></p>
<ul>
<li>依赖——如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类</li>
<li>聚合——聚合关系意味着类A的对象包含类B的对象</li>
<li>继承——类A扩展类B，类A不但包含从类B继承的方法，还会有一些额外的功能。</li>
</ul>
<p><strong>对象与对象变量</strong></p>
<p>要想使用对象，必须首先构造对象，并指定其初始状态。然后、对对象应用方法。</p>
<p>构造器是一种特殊的方法，用来构造并初始化对象。</p>
<p>构造器的名字应该与类名相同。因此Date类的构造器名为Date。</p>
<p>new Date（）</p>
<p>这个表达式构造了一个新对象。这个对象被初始化为当前的日期和时间</p>
<p>如果需要的话，也可以将这个对象传递给一个方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Date<span style="color:#f92672">());</span>
</code></pre></div><p>Date类中有一个toString方法。这个方法将返回日期的字符串描述</p>
<pre><code>String s =new Date().toString();
</code></pre><p>一定要认识到：一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。</p>
<p>在Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个引用。</p>
<p>可以显式地将对象变量设置为null，表明这个对象变量目前没有引用任何对象。</p>
<p>局部变量不会自动地初始化为null，而必须通过调用new或将它们设置为null进行初始化</p>
<p><strong>更改器方法与访问器方法</strong></p>
<p>更改器方法是访问并修改对象的方法，与只访问对象而不修改对象的方法是访问器方法。</p>
<p>关键字public意味着任何类的任何方法都可以调用</p>
<p>关键字private确保只有类自身的方法能够访问</p>
<p>为了保证封装性，建议将实例域标记为private</p>
<p>构造器与类同名。在构造类的对象时，构造器会允许，以便将实例域初始化为所希望的状态。</p>
<p>构造器与其他方法有一个重要的不同。它总是伴随着new操作符的执行被调用。不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。</p>
<p><strong>务必记住！</strong></p>
<ul>
<li>构造器与类同名</li>
<li>每个类可以有一个以上的构造器</li>
<li>构造器可以有0个、1个或多个参数</li>
<li>构造器没有返回值</li>
<li>构造器总是伴随着new操作一起调用</li>
</ul>
<p>注意，不要再构造器中定义与实例域重名的局部变量。如</p>
<pre><code>public Employee(String n,double s,...){
	String name = n;// Error
	double salary =s;//Error
}
</code></pre><p><strong>隐式参数与显式参数</strong></p>
<p>方法用于操作对象以及存取它们的实例域。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> raiseSalary<span style="color:#960050;background-color:#1e0010">（</span><span style="color:#66d9ef">double</span> byPercent<span style="color:#960050;background-color:#1e0010">）</span>
<span style="color:#f92672">{</span>

<span style="color:#66d9ef">double</span> raise<span style="color:#f92672">=</span>salary <span style="color:#f92672">*</span>byPercent<span style="color:#f92672">/</span>100<span style="color:#f92672">;</span>

salary <span style="color:#f92672">+=</span>raise<span style="color:#f92672">;</span>

<span style="color:#f92672">}</span>
</code></pre></div><p>上面的方法有两个参数。第一个参数是隐式参数，是出现在方法名前的Employee类对象。第二个参数位于方法名后面括号中的数值，这是一个显式参数。（有些人把隐式参数称为方法的调用的目标或接收者）。</p>
<p>可以看到，显式参数是明显地列在方法名后面括号中的数值，这是一个显式参数。</p>
<p>在每一个方法中，关键字this表示隐式参数。（表示调用这个方法的对象）</p>
<p>例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> raiseSalary<span style="color:#960050;background-color:#1e0010">（</span><span style="color:#66d9ef">double</span> byPercent<span style="color:#960050;background-color:#1e0010">）</span>
<span style="color:#f92672">{</span>

<span style="color:#66d9ef">double</span> raise<span style="color:#f92672">=</span><span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">salary</span> <span style="color:#f92672">*</span>byPercent<span style="color:#f92672">/</span>100<span style="color:#f92672">;</span>

<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">salary</span> <span style="color:#f92672">+=</span>raise<span style="color:#f92672">;</span>

<span style="color:#f92672">}</span>
</code></pre></div><p>有些程序员更偏爱这样的风格，因为这样可以将实例域与局部变量明显区分开来</p>
<p>在Java中，所有方法必须在类的内部定义，但并不表示它们是内联方法。是否将某个方法设置为内联方法是Java虚拟机的任务。即时编译器会监视调用那些简洁、经常被调用、没有被重载以及可以优化的方法。</p>
<p><strong>封装的优点</strong></p>
<p>典型的访问器方法。由于只返回实例域值。因此又被称为域访问器。</p>
<p>有些适合，需要获得或设置实例域的值，需要提供下面三项内容</p>
<ul>
<li>一个私有的数据域</li>
<li>一个公有的域访问器方法</li>
<li>一个公有的域更改器方法</li>
</ul>
<p>这样做要比提供一个简单的公有数据域复杂些，担忧明显的好处：</p>
<p>首先，可以改变内部实现，除了该类的方法之外，不会影响其他代码。</p>
<p>更改器方法可以执行错误检查，然而直接对域进行赋值将不会进行这些处理。</p>
<p>注意不要编写返回可变对象的访问器方法，这样破坏了封装性。如果需要返回一个可变对象的引用，一个首先对它进行克隆。如果需要返回一个可变数据域的拷贝，就应该使用克隆。</p>
<p><strong>基于类的访问权限</strong></p>
<p>方法可以访问所调用对象的私有数据。一个方法可以访问所属类的所有对象的私有数据。</p>
<p><strong>私有方法</strong></p>
<p>尽管大多数方法都被设计为公有的，但在某些特殊情况下，也可能将它们设计为私有的。优势，可能希望将一个计算代码划分成若干个独立的房租胡方法。通常在，这些赋值方法比一个称为公有接口的一部分，这是由于它们往往域当前的实现机制，非常紧密，或者需要一个特别的协议以及一个特别的调用次序。最好将这样的方法设计为private即可。</p>
<p>在Java中，为了实现一个私有的方法，只需要将关键字public改为private即可。</p>
<p>只要方法是私有的，类的设计者就可以确信；它不会被外部的其他类操作调用，可以将其删去，如果方法是公有的，就不能将其删去，因为其他代码很可能依赖它。</p>
<p><strong>final实例域</strong></p>
<p>可以将实例域定义为final，但是必须进行初始化。也就是说，在每一个构造器执行之后，要确保这个域的值被设置，并且在后面的操作中，不能再对它进行修改。</p>
<p>final修饰符大都应用于基本类型域、或不可变类的域（如果类中的每个方法都不会改变其对象，这种类就是不可变的类。例如String）。</p>
<p>对于可变的类，使用final修饰符可能会造成混乱。</p>
<p>例如</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> StringBuilder evalutions<span style="color:#f92672">;</span>

evalutions <span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> StringBuilder<span style="color:#f92672">();</span>
</code></pre></div><p>final关键字只是表示存储再evalutions变量中的对象引用不会再指示其他StringBuilder对象。不过这个对象可以更改：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">giveGoldStar</span><span style="color:#f92672">(){</span>
 evalutions<span style="color:#f92672">.</span><span style="color:#a6e22e">append</span><span style="color:#f92672">(</span>LocalDatje<span style="color:#f92672">.</span><span style="color:#a6e22e">now</span><span style="color:#f92672">()+</span><span style="color:#e6db74">&#34;:Gold star!\n&#34;</span><span style="color:#f92672">)</span>

<span style="color:#f92672">}</span>
</code></pre></div><p><strong>静态域</strong>（域就是数据与变量）</p>
<p>如果将域定义为static，每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。静态域即使没有实例对象也存在，它属于类，而不属于任何独立的对象。</p>
<p><strong>静态常量</strong></p>
<p>静态变量使用得比较少，静态常量却使用得比较多。例如</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Math</span><span style="color:#f92672">{</span>
<span style="color:#f92672">...</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">double</span> PI<span style="color:#f92672">=</span>3<span style="color:#f92672">.</span><span style="color:#a6e22e">1415926</span>
<span style="color:#f92672">...</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>在程序中，可以使用Math.PI的形式获得这个常量。如果关键字static被省略，PI就变成了Math类的一个实例域。需要通过Math类的对象访问PI，并且每一个Math类的对象访问PI拷贝。</p>
<p>另一个多次使用的静态常量是System.out。它在System类中声明：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">System</span><span style="color:#f92672">{</span>
<span style="color:#f92672">...</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> PrintStream out <span style="color:#f92672">=...;</span>
<span style="color:#f92672">...</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>虽然前面提到，由于每个类对象都可以对公有域进行修改，所有最好不要将域设计为public。然而，公有常量（final域）却没问题。因为out被声明为final,所以，不允许再将其他打印流赋给它。</p>
<p><strong>静态方法</strong></p>
<p>静态方法是一种不能向对象实施操作的方法。例如，Math类的pow方法就是一种静态方法。</p>
<p>表达式</p>
<pre><code>Math.pow（x,a）
</code></pre><p>计算幂X的a次方。再运算时，不能使用任何Math对象。换句话说，没有隐式的参数。</p>
<p>可以认为静态方法是没有this参数的方法（在一个非静态的方法中，this参数表示这个方法的隐式参数）</p>
<p>静态方法不能访问实例域，因为它不饿能操作对象。但是静态方法可以访问自身类中的静态域。</p>
<p>为了避免造成混淆，建议通过类名而不是对象调用静态方法。</p>
<p>在下面两种情况下使用静态方法：</p>
<ul>
<li>一个方法不需要访问对象状态，其所需参数都是通过显式参数提供（如Math.pow）</li>
<li>一个方法只需要访问类的静态域</li>
</ul>
<p><strong>工厂方法</strong></p>
<p>类似LocalDate和NumberFormat的类使用静态工厂方法来构造对象。</p>
<p>为什么NumberFormat类不利用构造器完成这些操作呢？有两个原因</p>
<ul>
<li>无法命名构造器。构造器的名字必须与类名相同。</li>
<li>当使用构造器时，无法改变所构造的对象类型。而Factory方法将返回一个DecimalFormat类对象，这是NumberFormat的子类。</li>
</ul>
<p><strong>main方法</strong></p>
<p>需要注意，不需要使用对象调用静态方法。例如，不需要构造Math类对象就可以调用Math.pow。</p>
<p>同理，main方法也是一个静态方法。</p>
<p>main方法不对任何对象进行操作。事实上，在启动程序时还没有任何一个对象。静态的main方法将执行并创建程序所需要的对象。</p>
<p>每一个类都可以有一个main方法。这是一个常用于对类进行单元测试的技巧。</p>
<p><strong>方法参数</strong></p>
<p>Java程序设计语言总是采用按值调用。也就是说，方法得到的时所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。如</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">double</span> percent <span style="color:#f92672">=</span>10<span style="color:#f92672">;</span>
harry<span style="color:#f92672">.</span><span style="color:#a6e22e">raiseSalary</span><span style="color:#f92672">(</span>percent<span style="color:#f92672">);</span>
</code></pre></div><p>调用这个方法之后，percent值还是10.</p>
<p>局部变量方法结束后不再使用。</p>
<p>方法参数有两种基本类型：</p>
<ul>
<li>基本数据类型</li>
<li>对象引用</li>
</ul>
<p>Java程序对对象采用的不是引用调用，实际上，对象引用是按值传递的。</p>
<p>一个方法不能修改一个基本数据类型的参数。（即数值型或布尔型）</p>
<p>一个方法可以改变对象参数的状态。</p>
<p>一个方法不能让对象参数引用一个新的对象。</p>
<p>如果传入的是对象类型的参数，则可以通过对象引用的拷贝修改所引用的对象状态。</p>
<p><strong>对象构造</strong></p>
<p>Java提供了多种编写构造器的机制。以下是对这些机制的详细介绍。构造器的目标就是对域值进行初始化。创造不同域值的各种对象。</p>
<p>域值包括，数值型数据，布尔型数据以及对象引用。</p>
<p><em><strong>1.重载</strong></em></p>
<p>有些类有多个构造器。例如，可以如下构造一个空的StringBuilder对象：</p>
<pre><code>StringBuilder messages=new StringBuilder();
</code></pre><p>或者，可以指定一个初始字符串：</p>
<pre><code>StringBuilder todoList=new StringBuilder(&quot;To do:\n&quot;);
</code></pre><p>这种特征叫做重载。如果多个方法有相同的名字、不同的参数，便产生了重载。编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。如果编译器找不到匹配的参数，就会产生编译时错误，因为根本不存在匹配，或者没有一个比其他的更好。（这个过程被称为重载接续）</p>
<p>Java允许重载任何方法，而不只是构造器方法。</p>
<p>因此要完整的描述与i个方法需要指出方法名以及参数类型。这叫做方法的签名。</p>
<p>返回类型不是方法签名的一部分。也就是说，不能有两个名字相同、参数类型也相同却返回不同类型值的方法。</p>
<p>方法名加方法参数唯一确定一个方法</p>
<p><em><strong>2.默认域初始化</strong></em></p>
<p>如果在构造器中没有显式地给域赋予初值，呢么就会被自动地赋为默认值：数值为0、布尔值为false、对象引用为null。</p>
<p>必须明确地初始化方法中的局部变量。但是，如果没有初始化类中的域，将会被自动初始化为默认值（0、false或null）。这是域和局部变量的主要不同点。也就是说局部变量必须手动初始化。</p>
<p><em><strong>3.无参数构造器</strong></em></p>
<p>很多类都包含一个无参数的构造函数，对象由无参数构造器函数创建时，其状态会设置为适当的默认值。</p>
<p>如果在编写一个类时没有编写构造器，那么系统就会提供一个无参数构造器。这个构造器将所有的实例域设置为默认值。于是，实例域中的数值型数据设置为0，布尔值数据设置为false，所有对象变量将设置为null。</p>
<p>如果类中提供了至少一个构造器，但是没有提供无参数的构造器，则在构造对象时如果没有提供参数就会被视为不合法。（有参构造会覆盖无参构造）。</p>
<p>要想同时使用有参无参，就把它们都进行定义。否则要不就是有参，又不没有定义就是无参。</p>
<p><em><strong>4.显式域初始化</strong></em></p>
<p>通过重载类的构造器方法，可以采用多种形式设置类的实例域的初始状态。确保不管怎样调用构造器，每个实例域都可以被设置为一个有意义的初值</p>
<p>在执行构造器之前，先进行赋值操作。当一个类的所有构造器都希望把相同的值赋予某个特定的实例域时，特别有用。</p>
<p>初始值不一定是常量值。可以调用方法对域进行初始化。每个雇员有一个id域，可与i使用下列方法进行初始化：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Employee</span><span style="color:#f92672">{</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> nextId<span style="color:#f92672">;</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> id<span style="color:#f92672">=</span>assignId<span style="color:#f92672">();</span>
<span style="color:#f92672">...</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">assignId</span><span style="color:#f92672">(){</span>
<span style="color:#66d9ef">int</span> r<span style="color:#f92672">=</span> nextId<span style="color:#f92672">;</span>
nextId<span style="color:#f92672">++;</span>
<span style="color:#66d9ef">return</span> r<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
<span style="color:#f92672">...</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><em><strong>5.参数名</strong></em></p>
<p>在编写很小的构造器时，常常在参数命名上出现错误。比如说参数用单个字符命名。这样做有一个缺陷：”只有阅读代码才能够了解参数n和参数s的含义。有些程序员在每个参数前面加上一个前缀&rsquo;a&rsquo;:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Employee</span> <span style="color:#f92672">(</span>String aName<span style="color:#f92672">,</span><span style="color:#66d9ef">double</span> aSalary<span style="color:#f92672">)</span>
<span style="color:#f92672">{</span>
	name<span style="color:#f92672">=</span>aName<span style="color:#f92672">;</span>
	salary<span style="color:#f92672">=</span>aSalary<span style="color:#f92672">;</span>	
<span style="color:#f92672">}</span>
</code></pre></div><p>还有一种常用的技巧，参数变量用同样的名字将实例域屏蔽起来。例外，如果将参数命名为salary，salary将引用这个参数，而不是实例域。但是，可以采用this.salary的形式访问实例域。this指示隐式参数，也就是所构造的对象。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Employee</span><span style="color:#f92672">(</span>String name<span style="color:#f92672">,</span><span style="color:#66d9ef">double</span> salary<span style="color:#f92672">)</span>
<span style="color:#f92672">{</span>
	<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">name</span><span style="color:#f92672">=</span>name<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">salary</span><span style="color:#f92672">=</span>salary<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><em><strong>6.调用另一个构造器</strong></em></p>
<p>关键字this引用方法的隐式参数。然而这个关键字还有另外一个含义。</p>
<p>如果构造器的第一个语句形如this（&hellip;）,这个构造器将调用同一个类的另一个构造器</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Employee</span><span style="color:#f92672">(</span><span style="color:#66d9ef">double</span> s<span style="color:#f92672">)</span>

<span style="color:#f92672">{</span>

<span style="color:#66d9ef">this</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Employee #&#34;</span><span style="color:#f92672">+</span>nextId<span style="color:#f92672">,</span>s<span style="color:#f92672">);</span>

nextId<span style="color:#f92672">++;</span>

<span style="color:#f92672">}</span>

</code></pre></div><p>当调用new Emplyee(60000)时，Employee(double)构造器将调用Employee（String,double）构造器。</p>
<p>采用这种方式使用this关键字非常有用，这样对公共的构造器代码部分值编写一部分即可。</p>
<p>不能用类名调用构造器，只能使用this调用，最后会先返回一个新的构造对象（方法体里面的对象）。 然后返回外层构造器的对象。</p>
<p><em><strong>7.初始化块</strong></em></p>
<p>有两种初始化数据域的方法：</p>
<ul>
<li>在构造器中设置值</li>
<li>在声明中赋值</li>
</ul>
<p>实际上，Java还有第三种机制，称为初始化块。在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">{</span>
id<span style="color:#f92672">=</span>nextId
nextId<span style="color:#f92672">++</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这种机制不是必需的，也不常见。通常会直接将初始化代码放在构造器中。</p>
<p>构造过程具体运行顺序：</p>
<p>1.所有数据域被初始化为默认值（0、false或null）,这个自动初始化仅针对数据域（是全局的），局部变量是需要手动初始化的。</p>
<p>2.按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块。</p>
<p>3.如果构造器第一行调用了第二个构造器，则执行第二个构造器。</p>
<p>4.执行这个构造器主体。</p>
<p>可以把一些所有对象需要的公用部分数据，在数据域或初始化块中被初始化。</p>
<p>然后特殊的对象数据，放在构造器里面根据需要进行初始化。</p>
<p>如果对类的静态域初始化的代码比较复杂，那么可以使用静态的初始化块。如</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">static</span>
<span style="color:#f92672">{</span>
	Random generator <span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> Random<span style="color:#f92672">();</span>
	nextId<span style="color:#f92672">=</span>generator<span style="color:#f92672">.</span><span style="color:#a6e22e">nextId</span><span style="color:#f92672">(</span>10000<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>在类第一次加载的时候，将会进行静态域的初始化。与实例域一样，除非将它们显式地设置成其他值，否则默认的初始值是0、false或null。所有的静态初始化语句以及静态初始化块都将按照类定义的顺序执行。</p>
<p>Java程序首先会检查是否有一个main方法。</p>
<p><strong>对象析构与finalize方法</strong></p>
<p>在析构器中，最常见的操作是回收分配给对象的存储空间。</p>
<p>由于Java有自动的垃圾回收器， 不需要人工回收内存，所以Java不支持析构器。</p>
<p>当然，某些对象使用了内存之外的其他资源，例如，文件或使用了系统资源的另一个对象的句柄。在这种情况下，当资源不再需要时，将其回收和再利用将显得十分重要。</p>
<p>可以为任何一个类添加finalize方法。finalize方法将在垃圾回收期清除对象之前调用。在实际应用中，不要依赖于使用finalize方法回收任何短缺的资源，这是因为很难知道这个方法什么时候才能够调用。</p>
<p>如果某个资源需要在使用完毕后立刻被关闭，那么就需要由人工来管理。对象用完时，可以应用一个close方法来完成相应的清理操作。</p>
<p><strong>包</strong></p>
<p>Java允许使用包将类组织起来。借助于包可以方便地组织自己的代码，并将自己的代码与别人提供的代码库分开管理。</p>
<p>标准的Java类库分布在多个包中，包括java.lang、Java.util和java.net等。标准的Java包具有一个层次结构。如同硬盘的目录嵌套一样，也可以使用嵌套层次组织包。所有标准的Java包都处在java和javax包层次中。使用包的主要原因是确保类名的唯一性。假如两个程序员不约而同地建立了Employee类。只要将这些类放置在不同的包中，就不会产生冲突。</p>
<p>从编译器的角度来看、嵌套的包之间没有任何关系。例如，java.util包与java.util.jar包毫无关系。每一个都拥有独立的类集合。</p>
<p><strong>类的导入</strong></p>
<p>一个类可以使用所属包中的所有类，以及其他包中的公有类。我们可以采用两种方式访问另一个包中的公有类。</p>
<p>第一种方式是在每个类名之前添加完整的包名，这显然很繁。更简单更常用的方式是使用import语句。</p>
<p>一旦使用了import语句，在使用类时，就不必写出包的全名了。</p>
<p>可以使用import语句导入一个特定的类或者整个包。应该位于源文件的顶部。例如：</p>
<pre><code>import java.util.*;
</code></pre><p>或者直接导入特定的类。</p>
<pre><code> import java.time.LocalDate;
</code></pre><p>但是，需要注意的时，只能使用星号（）导入一个包，而不能使用import java.<em>或import java.</em>.*导入以java为前缀的所有包。</p>
<p>在大多数情况下，只导入所需的包，不必过多的理睬它们。</p>
<p>如果有同名的类造成混淆，则导入完整的包名。</p>
<p>import语句的唯一的好处是简捷。可以使用简短的名字而不是完整的包名来引用一个类</p>
<p><strong>静态导入</strong></p>
<p>import语句不仅可以导入类，还增加了导入静态方法和静态域的功能。</p>
<p>例如，如果在源文件的顶部，添加一条指令：</p>
<p>import static Java.lang.System.*;</p>
<p>就可以使用System类的静态方法和静态域，而不必加类名前缀：</p>
<pre><code>out.println（&quot;Goodbye,world!&quot;）;
exit(0);
</code></pre><p>另外，还可以导入特定的方法或域：</p>
<pre><code>import static java.lang.System.out;
</code></pre><p>在包中定位类是编译器的工作。类文件中的字节码肯定使用完整的包名来引用其他类。</p>
<p><strong>将类放入包中</strong></p>
<p>要想将类放入包中，就必须将包的名字放在源文件的开头，保证定义类的代码之前。例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">package</span> com.horstmann.corejava<span style="color:#f92672">;</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Employee</span><span style="color:#f92672">{</span>
	<span style="color:#f92672">...</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>如果没有在源文件中放置package语句，这个源文件中的类就被放置在一个默认包中。默认包是一个没有名字的包。在此之前，我们定义的所有类都在默认包中。</p>
<p>将包中的文件放到与完整的包名相匹配的子目录中。例如，com.horstmann.corejava包中所有的源文件应该被放置在子目录com/horstmann/corejava中。编译器将类文件也放在相同的目录结构中。编译基目录，所有子目录的也将被编译。</p>
<p>需要从基目录编译和运行类。</p>
<p>需要注意，编译器对文件进行操作。而java解释器加载类。</p>
<p>编译器在编译源文件的时候不检查目录结构。即使源文件没有在子目录下，也可以进行编译。但是如果不依赖于其他包，就不会出现编译错误。但是，最终的出现将无法运行，除非先将所有类文件移到正确的位置上。如果包与目录不匹配，虚拟机就找不到类。</p>
<p><strong>访问修饰符作用域</strong></p>
<p>public——可以被任意类使用</p>
<p>private——只能被定义它们的类使用</p>
<p>default——可以被同一个包中的所有方法访问</p>
<p>可以通过包密封的机制来解决将各种包混杂在一起的问题。如果将一个包密封起来，就不能再向这个包中添加类了。</p>
<p><strong>类路径</strong>（为编译器定位类提供起点）</p>
<p>类存储在文件系统的子目录中。类的路径必须与包名匹配。</p>
<p>类文件也可以存储在JAR文件中。在一个JAR（Java归档）文件中，可以包含多个压缩形式的类文件和子目录，这样既可以节省又可以改善性能。在程序中用到第三方的库文件时，通常会给出一个或多个需要包含的JAR文件。JDK也提供了许多的JAR文件，例如，在jre/lib/rt.jar中包含数千个类库文件。</p>
<p>JAR文件使用ZIP格式组织文件和子目录。可以使用所有ZIP实用程序查看内部的rt,jar以及其他的JAR文件。</p>
<p>为了使类能被多个程序共享，需要做到下面几点：</p>
<p>1.把类放到一个目录中</p>
<p>2.将JAR文件放在一个目录中</p>
<p>3.设置类路径。类路径是所有包含类文件的路径的集合</p>
<p>类路径包括</p>
<ul>
<li>基目录/home/user/classdir或c:\classes</li>
<li>当前目录（.）;</li>
<li>JAR文件/home/user/archives.jar或c:\archives\archive.jar</li>
</ul>
<p>由于运行时库文件（rt.jar和在jre/lib与jre/lib/ext目录下的一些其他的JAR文件）会被自动的搜索，所以不必将它们显式地列在类路径中。</p>
<p>javac编译器总是在当前的目录中查找文件，但Java虚拟机仅在类路径有”.&ldquo;目录的时候才查看当前目录。如果没有设置类路径，那也并不会产生什么问题，默认的类路径包含”.&ldquo;目录。然而如果设置了类路径却忘记包含”.“目录，则程序仍然可以通过编译，但是不能运行。</p>
<p>类路径所列出的目录和归档文件是搜寻类的起始点。</p>
<p>编译器定位文件要比虚拟机复杂得多。如果引用一个类，而没有指出这个类所在的包，那么编译器将首先查找包含这个类的包，并询查所以的import指令，确定其中是否包含了被引用的类。</p>
<p>编译器对类路径的所有位置中所列出的每一个类进行逐一查看。如果找到了一个以上的类，就会产生编译错误（因为类必须是唯一的，而import语句的次序却无关紧要）。</p>
<p>编译器的任务不止这些，它还要查看源文件是否比类文件（字节码文件）新。如果是这样的话，那么源文件就会被自动的重新编译。</p>
<p>仅可以导入其他包中的公有类。一个源文件只能包含一个公有类，并且文件名必须与公有类匹配。因此，编译器很容易定位公有类所在的源文件。当然，也可以从当前包中导入非公有类（default）。这些类有可能定义在与类名不同的源文件中。如果从当前包中导入一个类，编译器就要搜索当前包中的所有源文件，以便确定哪个源文件定义了这个类。</p>
<p>源文件必须与公有类匹配，非公有类可能定义在与类名不同的源文件。</p>
<p><strong>设置类路径</strong></p>
<p>用java -classpath或（-cp）指定类路径</p>
<p>整个指令应该书写在一行中。将这样一个长的命令行放在一个shell脚本或一个批处理文件中是一个不错的主意。</p>
<p>利用-classpath选项设置类路径是首选的方法，也可以提供设置CLASSPATH环境变量完成这个操作。</p>
<p><strong>文档注释</strong></p>
<p>JDK包含一个很有用的工具，叫做javadoc，它可以由源文件生成一个HTML文档。</p>
<p>如果将注释文档存入一个独立的文件中，就有可能会随着时间的推移，出现代码和注释不一致的问题。然而，由于文档注释与源代码在同一个文件中，在修改源代码的同时，重新运行javadoc就可以轻而易举地保持两者的一致性。</p>
<p><strong>注释的插入</strong></p>
<p>javadoc实用程序从下面几个特性抽取信息：</p>
<ul>
<li>包</li>
<li>公有类与接口</li>
<li>公有的和受保护的构造器和方法</li>
<li>公有的和受保护的域</li>
</ul>
<p>应该为上面几部分编写注释。注释应该放置在所描述特性的前面。注释以/*<em><em>开始，并以</em>、</em>/结束。</p>
<p>每个/******<em>..</em>/文档在标记之后紧跟着自由格式文本。标记由@开始。</p>
<p>自由文本的第一句应该是一个概要性的句子。javadoc实用程序自动地将这些句子抽取出来形成概要页。</p>
<p><strong>类注释</strong></p>
<p>类注释必须放在import语句之后，类定义之前。注意没有必要在注释的每一行的开始用星号*。</p>
<p><strong>方法注释</strong></p>
<p>每一个方法注释必须放在所描述的方法之前。除了通用标记之外，还可以使用下面的标记：@param代表变量描述</p>
<p>@return代表返回标记 @throws代表类描述</p>
<p><strong>域注释</strong></p>
<p>只需要对公有域（通常是静态常量）建立文档</p>
<p><strong>通用文档</strong></p>
<p>注释里一定要使用#号，不要使用句号.分隔类名和方法名。</p>
<p><strong>包与概述注释</strong></p>
<p>可以直接将类、方法和变量的注释放置在Java源文件中，只要用文档注释进行界定就可以了。但是，要想产生保住是，就需要在每一个包目录中添加一个单独的文件。提供一个以package.html命名的HTML文件。在标记<!-- raw HTML omitted -->&hellip;<!-- raw HTML omitted -->之间的所有文本都会被抽取出来。</p>
<p>提供一个以package-info.java命名的Java文件。这个文件必须包含一个初始的以/*<em>和</em>/界定的doc注释，跟随在一个包语句之后。它不应该包含更多的代码或注释。</p>
<p>还可以为所有的源文件提供一个概述性的注释。这个注释被放置在一个名为overview.html的文件中，这个文件位于包含所有源文件的父目录中，这个文件位于包含所有源文件的父目录中。标记<!-- raw HTML omitted -->&hellip;<!-- raw HTML omitted -->之间的所有文本都将被抽取出来。当用户从导航栏中选择”Overview“时，就会显示出这些注释内容。</p>
<p><strong>注释的抽取</strong></p>
<p>·这里，假设HTML文件将被存放在目录docDirectory下</p>
<p>1.切换到包含想要生成文档的源文件目录。如果有嵌套的包要生成文档，就必须切换到包含子目录com的目录（如果存在overview.html文件的话，这也是它的所在目录）。</p>
<p>2.如果是一个包，应该运行命令：</p>
<p>javadoc -d docDirectory 包名</p>
<p>或多个包</p>
<p>javadoc -d docDirectory 包名1 包名2</p>
<p>如果文件在默认包中，就应该运行：</p>
<p>javadoc -d docDirectory  *.java</p>
<p>如果使用-linksopurce选项，则每个源文件被转换为HTML，并且每个类和方法名将转变为指向源代码的超链接。</p>
<p><strong>类设计技巧</strong></p>
<p><em><strong>1.一定要保证数据私有</strong></em></p>
<p>这是最重要;绝对不要破坏封装性。有时候，需要编写一个访问器方法或更改器方法。但是最好还是保持实例域的私有性。很多惨痛的经验告诉我们，数据的表示形式很可能会改变，但它们的使用方式却不会经常发生变化。当数据保持私有时，它们的表示形式的变化不会对类的使用者产生影响，即使出现bug也易于检测。</p>
<p><em><strong>2.一定要对数据初始化</strong></em></p>
<p>Java不对局部变量进行初始化，但是会对对象的实例域进行初始化。最好不要依赖于系统的默认值，而是应该显式地初始化所有的数据，具体的初始化方式可以是提供默认值，也可以是在所有构造器中设置默认值。</p>
<p><em><strong>3.不要在类中使用过多的基本类型</strong></em></p>
<p>就是说，尽量用其他的类代替多个相关的基本类型的使用。这样会使类更加易于理解且易于修改。例如，用一个称为Address的新的类替换一个Customer类中以下的实例域：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> String street<span style="color:#f92672">;</span>
<span style="color:#66d9ef">private</span> String city<span style="color:#f92672">;</span>
<span style="color:#66d9ef">private</span> String state<span style="color:#f92672">;</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> zip<span style="color:#f92672">;</span>
</code></pre></div><p>这样可以很容易处理地址的变化，例如需要增加对国际地址的处理</p>
<p><em><strong>4.不是所有的域都需要都需要独立的域访问器和域更改器</strong></em></p>
<p>或许，需要获得或设置雇员的薪金。而一旦构造了雇员对象，就应该禁止更改雇用日期，并且在对象中，常常包含一些不希望别人获得或设置的实例域，例如，在Address类中，存放州缩写的数组。</p>
<p><em><strong>5.将职责过多的类进行分解</strong></em></p>
<p>如果明显可以将一个复杂的类分解成两个更为简单的类，就应该将其分解。</p>
<p><em><strong>6.类名和方法名要能够体现它们的职责</strong></em></p>
<p>命名类名的良好习惯是采用一个名词、前面有形容词修饰的名词或动名词修饰名词。对于方法来说，习惯是访问器方法用小写的get开头,更改器方法用小写的set方法开头。</p>
<p><em><strong>7.优先使用不可变的类</strong></em></p>
<p>LocalDate类以及java.time包中的其他类是不可变的——没有方法能修改对象的状态。类似plusDays的方法并不是更改对象，而是返回状态已修改的新对象。</p>
<p>更改对象的问题在于，如果多个线程试图同时更新一个对象，就会发生并发更改。其结果是不可预料的。如果类是不可变的，就可以安全地在多个线程间共享其对象。</p>
<p>因此，要尽可能让类不可变的，这是一个很好的想法。对于表示值的类，如一个字符串或一个时间点，这尤其容易。计算会生成新值，而不是更新原来的值。</p>
<p>当然，并不是所有类都应当是不可变的。如果员工加薪时让raiseSalary方法返回一个新的Employee对象，这会很奇怪。</p>

    </div>
    <div class="post-footer">
      
    </div>
    <div class="post-comment">
      
      


<span id="/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/" class="leancloud_visitors" data-flag-title="Java核心技术第四章笔记-对象和类">
    <span class="post-meta-item-text">文章阅读量 </span>
    <span class="leancloud-visitors-count">1000000</span>
    <p></p>
  </span>
<div id="vcomments"></div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script type="text/javascript">
  new Valine({
    el: '#vcomments' ,
    appId: 'cScQmclMsD4OOWCclCP1pNsz-gzGzoHsz',
    appKey: 'dtSaHLmdH3J4ICVVInYg9YFM',
    notify:  false ,
  verify:  false ,
  avatar:'mm',
    placeholder: '说点什么吧...',
    visitor:  true 
  });
</script>

    </div>
  </article>

    </main>
  </body>
</html>
