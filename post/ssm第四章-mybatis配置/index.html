<!doctype html>
<html lang="en-us">
  <head>
    <title>SSM第四章-MyBatis配置 // Zereal-宋致远技术博客</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.72.0" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75，minimum-scale=0.75, maximum-scale=0.75, user-scalable=no" />
    <meta name="author" content="Zereal" />
    <meta name="description" content="" />
    <meta name="referrer" content="never"/>
    <link rel="stylesheet" href="https://zereals7.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="SSM第四章-MyBatis配置"/>
<meta name="twitter:description" content="4.1 概述 MyBatis配置文件不复杂
配置文件元素
&lt;configuration&gt;配置&lt;properties/&gt;属性&lt;setting/s&gt;设置&lt;typeAliases/&gt;类型别名&lt;typeHandlers/&gt;类型处理器&lt;objectFactory/&gt;对象工厂&lt;plugins&gt;插件&lt;environments&gt;配置环境&lt;environment&gt;环境变量&lt;transactionManager&gt;事务管理器&lt;dataSource&gt;数据源&lt;/environment&gt;&lt;/environments&gt;&lt;databaseIdProvider/&gt;数据库厂商标识&lt;mappers&gt;映射器&lt;/configuration&gt;需要注意配置的顺序不能颠倒。顺序错了，启动阶段就会发生异常，导致程序无法运行。
4.2 properties属性 properties属性可以给系统配置一些运行参数，可以放在XML文件或者 properties文件中，而不是放在Java编码中，这样的好处在于方便参数修改，不会引起代码重新编译。
可以使用元素 properties下的 propertie子元素定义。比如通过
,可以定义数据库的驱动，然后可以通过${database.driver},定义一次，到处引用。如果属性参数有成百上千个，可以使用properties文件。
使用properties文件是比较普遍的方法，一方面这个文件十分简单，其逻辑就是键值对应，我们可以配置多个键值放在一个properties文件中，也可以把多个键值对放在多个properties文件中，这些都是允许的，它方便日后维护和修改。
在MyBatis中通过properties的属性resource来引入properties文件。
&lt;properties resource=&#34;jdbc.properties&#34;/&gt; 也可以按${database.username}的方法引入properties文件的属性参数到MyBatis配置文件中。这个时候通过维护properties文件就可以维护我们的配置内容了。
在真实的生产环境中，数据库的用户密码是对开发人员和其他人员保密的。运维人员为了保密，一般都需要把用户和密码经过加密成为密文后，配置到properties文件中。对于开发人员及其他人员而言，就不知道其真实的用户密码了，数据库也不可能用以及加密的字符串去连接，此时往往需要通过解密才能得到真实的用户和密码了。现在假设系统已经为提供了这样的一个CodeUtils.decode(str)进行解密，那么我们在创建SqlSessionFactory前，就需要把用户名和密码解密，然后把解密后的字符串重置到properties属性中。
首先使用Resources对象读取了一个jdbc.properties配置文件，然后获取了它原来配置的用户和密码，进行解密并重置，最后使用SqlSessionFactoryBuilder的build方法，传递多个properties参数来完成。这将覆盖之前配置的密文，这样就能连接数据库了，同时也满足了运维人员对数据库用户和密码安全的要求。
总结：以上是MyBatis使用properties的3种方式。这3种方式是有优先级的，最优先的是使用程序传递的方式，其次是使用properties文件的方式，最后使用子元素的方式。MyBatis会根据优先级来覆盖原先配置的属性值。
建议采用properties文件的方式，因为管理它简单易行，而且可以从XML文件中剥离出来独立维护。
4.3 settings设置 settings是MyBatis中最复杂的配置，它能深刻影响MyBatis底层的运行，但大部分情况下使用默认值便可以运行，所以大部分情况下不需要大量配置它，只需要修改一些常用的规则即可，比如自动映射、驼峰命名映射、级联规则、是否启动缓存、执行器类型等。
settings的配置项很多，但是真正用到的不会太多，我们把常用的配置项研究清楚就可以了，比如关于缓存的CacheEnabled,关于级联的LazyloadingEnabled和aggressiveLazyLoading,关于自动映射的autoMappingBehavior和mapUnderscoreToCamelCase,关于执行器类型的defaultExecutorType等。
4.4 typeAliases别名 由于类的全限定名很长，需要大量使用的时候，写那么长的名称不方便。在MyBatis中允许定义一个简写来代表这个类，这就是别名，别名分为系统定义别名和自定义别名。在MyBatis中别名由类TypeAliasRegistry去定义。注意，在MyBatis中别名不区分大小写。
MyBatis也提供了用户自定义别名的规则。我们可以通过TypeAliasRegistry类的registerAlias方法注册，也可以采用配置文件或者扫描方式来自定义它。
使用配置文件定义很简单：
&lt;typeAliases&gt; &lt;typeAliases alias=&#34;role&#34; type=&#34;com.leartn.ssmchapter4.pojo.Role&#34;/&gt; &lt;typeAliases alias=&#34;user&#34; type=&#34;com.learn.ssm.chapter4.pojo.User&#34;/&gt; &lt;/typeAliases&gt; 这样就可以定义一个别名了。如果由很多类需要定义别名，那么用这样的方式进行配置可就不那么轻松了。MyBatis还支持扫描别名。比如上面的两个类都在包com.learn.ssm.chapter4.pojo之下，那么就可以定义为：
&lt;typeAliases&gt; &lt;package name=&#34;com.learn.ssm.chapter4.pojo&#34;/&gt; &lt;typeAliases&gt; 这样MyBatis将扫描这个包里面的类，将其第一个字母变为小写作为其别名，比如类Role的别名会变成role，而User的别名会变成user。使用这样的规则有时候会出现重名，这个时候可以使用MyBatis提供的直接@Alias来进行区分。
这样就能够避免因为别名重名导致的扫描失败的问题。
4.5 typeHandler类型转换器 在JDBC中，需要在PreparedStatement对象中设置那些已经预编译过的SQL语句的参数。执行SQL后，会通过ResultSet对象获取得到数据库的数据，而这些MyBatis是根据数据的类型typeHandler来实现的。在typeHandler中，分为jdbcType和javaType,其中jdbcType用于定义数据库类型，而javaType用于定义Java类型，那么typeHandler的作用就是承担jdbcType和iavaType之间的相互转换。在很多情况下我们并不需要去配置typeHandler、jdbcType、javaType,因为MyBatis会探测应该使用什么类型的typeHandler进行处理，但是有些场景无法探测到。对于那些需要使用自定义枚举的场景，或者数据库使用特殊数据类型的场景，可以使用自定义的typeHandler去处理类型之间的转换问题。
和别名一样，在MyBatis中存在系统定义typeHandler和自定义typeHandler。MyBatis会根据javaType和数据库的jdbcType来决定采用哪个typeHandler处理这些转换规则。系统提供的typeHandler能覆盖大部分场景的要求，但是有些情况下是不够的，比如我们由特殊的转换规则，枚举类就是这样。
总之，typeHandler负责jdbcType和javaType之间的相互转换。
在大部分的情况下无须显式地声明jdbcType和javaType，或者用typeHandler去指定对应的typeHandler来实现数据类型转换，因为MyBatis系统会自己探测。有时候需要修改一些转换规则，比如枚举类往往需要自己去编写规则。
typeHandler继承了BaseTypeHandler
 BaseTypeHandler是个抽象类，需要子类去实现其定义的4个抽象方法，而它本身实现类typeHandler接口的4个方法。 getResult方法，非空结果集是通过getNullableResult方法获取的。如果判断为空，则返回null。 setParameter方法，当参数parameter和jdbcType同时为空时，MyBatis将抛出异常，如果能明确jdbcType,则会进行空设置；如果参数不为空，那么它将采用setNonNullParameter方法设置参数。 getNullableResult方法用于存储过程。  MyBatis使用最多的typeHandler之一——StringTypeHandler。它用于字符串转换。它实现类BaseTypeHandler的4个抽象方法。"/>

    <meta property="og:title" content="SSM第四章-MyBatis配置" />
<meta property="og:description" content="4.1 概述 MyBatis配置文件不复杂
配置文件元素
&lt;configuration&gt;配置&lt;properties/&gt;属性&lt;setting/s&gt;设置&lt;typeAliases/&gt;类型别名&lt;typeHandlers/&gt;类型处理器&lt;objectFactory/&gt;对象工厂&lt;plugins&gt;插件&lt;environments&gt;配置环境&lt;environment&gt;环境变量&lt;transactionManager&gt;事务管理器&lt;dataSource&gt;数据源&lt;/environment&gt;&lt;/environments&gt;&lt;databaseIdProvider/&gt;数据库厂商标识&lt;mappers&gt;映射器&lt;/configuration&gt;需要注意配置的顺序不能颠倒。顺序错了，启动阶段就会发生异常，导致程序无法运行。
4.2 properties属性 properties属性可以给系统配置一些运行参数，可以放在XML文件或者 properties文件中，而不是放在Java编码中，这样的好处在于方便参数修改，不会引起代码重新编译。
可以使用元素 properties下的 propertie子元素定义。比如通过
,可以定义数据库的驱动，然后可以通过${database.driver},定义一次，到处引用。如果属性参数有成百上千个，可以使用properties文件。
使用properties文件是比较普遍的方法，一方面这个文件十分简单，其逻辑就是键值对应，我们可以配置多个键值放在一个properties文件中，也可以把多个键值对放在多个properties文件中，这些都是允许的，它方便日后维护和修改。
在MyBatis中通过properties的属性resource来引入properties文件。
&lt;properties resource=&#34;jdbc.properties&#34;/&gt; 也可以按${database.username}的方法引入properties文件的属性参数到MyBatis配置文件中。这个时候通过维护properties文件就可以维护我们的配置内容了。
在真实的生产环境中，数据库的用户密码是对开发人员和其他人员保密的。运维人员为了保密，一般都需要把用户和密码经过加密成为密文后，配置到properties文件中。对于开发人员及其他人员而言，就不知道其真实的用户密码了，数据库也不可能用以及加密的字符串去连接，此时往往需要通过解密才能得到真实的用户和密码了。现在假设系统已经为提供了这样的一个CodeUtils.decode(str)进行解密，那么我们在创建SqlSessionFactory前，就需要把用户名和密码解密，然后把解密后的字符串重置到properties属性中。
首先使用Resources对象读取了一个jdbc.properties配置文件，然后获取了它原来配置的用户和密码，进行解密并重置，最后使用SqlSessionFactoryBuilder的build方法，传递多个properties参数来完成。这将覆盖之前配置的密文，这样就能连接数据库了，同时也满足了运维人员对数据库用户和密码安全的要求。
总结：以上是MyBatis使用properties的3种方式。这3种方式是有优先级的，最优先的是使用程序传递的方式，其次是使用properties文件的方式，最后使用子元素的方式。MyBatis会根据优先级来覆盖原先配置的属性值。
建议采用properties文件的方式，因为管理它简单易行，而且可以从XML文件中剥离出来独立维护。
4.3 settings设置 settings是MyBatis中最复杂的配置，它能深刻影响MyBatis底层的运行，但大部分情况下使用默认值便可以运行，所以大部分情况下不需要大量配置它，只需要修改一些常用的规则即可，比如自动映射、驼峰命名映射、级联规则、是否启动缓存、执行器类型等。
settings的配置项很多，但是真正用到的不会太多，我们把常用的配置项研究清楚就可以了，比如关于缓存的CacheEnabled,关于级联的LazyloadingEnabled和aggressiveLazyLoading,关于自动映射的autoMappingBehavior和mapUnderscoreToCamelCase,关于执行器类型的defaultExecutorType等。
4.4 typeAliases别名 由于类的全限定名很长，需要大量使用的时候，写那么长的名称不方便。在MyBatis中允许定义一个简写来代表这个类，这就是别名，别名分为系统定义别名和自定义别名。在MyBatis中别名由类TypeAliasRegistry去定义。注意，在MyBatis中别名不区分大小写。
MyBatis也提供了用户自定义别名的规则。我们可以通过TypeAliasRegistry类的registerAlias方法注册，也可以采用配置文件或者扫描方式来自定义它。
使用配置文件定义很简单：
&lt;typeAliases&gt; &lt;typeAliases alias=&#34;role&#34; type=&#34;com.leartn.ssmchapter4.pojo.Role&#34;/&gt; &lt;typeAliases alias=&#34;user&#34; type=&#34;com.learn.ssm.chapter4.pojo.User&#34;/&gt; &lt;/typeAliases&gt; 这样就可以定义一个别名了。如果由很多类需要定义别名，那么用这样的方式进行配置可就不那么轻松了。MyBatis还支持扫描别名。比如上面的两个类都在包com.learn.ssm.chapter4.pojo之下，那么就可以定义为：
&lt;typeAliases&gt; &lt;package name=&#34;com.learn.ssm.chapter4.pojo&#34;/&gt; &lt;typeAliases&gt; 这样MyBatis将扫描这个包里面的类，将其第一个字母变为小写作为其别名，比如类Role的别名会变成role，而User的别名会变成user。使用这样的规则有时候会出现重名，这个时候可以使用MyBatis提供的直接@Alias来进行区分。
这样就能够避免因为别名重名导致的扫描失败的问题。
4.5 typeHandler类型转换器 在JDBC中，需要在PreparedStatement对象中设置那些已经预编译过的SQL语句的参数。执行SQL后，会通过ResultSet对象获取得到数据库的数据，而这些MyBatis是根据数据的类型typeHandler来实现的。在typeHandler中，分为jdbcType和javaType,其中jdbcType用于定义数据库类型，而javaType用于定义Java类型，那么typeHandler的作用就是承担jdbcType和iavaType之间的相互转换。在很多情况下我们并不需要去配置typeHandler、jdbcType、javaType,因为MyBatis会探测应该使用什么类型的typeHandler进行处理，但是有些场景无法探测到。对于那些需要使用自定义枚举的场景，或者数据库使用特殊数据类型的场景，可以使用自定义的typeHandler去处理类型之间的转换问题。
和别名一样，在MyBatis中存在系统定义typeHandler和自定义typeHandler。MyBatis会根据javaType和数据库的jdbcType来决定采用哪个typeHandler处理这些转换规则。系统提供的typeHandler能覆盖大部分场景的要求，但是有些情况下是不够的，比如我们由特殊的转换规则，枚举类就是这样。
总之，typeHandler负责jdbcType和javaType之间的相互转换。
在大部分的情况下无须显式地声明jdbcType和javaType，或者用typeHandler去指定对应的typeHandler来实现数据类型转换，因为MyBatis系统会自己探测。有时候需要修改一些转换规则，比如枚举类往往需要自己去编写规则。
typeHandler继承了BaseTypeHandler
 BaseTypeHandler是个抽象类，需要子类去实现其定义的4个抽象方法，而它本身实现类typeHandler接口的4个方法。 getResult方法，非空结果集是通过getNullableResult方法获取的。如果判断为空，则返回null。 setParameter方法，当参数parameter和jdbcType同时为空时，MyBatis将抛出异常，如果能明确jdbcType,则会进行空设置；如果参数不为空，那么它将采用setNonNullParameter方法设置参数。 getNullableResult方法用于存储过程。  MyBatis使用最多的typeHandler之一——StringTypeHandler。它用于字符串转换。它实现类BaseTypeHandler的4个抽象方法。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zereals7.github.io/post/ssm%E7%AC%AC%E5%9B%9B%E7%AB%A0-mybatis%E9%85%8D%E7%BD%AE/" />
<meta property="article:published_time" content="2021-04-19T01:38:36+08:00" />
<meta property="article:modified_time" content="2021-04-19T01:38:36+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://zereals7.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="Zereal" /></a>
      <h1>Zereal</h1>
      <p>Java coder</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/ZerealS7" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">SSM第四章-MyBatis配置</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Apr 19, 2021
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div></div>
    </header>
    <div class="post-content">
      <h1 id="41-概述">4.1 概述</h1>
<p>MyBatis配置文件不复杂</p>
<p>配置文件元素</p>
<pre><code>&lt;configuration&gt;配置
&lt;properties/&gt;属性
&lt;setting/s&gt;设置
&lt;typeAliases/&gt;类型别名
&lt;typeHandlers/&gt;类型处理器
&lt;objectFactory/&gt;对象工厂
&lt;plugins&gt;插件
&lt;environments&gt;配置环境
&lt;environment&gt;环境变量
&lt;transactionManager&gt;事务管理器
&lt;dataSource&gt;数据源
&lt;/environment&gt;
&lt;/environments&gt;
&lt;databaseIdProvider/&gt;数据库厂商标识
&lt;mappers&gt;映射器
&lt;/configuration&gt;
</code></pre><p>需要注意配置的顺序不能颠倒。顺序错了，启动阶段就会发生异常，导致程序无法运行。</p>
<h1 id="42-properties属性">4.2 properties属性</h1>
<p>properties属性可以给系统配置一些运行参数，可以放在XML文件或者 properties文件中，而不是放在Java编码中，这样的好处在于方便参数修改，不会引起代码重新编译。</p>
<p>可以使用元素 properties下的 propertie子元素定义。比如通过</p>
<p><!-- raw HTML omitted -->,可以定义数据库的驱动，然后可以通过${database.driver},定义一次，到处引用。如果属性参数有成百上千个，可以使用properties文件。</p>
<p>使用properties文件是比较普遍的方法，一方面这个文件十分简单，其逻辑就是键值对应，我们可以配置多个键值放在一个properties文件中，也可以把多个键值对放在多个properties文件中，这些都是允许的，它方便日后维护和修改。</p>
<p>在MyBatis中通过properties的属性resource来引入properties文件。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>properties resource<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;jdbc.properties&#34;</span><span style="color:#f92672">/&gt;</span>
</code></pre></div><p>也可以按${database.username}的方法引入properties文件的属性参数到MyBatis配置文件中。这个时候通过维护properties文件就可以维护我们的配置内容了。</p>
<p>在真实的生产环境中，数据库的用户密码是对开发人员和其他人员保密的。运维人员为了保密，一般都需要把用户和密码经过加密成为密文后，配置到properties文件中。对于开发人员及其他人员而言，就不知道其真实的用户密码了，数据库也不可能用以及加密的字符串去连接，此时往往需要通过解密才能得到真实的用户和密码了。现在假设系统已经为提供了这样的一个CodeUtils.decode(str)进行解密，那么我们在创建SqlSessionFactory前，就需要把用户名和密码解密，然后把解密后的字符串重置到properties属性中。</p>
<p>首先使用Resources对象读取了一个jdbc.properties配置文件，然后获取了它原来配置的用户和密码，进行解密并重置，最后使用SqlSessionFactoryBuilder的build方法，传递多个properties参数来完成。这将覆盖之前配置的密文，这样就能连接数据库了，同时也满足了运维人员对数据库用户和密码安全的要求。</p>
<p>总结：以上是MyBatis使用properties的3种方式。这3种方式是有优先级的，最优先的是使用程序传递的方式，其次是使用properties文件的方式，最后使用子元素的方式。MyBatis会根据优先级来覆盖原先配置的属性值。</p>
<p>建议采用properties文件的方式，因为管理它简单易行，而且可以从XML文件中剥离出来独立维护。</p>
<h1 id="43-settings设置">4.3 settings设置</h1>
<p>settings是MyBatis中最复杂的配置，它能深刻影响MyBatis底层的运行，但大部分情况下使用默认值便可以运行，所以大部分情况下不需要大量配置它，只需要修改一些常用的规则即可，比如自动映射、驼峰命名映射、级联规则、是否启动缓存、执行器类型等。</p>
<p>settings的配置项很多，但是真正用到的不会太多，我们把常用的配置项研究清楚就可以了，比如关于缓存的CacheEnabled,关于级联的LazyloadingEnabled和aggressiveLazyLoading,关于自动映射的autoMappingBehavior和mapUnderscoreToCamelCase,关于执行器类型的defaultExecutorType等。</p>
<h1 id="44-typealiases别名">4.4 typeAliases别名</h1>
<p>由于类的全限定名很长，需要大量使用的时候，写那么长的名称不方便。在MyBatis中允许定义一个简写来代表这个类，这就是别名，别名分为系统定义别名和自定义别名。在MyBatis中别名由类TypeAliasRegistry去定义。注意，在MyBatis中别名不区分大小写。</p>
<p>MyBatis也提供了用户自定义别名的规则。我们可以通过TypeAliasRegistry类的registerAlias方法注册，也可以采用配置文件或者扫描方式来自定义它。</p>
<p>使用配置文件定义很简单：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>typeAliases<span style="color:#f92672">&gt;</span>

<span style="color:#f92672">&lt;</span>typeAliases alias<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;role&#34;</span> type<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.leartn.ssmchapter4.pojo.Role&#34;</span><span style="color:#f92672">/&gt;</span>

<span style="color:#f92672">&lt;</span>typeAliases alias<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;user&#34;</span> type<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.learn.ssm.chapter4.pojo.User&#34;</span><span style="color:#f92672">/&gt;</span>

<span style="color:#f92672">&lt;/</span>typeAliases<span style="color:#f92672">&gt;</span>
</code></pre></div><p>这样就可以定义一个别名了。如果由很多类需要定义别名，那么用这样的方式进行配置可就不那么轻松了。MyBatis还支持扫描别名。比如上面的两个类都在包com.learn.ssm.chapter4.pojo之下，那么就可以定义为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>typeAliases<span style="color:#f92672">&gt;</span>

<span style="color:#f92672">&lt;</span><span style="color:#f92672">package</span> name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.learn.ssm.chapter4.pojo&#34;</span><span style="color:#f92672">/&gt;</span>

<span style="color:#f92672">&lt;</span>typeAliases<span style="color:#f92672">&gt;</span>
</code></pre></div><p>这样MyBatis将扫描这个包里面的类，将其第一个字母变为小写作为其别名，比如类Role的别名会变成role，而User的别名会变成user。使用这样的规则有时候会出现重名，这个时候可以使用MyBatis提供的直接@Alias来进行区分。</p>
<p>这样就能够避免因为别名重名导致的扫描失败的问题。</p>
<h1 id="45-typehandler类型转换器">4.5 typeHandler类型转换器</h1>
<p>在JDBC中，需要在PreparedStatement对象中设置那些已经预编译过的SQL语句的参数。执行SQL后，会通过ResultSet对象获取得到数据库的数据，而这些MyBatis是根据数据的类型typeHandler来实现的。在typeHandler中，分为jdbcType和javaType,其中jdbcType用于定义数据库类型，而javaType用于定义Java类型，那么typeHandler的作用就是承担jdbcType和iavaType之间的相互转换。在很多情况下我们并不需要去配置typeHandler、jdbcType、javaType,因为MyBatis会探测应该使用什么类型的typeHandler进行处理，但是有些场景无法探测到。对于那些需要使用自定义枚举的场景，或者数据库使用特殊数据类型的场景，可以使用自定义的typeHandler去处理类型之间的转换问题。</p>
<p>和别名一样，在MyBatis中存在系统定义typeHandler和自定义typeHandler。MyBatis会根据javaType和数据库的jdbcType来决定采用哪个typeHandler处理这些转换规则。系统提供的typeHandler能覆盖大部分场景的要求，但是有些情况下是不够的，比如我们由特殊的转换规则，枚举类就是这样。</p>
<p>总之，typeHandler负责jdbcType和javaType之间的相互转换。</p>
<p>在大部分的情况下无须显式地声明jdbcType和javaType，或者用typeHandler去指定对应的typeHandler来实现数据类型转换，因为MyBatis系统会自己探测。有时候需要修改一些转换规则，比如枚举类往往需要自己去编写规则。</p>
<p>typeHandler继承了BaseTypeHandler</p>
<ul>
<li>BaseTypeHandler是个抽象类，需要子类去实现其定义的4个抽象方法，而它本身实现类typeHandler接口的4个方法。</li>
<li>getResult方法，非空结果集是通过getNullableResult方法获取的。如果判断为空，则返回null。</li>
<li>setParameter方法，当参数parameter和jdbcType同时为空时，MyBatis将抛出异常，如果能明确jdbcType,则会进行空设置；如果参数不为空，那么它将采用setNonNullParameter方法设置参数。</li>
<li>getNullableResult方法用于存储过程。</li>
</ul>
<p>MyBatis使用最多的typeHandler之一——StringTypeHandler。它用于字符串转换。它实现类BaseTypeHandler的4个抽象方法。</p>
<p>MyBatis中采用org.apache.ibatis.type.TypeHandlerRegistry类对象的register方法进行注册。</p>
<pre><code>public TypeHandlerRegistry(){
	register（Boolean.class，new BooleanTypeHandler()）;
}
</code></pre><p>这样就实现了用代码的形式注册typeHandler。注意,自定义的typeHandler一般不会使用代码注册，而是通过配置或扫描。</p>
<p>要实现typrHandler就需要去实现接口typeHandler，或者继承BaseTypeHandler（实际上，BaseTypeHandler实现了typeHandler接口）</p>
<p>配置typeHandler</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>typeHandlers<span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;</span>typeHandler jdbcType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;VARCHAR&#34;</span> javaType<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;String&#34;</span>
	handler<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.learn.ssm.chapter4.typehandler.MyTypeHandler&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;/</span>typeHandlers<span style="color:#f92672">&gt;</span>
</code></pre></div><p>配置完成后系统才会读取它，这样注册后，当jdbcTYpe和javaType能与MyTypeHandler对应的时候，它就会启动MyTypeHandler。有时候还可以显式启用typeHandler，一般而言启用这个typeHandler有两种方式。</p>
<p>要么指定了与自定义typeHandler一致的jdbcType和javaType,要么直接使用typeHandler指定具体的实现类。在一些因为数据库返回为空导致无法断定采用哪个typeHandler来处理，而又没有注册对应的javaType的typeHandler时。MyBatis无法知道使用哪个typeHandler转换数据，我们可以采用这样方式来确定采用哪个typeHandler处理，这样就不会有异常出现了。</p>
<p>有时候由于枚举类型很多，系统需要的typeHandler也会很多，采用配置会很麻烦，这个时候可以考虑使用包扫描的形式。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>typeHandlertype<span style="color:#f92672">&gt;</span>

<span style="color:#f92672">&lt;</span><span style="color:#f92672">package</span> name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;com.leearn.ssm.chapter4.typehandler&#34;</span><span style="color:#f92672">/&gt;</span>

<span style="color:#f92672">&lt;/</span>typeHandlertype<span style="color:#f92672">&gt;</span>
</code></pre></div><p>只是这样就没法指定jdbcType和javaType,不过可以使用注解来处理它们。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@MappedTypes</span><span style="color:#f92672">(</span>String<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">)</span>
<span style="color:#a6e22e">@MappedjdbcTYpes</span><span style="color:#f92672">(</span>jdbcType<span style="color:#f92672">.</span><span style="color:#a6e22e">VARCHAR</span><span style="color:#f92672">)</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyTypeHandler</span> <span style="color:#66d9ef">implements</span> TypeHandler<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;{</span>
<span style="color:#f92672">......</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>在绝大多数情况下，typeHandler因为枚举而使用，MyBatis已经定义了连哥哥类作为枚举类型的支持，这两个类分别是：</p>
<ul>
<li>EnumOrdinalTypeHandler</li>
<li>EnumTypeHandler</li>
</ul>
<p>因为它们的作用不大，所以在大部分情况下，我们都不用它们。前者是按MyBatis根据枚举数组下标牵引的方式进行匹配的，它要求数据库返回一个整数作为其下标，它会根据下标找到对应的枚举类型。而后者会把使用的名称转化为对应的枚举。</p>
<h2 id="451-文件操作">4.5.1 文件操作</h2>
<p>MyBatis对数据库的Blob字段也进行了支持，它提供了一个BlobTypeHandler，为了应付更多的场景，它还提供了ByteArrayTypeHandler，只是不太常用。</p>

    </div>
    <div class="post-footer">
      
    </div>
    <div class="post-comment">
      
      


<span id="/post/ssm%E7%AC%AC%E5%9B%9B%E7%AB%A0-mybatis%E9%85%8D%E7%BD%AE/" class="leancloud_visitors" data-flag-title="SSM第四章-MyBatis配置">
    <span class="post-meta-item-text">文章阅读量 </span>
    <span class="leancloud-visitors-count">1000000</span>
    <p></p>
  </span>
<div id="vcomments"></div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script type="text/javascript">
  new Valine({
    el: '#vcomments' ,
    appId: 'cScQmclMsD4OOWCclCP1pNsz-gzGzoHsz',
    appKey: 'dtSaHLmdH3J4ICVVInYg9YFM',
    notify:  false ,
  verify:  false ,
  avatar:'mm',
    placeholder: '说点什么吧...',
    visitor:  true 
  });
</script>

    </div>
  </article>

    </main>
  </body>
</html>
