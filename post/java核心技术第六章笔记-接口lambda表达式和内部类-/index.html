<!doctype html>
<html lang="en-us">
  <head>
    <title>Java核心技术第六章笔记-接口、lambda表达式和内部类 // Zereal-宋致远技术博客</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.72.0" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75，minimum-scale=0.75, maximum-scale=0.75, user-scalable=no" />
    <meta name="author" content="Zereal" />
    <meta name="description" content="" />
    <meta name="referrer" content="never"/>
    <link rel="stylesheet" href="https://zereals7.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java核心技术第六章笔记-接口、lambda表达式和内部类"/>
<meta name="twitter:description" content="接口主要用来描述类具有什么功能，而并不给出每个功能的具体实现。一个类可以实现一个或多个接口，并在需要接口的地方，随时使用实现了相应接口的对象。
lambda表达式是一种表示可以在将来某个时间点执行代码块的简洁方法。使用lambda表达式，可以用一种精巧而简洁的方式表示使用回调或变量行为的代码。
内部类定义在另一个类的内部，其中的方法可以访问到包含它们外部类的域。内部类技术主要用于设计具有相互协作关系的类集合。
代理，这是一种实现任意接口的对象。代理是一种非常专业的构造工具，它用来构建系统级的工具。
**接口 **
接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的同一格式进行定义。
如果类遵从某个特定的接口，那么就履行这项服务。
Array类的sort方法承诺可以对对象数组进行排序，但要求类必须实现Comparable接口。
任何实现Comparable接口的类都需要包含compareTo方法。
接口中的所有方法自动地属于public。因此，在接口中声明方法时，不必提供关键字public。
有些接口可能包含多个方法。在接口中声明方法时，不必提供关键字public。
提供实例域和方法实现的任务应该由实现接口的那个类来完成。可以将接口看做是没有实例域的抽象类。
假设希望使用Arrays类的sort方法对Employee对象数组进行排序，Employee就必须实现Comparable接口。
为了 让类是实现一个接口，通常需要下面的步骤：
1.将类声明为实现给定的接口
2.对接口中的所有方法进行定义
接口的特性
接口不是类，不能用new运算符实例化一个接口。
尽管不能构造接口的对象，却能声明接口的变量：
Comparable x; 接口变量必须引用实现了接口的类对象
x =new Employee(&hellip;)
与可以建立类的继承关系一样，接口也可以被扩展。这里允许存在多条从具有较高通用性的接口到较高专用性的接口的链。例如，假设有一个被称为Moveable的接口
public interface Moveable{ void move（double x,double y）; } 然后，可以以它为基础扩展一个叫做Powered的接口：
public interface Powerd extends Moveable{double milesPerGallon();}虽然接口中不能包含实例域或静态方法，但却可以包含常量。
与接口中的方法都能自动的设置为public一样，接口中的域将被自动的设为public static final。
有些接口只定义了常量，而没有定义方法。这样的接口似乎偏离了接口概念的初衷，最好不要这样使用它。
尽管每个类只能够拥有一个超类，但却可以实现多个接口。这能为定义类的行为提供极大的灵活性。
Java有一个非常重要的内置接口，称为 Cloneable。如果某个类实现了这个cloneable接口。Object类中的clone方法就可以创建类对象的一个拷贝。如果希望自己设计的类拥有克隆和比较的能力，只要实现这两个接口就可以了。使用逗号将实现的各个接口分隔开。
class Employee implements Cloneable,Comparable 接口与抽象类
使用抽象类表示通用属性存在一个问题：每个类只能扩展于一个类。假设已经扩展于一个类，就不能再扩展第二个类了。但每个类可以实现多个接口。实际上，接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。
静态方法
允许在接口中增加静态方法。目前为止，通常做法都是将静态方法放在伴随类中。在标准库中，会看到成对出现的接口和实用工具类。如Collection或Path。
Path类只包含两个工厂方法。可以由一个字符串序列构造一个文件或目录的路径。
默认方法
可以为接口提供一个默认实现。必须用default修饰符标记这样一个方法。
public interface Comparable&lt;T&gt;{ default int compareTo(T other){ return 0; } } Comparable 的每个实际实现都要覆盖这个方法。不过有些情况下，默认方法可能很有用。"/>

    <meta property="og:title" content="Java核心技术第六章笔记-接口、lambda表达式和内部类" />
<meta property="og:description" content="接口主要用来描述类具有什么功能，而并不给出每个功能的具体实现。一个类可以实现一个或多个接口，并在需要接口的地方，随时使用实现了相应接口的对象。
lambda表达式是一种表示可以在将来某个时间点执行代码块的简洁方法。使用lambda表达式，可以用一种精巧而简洁的方式表示使用回调或变量行为的代码。
内部类定义在另一个类的内部，其中的方法可以访问到包含它们外部类的域。内部类技术主要用于设计具有相互协作关系的类集合。
代理，这是一种实现任意接口的对象。代理是一种非常专业的构造工具，它用来构建系统级的工具。
**接口 **
接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的同一格式进行定义。
如果类遵从某个特定的接口，那么就履行这项服务。
Array类的sort方法承诺可以对对象数组进行排序，但要求类必须实现Comparable接口。
任何实现Comparable接口的类都需要包含compareTo方法。
接口中的所有方法自动地属于public。因此，在接口中声明方法时，不必提供关键字public。
有些接口可能包含多个方法。在接口中声明方法时，不必提供关键字public。
提供实例域和方法实现的任务应该由实现接口的那个类来完成。可以将接口看做是没有实例域的抽象类。
假设希望使用Arrays类的sort方法对Employee对象数组进行排序，Employee就必须实现Comparable接口。
为了 让类是实现一个接口，通常需要下面的步骤：
1.将类声明为实现给定的接口
2.对接口中的所有方法进行定义
接口的特性
接口不是类，不能用new运算符实例化一个接口。
尽管不能构造接口的对象，却能声明接口的变量：
Comparable x; 接口变量必须引用实现了接口的类对象
x =new Employee(&hellip;)
与可以建立类的继承关系一样，接口也可以被扩展。这里允许存在多条从具有较高通用性的接口到较高专用性的接口的链。例如，假设有一个被称为Moveable的接口
public interface Moveable{ void move（double x,double y）; } 然后，可以以它为基础扩展一个叫做Powered的接口：
public interface Powerd extends Moveable{double milesPerGallon();}虽然接口中不能包含实例域或静态方法，但却可以包含常量。
与接口中的方法都能自动的设置为public一样，接口中的域将被自动的设为public static final。
有些接口只定义了常量，而没有定义方法。这样的接口似乎偏离了接口概念的初衷，最好不要这样使用它。
尽管每个类只能够拥有一个超类，但却可以实现多个接口。这能为定义类的行为提供极大的灵活性。
Java有一个非常重要的内置接口，称为 Cloneable。如果某个类实现了这个cloneable接口。Object类中的clone方法就可以创建类对象的一个拷贝。如果希望自己设计的类拥有克隆和比较的能力，只要实现这两个接口就可以了。使用逗号将实现的各个接口分隔开。
class Employee implements Cloneable,Comparable 接口与抽象类
使用抽象类表示通用属性存在一个问题：每个类只能扩展于一个类。假设已经扩展于一个类，就不能再扩展第二个类了。但每个类可以实现多个接口。实际上，接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。
静态方法
允许在接口中增加静态方法。目前为止，通常做法都是将静态方法放在伴随类中。在标准库中，会看到成对出现的接口和实用工具类。如Collection或Path。
Path类只包含两个工厂方法。可以由一个字符串序列构造一个文件或目录的路径。
默认方法
可以为接口提供一个默认实现。必须用default修饰符标记这样一个方法。
public interface Comparable&lt;T&gt;{ default int compareTo(T other){ return 0; } } Comparable 的每个实际实现都要覆盖这个方法。不过有些情况下，默认方法可能很有用。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%AC%94%E8%AE%B0-%E6%8E%A5%E5%8F%A3lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB-/" />
<meta property="article:published_time" content="2021-05-16T23:10:42+08:00" />
<meta property="article:modified_time" content="2021-05-16T23:10:42+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://zereals7.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="Zereal" /></a>
      <h1>Zereal</h1>
      <p>Java coder</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/ZerealS7" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Java核心技术第六章笔记-接口、lambda表达式和内部类</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          May 16, 2021
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          3 min read
        </div></div>
    </header>
    <div class="post-content">
      <p>接口主要用来描述类具有什么功能，而并不给出每个功能的具体实现。一个类可以实现一个或多个接口，并在需要接口的地方，随时使用实现了相应接口的对象。</p>
<p>lambda表达式是一种表示可以在将来某个时间点执行代码块的简洁方法。使用lambda表达式，可以用一种精巧而简洁的方式表示使用回调或变量行为的代码。</p>
<p>内部类定义在另一个类的内部，其中的方法可以访问到包含它们外部类的域。内部类技术主要用于设计具有相互协作关系的类集合。</p>
<p>代理，这是一种实现任意接口的对象。代理是一种非常专业的构造工具，它用来构建系统级的工具。</p>
<p>**接口                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              **</p>
<p>接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的同一格式进行定义。</p>
<p>如果类遵从某个特定的接口，那么就履行这项服务。</p>
<p>Array类的sort方法承诺可以对对象数组进行排序，但要求类必须实现Comparable接口。</p>
<p>任何实现Comparable接口的类都需要包含compareTo方法。</p>
<p>接口中的所有方法自动地属于public。因此，在接口中声明方法时，不必提供关键字public。</p>
<p>有些接口可能包含多个方法。在接口中声明方法时，不必提供关键字public。</p>
<p>提供实例域和方法实现的任务应该由实现接口的那个类来完成。可以将接口看做是没有实例域的抽象类。</p>
<p>假设希望使用Arrays类的sort方法对Employee对象数组进行排序，Employee就必须实现Comparable接口。</p>
<p>为了 让类是实现一个接口，通常需要下面的步骤：</p>
<p>1.将类声明为实现给定的接口</p>
<p>2.对接口中的所有方法进行定义</p>
<p><strong>接口的特性</strong></p>
<p>接口不是类，不能用new运算符实例化一个接口。</p>
<p>尽管不能构造接口的对象，却能声明接口的变量：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Comparable x<span style="color:#f92672">;</span>
</code></pre></div><p>接口变量必须引用实现了接口的类对象</p>
<p>x =new Employee(&hellip;)</p>
<p>与可以建立类的继承关系一样，接口也可以被扩展。这里允许存在多条从具有较高通用性的接口到较高专用性的接口的链。例如，假设有一个被称为Moveable的接口</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Moveable</span><span style="color:#f92672">{</span>
	<span style="color:#66d9ef">void</span> move<span style="color:#960050;background-color:#1e0010">（</span><span style="color:#66d9ef">double</span> x<span style="color:#f92672">,</span><span style="color:#66d9ef">double</span> y<span style="color:#960050;background-color:#1e0010">）</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>然后，可以以它为基础扩展一个叫做Powered的接口：</p>
<pre><code>public interface Powerd extends Moveable
{
	double milesPerGallon();
}
</code></pre><p>虽然接口中不能包含实例域或静态方法，但却可以包含常量。</p>
<p>与接口中的方法都能自动的设置为public一样，接口中的域将被自动的设为public static final。</p>
<p>有些接口只定义了常量，而没有定义方法。这样的接口似乎偏离了接口概念的初衷，最好不要这样使用它。</p>
<p>尽管每个类只能够拥有一个超类，但却可以实现多个接口。这能为定义类的行为提供极大的灵活性。</p>
<p>Java有一个非常重要的内置接口，称为 Cloneable。如果某个类实现了这个cloneable接口。Object类中的clone方法就可以创建类对象的一个拷贝。如果希望自己设计的类拥有克隆和比较的能力，只要实现这两个接口就可以了。使用逗号将实现的各个接口分隔开。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Employee</span> <span style="color:#66d9ef">implements</span> Cloneable<span style="color:#f92672">,</span>Comparable
</code></pre></div><p><strong>接口与抽象类</strong></p>
<p>使用抽象类表示通用属性存在一个问题：每个类只能扩展于一个类。假设已经扩展于一个类，就不能再扩展第二个类了。但每个类可以实现多个接口。实际上，接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。</p>
<p><strong>静态方法</strong></p>
<p>允许在接口中增加静态方法。目前为止，通常做法都是将静态方法放在伴随类中。在标准库中，会看到成对出现的接口和实用工具类。如Collection或Path。</p>
<p>Path类只包含两个工厂方法。可以由一个字符串序列构造一个文件或目录的路径。</p>
<p><strong>默认方法</strong></p>
<p>可以为接口提供一个默认实现。必须用default修饰符标记这样一个方法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Comparable</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;{</span>
	<span style="color:#66d9ef">default</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>T other<span style="color:#f92672">){</span>
	<span style="color:#66d9ef">return</span> 0<span style="color:#f92672">;</span>
	<span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>Comparable 的每个实际实现都要覆盖这个方法。不过有些情况下，默认方法可能很有用。</p>
<p>这样一来，程序员只需要为他们真正关心的时间覆盖相应的监听器。</p>
<p>默认方法可以调用任何其他方法。如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> interfacce Collection<span style="color:#f92672">{</span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">size</span><span style="color:#f92672">();</span>
<span style="color:#66d9ef">default</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">(){</span>
	<span style="color:#66d9ef">return</span> size<span style="color:#f92672">()==</span>0<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
<span style="color:#f92672">...</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这样一来实现Collection的程序员就不用操心isEmpty方法。</p>
<p>很多接口都有相应的伴随类。其中实现了接口的部分或所以方法。现在不需要了，SE8中，已经可以直接在接口中实现方法。</p>
<p>默认方法的一个重要用法是”接口演化“。假设你要为某个接口增加一个方法。</p>
<p>假设这个方法不是默认方法，那么就不能编译，因为它没有实现这个新方法。为接口增加非默认方法不能保证与源码兼容。</p>
<p>不过，如果不重新编译这个类。而只是使用原先的一个包含这个类的JAR文件。这个类仍能正常加载，尽管没有这个歌新方法。程序仍然可以正常构造实例。不过如果这个实例调用新增的方法，就会出现异常。</p>
<p>将方法实现为一个默认方法可以解决这个问题。</p>
<p><strong>解决默认方法冲突</strong></p>
<p>如果现在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口定义了同样的方法。会发生什么情况？</p>
<p>应遵循以下的规则：</p>
<p>1.超类优先。如果超额里提供了一个具体方法，同名而且具有相同参数的默认方法会被忽略。</p>
<p>2.接口冲突。如果一个超接口提供了一个默认方法。另一个接口提供了一个同名而且参数类型相同的方法。必须覆盖这个方法来解决冲突。</p>
<p>如果同时实现了这两个接口中的同样的方法，而不是从中选择一个。Java编译器会报告一个错误，让程序员来解决这个二义性。只需要在类中覆写具体的方法，从中做出一个选择。</p>
<p>Java强调一致性，两个接口如何冲突并不重要。如果至少有一个接口提供了一个实现，编译器就会报告错误，而程序员必须解决这个二义性、</p>
<p>如果两个接口都没有为共享方法提供默认实现。实现类有两个选择，实现这个方法，或者干脆不实现。如果是后一种情况，这个类本身就是抽象的。</p>
<p>一个类扩展了一个超类，同时实现了一个接口，并从超类和接口继承了相同的方法。</p>
<p>在这种情况下，只会考虑超类方法，接口所有默认方法都会被忽略。就算接口提供了默认实现也不会带来什么区别。这正是类优先的规则。</p>
<p><strong>接口与回调</strong></p>
<p>回调是一种常见的程序设计模式。在这种模式中，可以指出某个特定事件发生时应该采取的动作。例如，可以指出在按下鼠标或选择某个菜单项时应该采取什么行动。</p>
<p>java.swing包有一个Time类，可以使用它在到达给定的时间间隔发出通告，例如，假如程序中有一个时钟，就可以请求每秒钟获得一个通告，以便更新时钟的表盘。在构造定时器时，需要设置一个时间间隔，并告之定时器，当到达时间间隔时需要什么操作。</p>
<p>可以提供一个函数名，定时器周期性的调用它</p>
<p>。但是，在Java标准类库中的类采用的是面向对象方法，它将某个类的对象传递给定时器，然后，定时器调用这个对象的方法。由于对象可以携带一些附加的信息，传递一个对象币传递一个函数灵活的多。</p>
<p>当然，定时器需要知道调用哪个方法，并要求传递的对象所属的类实现了java.event包的ActionListen接口。下面是这个接口：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ActionListener</span> <span style="color:#f92672">{</span>
<span style="color:#66d9ef">void</span> actionPerformed<span style="color:#960050;background-color:#1e0010">（</span>ActionEvent event<span style="color:#960050;background-color:#1e0010">）</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>当到达指定的时间间隔时，定时器就调用actionPerformed方法。</p>
<p>需要注意actionPerformed方法的ActionEvent参数。  这个参数提供了时间的相关信息，例如，产生这个事件的源对象</p>
<p>可以构造类的对象，并把它传递给Timer构造器</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">ActionListener listener <span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> TimePrinter<span style="color:#f92672">();</span><span style="color:#75715e">//TimePrinter是实现了监听器接口的类对象。
</span><span style="color:#75715e"></span>Time t<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> Timer<span style="color:#f92672">(</span>10000<span style="color:#f92672">,</span>listener<span style="color:#f92672">);</span>
</code></pre></div><p>Timer构造器的第一个参数是发出通告的时间间隔，它的单位是毫秒。这里希望每隔10秒钟通告一次。第二个参数是监听器对象。</p>
<p>最后，启动定时器：</p>
<pre><code>t.start();
</code></pre><p><strong>Comparable接口</strong></p>
<p>要让一个对象数组排序，就要让这些对象实现Comparable接口的类的实例。可以对一个字符串数组排序，因为String类实现了Comparable<!-- raw HTML omitted -->，而String.compareTo方法可以按字典顺序比较字符串。要对一个数组排序，需要为Arrays.sprt方法传入一个LengthCompare对象。</p>
<p><strong>对象克隆</strong></p>
<p>clone方法是Object类的一个protected方法。这说明你的代码不能直接调用这个方法 。</p>
<p>默认的克隆方法是浅拷贝，并没有克隆对象中引用的其他对象，这样一来原对象和克隆对象仍然会共享一些信息。</p>
<p>对于浅拷贝，如果原对象和浅克隆对象共享的子对象是不可变的。那么这种共享就是安全的。如果子对象属于一个不可变的类，如String,就是这种情况。或者在对象的生命期中，子对象一直包含不变的常量，没有更改器方法会改变它，也没有方法会生成他的引用，这种情况下同样是安全的。</p>
<p>不过，通常子对象都是可变的，必须重新定义clone方法来建立一个深拷贝，同时克隆所有子对象。</p>
<p>对于每一个类，需要确定：</p>
<p>1.默认的clone方法是否满足要求</p>
<p>2.是否可以在可变的子对象上调用clone来修补默认的clone方法</p>
<p>2.是否不该使用clone</p>
<p>实际上第三个选项是默认选项。如果选择第一或第二项，类必须：</p>
<p>1.实现Cloneable接口</p>
<p>2.重新定义clone方法，并指定public修饰符。</p>
<p>Object类中clone方法声明为protected。子类只能调用受保护的clone方法来克隆它自己的对象。必须重新定义clone为public才能允许所有方法克隆对象。</p>
<p>对象对于克隆很偏执，如果一个对象请求克隆，但没有实现这个接口，就会生成一个受查异常。</p>
<p>即使clone的默认浅拷贝实现能够满足要求，还是需要实现 Cloneable接口，将clone重新定义为public，再调用super.clone（）。</p>
<p>如果在一个对象上调用clone，但这个对象没实现Cloneable接口，Object类的clone方法就会抛出异常。最好还是保留throw说明符。这样就允许子类在不支持克隆时选择抛出一个异常。</p>
<p>所有数组类型都有一个public的clone方法，而不是protected。可以使用这个方法建立一个新数组，包含原数组所有元素的副本。</p>
<p><strong>lambda表达式</strong></p>
<p>lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。</p>
<p>下面是一个例子</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#960050;background-color:#1e0010">（</span>String first<span style="color:#f92672">,</span>String second<span style="color:#960050;background-color:#1e0010">）→</span>first<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#960050;background-color:#1e0010">（）</span><span style="color:#f92672">-</span>second<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">()</span>
</code></pre></div><p>如果要完成的计算无法放在一个表达式中，就可以像写方法一样，把这些代码放在{}中，并包含显式的return语句。如</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#960050;background-color:#1e0010">（</span>String first<span style="color:#f92672">,</span>String second<span style="color:#960050;background-color:#1e0010">）→</span>
<span style="color:#f92672">{</span>
	<span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>first<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">()&lt;</span>second<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">())</span> <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>first<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">()&gt;</span>second<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">())</span> <span style="color:#66d9ef">return</span> 1<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> 0<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>即使lambda表达式没有参数，仍然要提供空括号，就像无参数方法一样；</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#960050;background-color:#1e0010">（）→</span><span style="color:#f92672">{</span> <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>100<span style="color:#f92672">;</span>i<span style="color:#f92672">&gt;=</span>0<span style="color:#f92672">;</span>i<span style="color:#f92672">--)</span> System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">();}</span>
</code></pre></div><p>这个就相当于无参数的方法。</p>
<p>如果方法只有一个参数，而且这个参数的类型可以推导得出，那么甚至还可以省略小括号；</p>
<pre><code>Actionlistener listener =event→System.out.println(&quot;The time is +new Date()&quot;)//省略了event的参数类型，ActionE
</code></pre><p>无需指定lambda表达式的返回类型。lambda表达式的返回类型总是会由上下文推导得出。例如，下面的表达式</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java\" data-lang="java\"><span style="color:#960050;background-color:#1e0010">（</span>String first<span style="color:#f92672">,</span>String second<span style="color:#960050;background-color:#1e0010">）→</span>first<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">()-</span>second<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">()</span>
</code></pre></div><p>可以在需要int类型结果的上下文中使用。</p>
<p>如果一个Lambda表达式只在某些分支返回一个值，而在另一些分支不返回值，这是不合法的。如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#960050;background-color:#1e0010">（</span><span style="color:#66d9ef">int</span> x<span style="color:#960050;background-color:#1e0010">）→</span><span style="color:#f92672">{</span><span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">&gt;=</span>0<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> 1<span style="color:#f92672">;}</span>
</code></pre></div><p><strong>函数式接口</strong></p>
<p>Java中有很多封装代码块的接口。如Actionlistener和Comparator。lambda表达式与这些接口是兼容的。</p>
<p>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lamda表达式。这种接口称为函数式接口。</p>
<p>函数式接口必须要有一个抽象方法 。</p>
<p>为了展示如何转换函数式接口，考虑Array.sort方法。它的第二个参数需要一个comparator实例，Comparator就是只有一个方法的接口。所以可以提供一个lambda表达式</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>words<span style="color:#f92672">,(</span>first<span style="color:#f92672">,</span>second<span style="color:#f92672">)</span><span style="color:#960050;background-color:#1e0010">→</span>first<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">()-</span>second<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">());</span>
</code></pre></div><p>在底层，Arrays.sort方法会接收实现了Comparator<!-- raw HTML omitted -->的某个类的对象。在这个对象上调用compare方法会执行这个lambda表达式的体。这些对象和类的管理完全取决于具体实现，与使用传统的内联类相比，这样可能高效得多。最好把lambda表达式看作是一个函数，而不是一个对象，另外要接受lambda表达式可以传递到函数式接口。</p>
<p>lambda表达式可以转换为接口，这一点让lambda表达式很有吸引力。具体的语法很简短。如</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Timer t <span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> Timer<span style="color:#f92672">(</span>1000<span style="color:#f92672">,</span>event<span style="color:#960050;background-color:#1e0010">→</span><span style="color:#f92672">{</span>
	System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">();</span>
	Toolkit<span style="color:#f92672">.</span><span style="color:#a6e22e">getDefaultToolkit</span><span style="color:#f92672">().</span><span style="color:#a6e22e">beep</span><span style="color:#f92672">;</span>
<span style="color:#f92672">})</span>
</code></pre></div><p>这个代码的可读性不错。</p>
<p>实际上，在Java中，对lambda表达式所能做的也只是转换为函数式接口。你甚至不能把lamda表达式付给类型为Object的变量，Object是对象而不是函数式接口。</p>
<p>ArrayList类有一个removeif方法，它的参数是一个Predict,这个接口专门用来传递lambda表达式。例如，下面的语句将从一个数组列表删除所有的null值。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">list<span style="color:#f92672">.</span><span style="color:#a6e22e">removeif</span><span style="color:#f92672">(</span>e<span style="color:#960050;background-color:#1e0010">→</span>e<span style="color:#f92672">==</span><span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
</code></pre></div><p><strong>方法引用</strong></p>
<p>有时，可能已经有现成的方法可以完成你想要传递到代码的某个动作。例如，假设你希望只要出现一个定时器时间就打印这个事件对象。当然，为此可以调用：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Timer t <span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> Timer<span style="color:#f92672">(</span>1000<span style="color:#f92672">,</span>event<span style="color:#960050;background-color:#1e0010">→</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>event<span style="color:#f92672">));</span>
</code></pre></div><p>但是，如果直接把println方法传递到Timer构造器就好了。如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Timer t<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> Timer<span style="color:#960050;background-color:#1e0010">（</span>1000<span style="color:#960050;background-color:#1e0010">，</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">::</span>println<span style="color:#960050;background-color:#1e0010">）</span>
</code></pre></div><p>表达式System.out::println是一个方法引用，它等价于lambda表达式x→System.out.println(x)。</p>
<p>再看一个例子，假设你想对字符串排序，而不考虑大小写。可以传递以下表达式：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Array<span style="color:#f92672">.</span><span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>strings<span style="color:#f92672">,</span>String<span style="color:#f92672">::</span>compareToIgnoreCase<span style="color:#f92672">)</span>
</code></pre></div><p>从这些例子可以看出，要用::操作符分割方法名与对象或类名。主要有三种情况。</p>
<pre><code>对象::实例方法
类::静态方法
类::实例方法
</code></pre><p>前两种情况，方法引用等价于提供方法参数的lambda表达式。类似的，Math::pow等价于（x,y）→Math.pow(x,y)</p>
<p>对于第3中情况，第一个参数会成为方法的目标。例如，String::compareToIgnoreCase等同于（x,y)→x.compareToIgnore（y)。</p>
<p>如果有多个同名的重载方法，编译器就会尝试从上下文中找出你指得哪一个。选择哪一个版本取决于转换为哪个函数式接口的实例。类似于lambda表达式,方法引用不能独立存在，总是会转换为函数式接口的实例。</p>
<p>可以在方法引用中使用this参数例如，this::equals等同于x→this.equals(x)。使用super也是合法的 。</p>
<p><strong>构造器引用</strong></p>
<p>构造器引用和方法引用很类似，只不过方法名为new。例如。Person::new是Person构造器的一个引用，但具体是哪一个构造器，得取决于上下文 。假设你有一个字符串列表。可以将它转换为一个Person对象数组，为此要在各个字符串上调用构造器。重点是map方法会为各个列表元素调用Person(String）构造器。如果有多个Person构造器，编译器会选择有String参数的那个，这是它从上下文推导出的。</p>
<p>可以用数组类型建立构造器引用。如，int[] ::new是一个构造器引用，它有一个参数；即数组的长度。这等价于lambda表达式x→new int[x]。</p>
<p>Java有一个限制，无法构造泛型类型T的数组。数组构造器引用对于克服这个限制很有用。表达式 new T[n]会产生错误，因为这回改为new Object[n]。对于开发类库的忍来说，这是一个问题。例如，假设我们需要一个Person对象数组。Stream接口有一个toArray方法可以返回Object数组。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Object<span style="color:#f92672">[]</span> people<span style="color:#f92672">=</span>stream<span style="color:#f92672">.</span><span style="color:#a6e22e">toArray</span><span style="color:#f92672">();</span> 
</code></pre></div><p>不过，这并不令人满意用户希望得到一个Person引用数组，而不是Object引用数组。流库利用构造器引用解决了这个问题。可以把Person[]::new传入toArray方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Person<span style="color:#f92672">[]</span> people <span style="color:#f92672">=</span>stream<span style="color:#f92672">.</span><span style="color:#a6e22e">toArray</span><span style="color:#960050;background-color:#1e0010">（</span>Person<span style="color:#f92672">[]::</span><span style="color:#66d9ef">new</span><span style="color:#960050;background-color:#1e0010">）</span><span style="color:#f92672">;</span>
</code></pre></div><p>toArray方法调用这个构造器来得到一个正确类型的数组。然后填充这个数组并返回。</p>
<p><strong>变量作用域</strong></p>
<p>通常，你可能希望能够在lambda表达式中访问外围方法或类中的变量。考虑下面这个例子。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">repeatMessage</span><span style="color:#f92672">(</span>String text<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> delay<span style="color:#f92672">){</span>
	ActionListener listener<span style="color:#f92672">=</span>event <span style="color:#960050;background-color:#1e0010">→</span>
<span style="color:#f92672">{</span>
	System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>text<span style="color:#f92672">);</span>
	Toolkit<span style="color:#f92672">.</span><span style="color:#a6e22e">getDefaultToolkit</span><span style="color:#f92672">().</span><span style="color:#a6e22e">beep</span><span style="color:#f92672">();</span>
<span style="color:#f92672">};</span>
<span style="color:#66d9ef">new</span> Timer<span style="color:#f92672">(</span>delay<span style="color:#f92672">,</span>listener<span style="color:#f92672">).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>来看这样一个调用；</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">repeatMessage<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Hello&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;1000&#34;</span><span style="color:#f92672">);</span>
</code></pre></div><p>现在来看lambda表达式中的变量text。注意这个变量不是在lambda表达式中定义的。实际上，这是repeatMassage方法的一个参数变量。</p>
<p>如果再想想看，lambda表达式可能会在这个方法调用返回很久之后才运行，而那时这个参数变量已经不存在了。如何保留text变量呢？要了解会发生什么，先来巩固一下我们对lambda表示的理解。lambda表达式分为3个部分 ：</p>
<p>1.一个代码块</p>
<p>2.参数</p>
<p>3.自由变量的值，这是指非参数而且不在代码中定义的变量。</p>
<p>在这个例子中，lambda表达式有一个自由变量text。表示lambda表达式的数据结构必须存储自由变量的值，在这里就是字符串”Hello“。我们说它被lambda表达式捕获。（例如，可以把一个Lambda表达式转换为包含一个方法的对象，这样自由变量的值就会复制到这个对象的实例变量中。）</p>
<p>关于代码块以及自由变量值有个术语：闭包（closure）。在Java中，lambda表达式就是闭包。</p>
<p>可以看到lambda表达式可以捕获外围作用域变量的值。在Java中，要确保所捕获的值是明确定义的，这里有一个重要的限制。在lambda表达式中，只能引用值不会改变的变量。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">countDown</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> start<span style="color:#960050;background-color:#1e0010">，</span><span style="color:#66d9ef">int</span> delay<span style="color:#960050;background-color:#1e0010">）</span><span style="color:#f92672">{</span>
	Actionlistener listener <span style="color:#f92672">=</span>event<span style="color:#960050;background-color:#1e0010">→</span>
	
<span style="color:#f92672">{</span>
	start<span style="color:#f92672">--;</span><span style="color:#75715e">//不能捕获变量
</span><span style="color:#75715e"></span>	System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>start<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
    <span style="color:#66d9ef">new</span> Timer<span style="color:#f92672">(</span>delay<span style="color:#f92672">,</span>listener<span style="color:#f92672">).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>之所以这样限制是有原因的。如果在lambda表达式中改变变量，并发执行多个动作时就会不安全。</p>
<p>另外 如果在lambda表达式中引用变量，而这个变量可能在外部改变，这也是不合法的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">repeat</span><span style="color:#f92672">(</span>String text<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> count<span style="color:#f92672">)</span>
<span style="color:#f92672">{</span>
<span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>1<span style="color:#f92672">;</span>i<span style="color:#f92672">&lt;=</span>count<span style="color:#f92672">;</span>i<span style="color:#f92672">++){</span>
ActionListener listener<span style="color:#f92672">=</span>event<span style="color:#960050;background-color:#1e0010">→</span><span style="color:#f92672">{</span>
	System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>i<span style="color:#f92672">+</span><span style="color:#e6db74">&#34;:&#34;</span><span style="color:#f92672">+</span>text<span style="color:#f92672">);</span>
	<span style="color:#75715e">//i可能会发生改变,i是可以在外部改变的变量 
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
	<span style="color:#66d9ef">new</span> Timer<span style="color:#960050;background-color:#1e0010">（</span>1000<span style="color:#960050;background-color:#1e0010">，</span>listener<span style="color:#960050;background-color:#1e0010">）</span><span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">;</span>  
<span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这里有一条规则：lambda表达式中 捕获的比哪里必须实际上是最终变量。实际上的最终变量是指，这个变量初始化之后就不会再为它赋新值。text总是指示同一个对象，所以这个变量是合法的。</p>
<p>lambda表达式的体与嵌套块有相同的作用域。在方法中，不能有两个同名的局部变量。因此，Lambda表达式同样也不能有同名的局部变量。</p>
<p>在一个lambda表达式使用this关键字时，是指创建这个lambda表达式的this参数</p>
<p>使用lambda表达式的重点是延迟执行。毕竟，如果需要立即执行代码，完全可以直接执行，而无需把它包装在一个lambda表达式中。之所以希望以后再执行代码，有很多原因:</p>
<p>1.在一个单独的线程中运行代码</p>
<p>2.多次运行代码</p>
<p>3.在算法的适当位置运行代码</p>
<p>4.发生某种情况 时执行代码</p>
<p>5.只在必要时才运行代码</p>
<p>假设你想重复一个动作n次。将这个动作和重复次数传递到一个repeat方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">repeat<span style="color:#f92672">(</span>10<span style="color:#f92672">,()</span><span style="color:#960050;background-color:#1e0010">→</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Hello,World！&#34;</span><span style="color:#f92672">))</span>
</code></pre></div><p>要接受这个lambda表达式，需要选择一个函数式接口。在这里，我们可以使用Runnable接口：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">repeat</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> n<span style="color:#f92672">,</span>Runnable action<span style="color:#f92672">){</span>
	<span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span>i<span style="color:#f92672">&lt;</span>n<span style="color:#f92672">;</span>i<span style="color:#f92672">++)</span> action<span style="color:#f92672">.</span><span style="color:#a6e22e">run</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>调用action.run()时会执行这个lambda表达式的主体。</p>
<p>如果设计自己的接口，其中只有一个抽象方法，可以用@FunctionalInterface注解来标记这个接口，这样有两个优点。如果你无意中增加了另一个非抽象方法，编译器就会产生一个错误消息。另外javadoc页里会指出你的接口是一个函数式接口。</p>
<p>并不是必须使用注解，根据定义，任何有一个抽象方法的接口都是函数式接口。不过使用@FunctionalImterface 注解确实是一个很好的做法。</p>
<p><strong>Comparator</strong></p>
<p>​    这个接口包含很多方便的静态方法来创建比较器。这些方法可以用于lambda表达式或方法引用。</p>
<p>静态comparing方法取一个“键提取器”函数，它将类型T映射为一个可比较的类型。对要比较的对象应用这个函数，然后对返回的键完成比较。</p>
<p>假设有一个Person对象数组，可以按名字对这些对象排序：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Array<span style="color:#f92672">.</span><span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>people<span style="color:#f92672">,</span>Comparator<span style="color:#f92672">.</span><span style="color:#a6e22e">comparing</span><span style="color:#f92672">(</span>Person<span style="color:#f92672">::</span>getName<span style="color:#f92672">));</span>
</code></pre></div><p>与动手实现一个Comparator相比，这当然容易得多。另外，代码也更为清晰，因为显然我们都希望按人名进行比较。</p>
<p><strong>内部类</strong></p>
<p>内部类就是定义在另一个类中的类。内部类主要有以下几点作用：</p>
<p>1.内部类 可以访问该类定义所在的作用域中的数据，包括私有域数据。</p>
<p>2.内部类可以对同一个包中的其他类隐藏起来</p>
<p>3.当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷。</p>
<p>使用内部类访问对象状态</p>
<p>举一个例子，构造一个语音时钟需要提供两个参数：发布通告的间隔和开关铃声的标志。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TalkingClock</span> <span style="color:#f92672">{</span>
	<span style="color:#66d9ef">private</span>　<span style="color:#66d9ef">int</span>　interval<span style="color:#960050;background-color:#1e0010">；</span>
	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> start<span style="color:#f92672">;</span>
	
	<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">TalkingClock</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> interval<span style="color:#f92672">,</span><span style="color:#66d9ef">boolean</span> beep<span style="color:#f92672">){</span>
	<span style="color:#f92672">...</span>
	<span style="color:#f92672">}</span>
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">start</span><span style="color:#f92672">(){</span>
	<span style="color:#f92672">...</span>
	<span style="color:#f92672">}</span>
	
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TimePrinter</span> <span style="color:#66d9ef">implements</span> ActionListener
	<span style="color:#f92672">{</span>
	System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;at the tone,the time is&#34;</span><span style="color:#f92672">+</span><span style="color:#66d9ef">new</span> Date<span style="color:#f92672">());</span>
        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>beep<span style="color:#f92672">)</span> Toolkit<span style="color:#f92672">.</span><span style="color:#a6e22e">getDefaultToolkit</span><span style="color:#f92672">().</span><span style="color:#a6e22e">beep</span><span style="color:#f92672">();</span>
	<span style="color:#f92672">}</span>
	
<span style="color:#f92672">}</span>
</code></pre></div><p>需要注意，这里的TimePrinter类位于TalkingClock类内部。这并不意味着每个TalkingClock都有一个TimePrinter实例域。</p>
<p>TimePrinter对象是由TalkingClock类的方法构造的。</p>
<p>令人惊讶的是。TimePrinter类没有实例域或者名为beep的变量，取而代之的是beep引用了创建TimePrinter的TalkingClock对象的域。内部类既可以访问自身的数据域，也可以访问创建它的外围类的对象的数据域。</p>
<p>内部类既可以访问自身的数据域，也可以访问 创建它的外围类对象的数据域。</p>
<p>为了能够运行这个程序，内部类的对象总有一个隐式引用outer，它指向了创建它的外部类对象。</p>
<p>这个引用在内部类的定义中是不可见的。beep其实是outer.beep 。</p>
<p>外围类的引用在构造器中设置。编译器修改了所有的内部类的构造器，添加一个外围类引用的参数。因为TimePrinter类没有定义构造器，所以编译器为这个类生成了一个默认的构造器   。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">TimePrinter</span><span style="color:#f92672">(</span>TalkingClock clock<span style="color:#f92672">){</span>
	outer<span style="color:#f92672">=</span>clock<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>当在start方法中创建了TimePrinter对象后，编译器就会将this引用传递给当前的语音时钟构造器 ：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">ActionListener listener <span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> TimePrinter<span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">);</span>
</code></pre></div><p>如果有一个TimePrinter类是一个常规类，它就需要通过TalkingClock类的公有方法访问beep标志，而使用内部类可以进行改进，即不必提供仅用于访问其他类的访问器。  TimePrinter类声明为私有的。这样一来，只有TalkingClock方法才能够构造TimePrinter对象。只有内部类可以是私有类，而常规类可以具有包可见性，或公有可见性。</p>
<p><strong>内部类特殊语法规则</strong></p>
<p>内部类有一个外围的引用outer。事实上，使用外围类的引用outer表示如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">OuterClass<span style="color:#f92672">.</span><span style="color:#a6e22e">this</span>
</code></pre></div><p>表示外围类的引用 。</p>
<p>通常this限定词是多余的。不过，可以通过显式地命名将外围类的引用设置为其他的对象。例如，如果TimePrinter是一个公有内部类，对于任意语音时钟都可以构造一个TimePrinter：</p>
<pre><code>TalkingClock jabberer =new Talking
</code></pre><p><strong>局部内部类</strong></p>
<p>可以在一个方法中定义局部类。如</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">start</span><span style="color:#f92672">(){</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TimePrinter</span> <span style="color:#66d9ef">implements</span> ActionListener<span style="color:#f92672">{</span>
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> actionPerformed<span style="color:#960050;background-color:#1e0010">（</span>ActionEvent event<span style="color:#960050;background-color:#1e0010">）</span><span style="color:#f92672">{</span>
	System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">()</span>
	<span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>局部类不能用public或private访问符声明。它的作用域被限定在声明这个局部类的块中。</p>
<p>局部类有一个优势，即对外部世界可以完全隐藏起来。即使是外部类的其他代码也不能访问它。除start方法之外，没有任何方法知道TimePrinter类的存在。</p>
<p>与其他内部类相比较，局部类还有一个优点。它们不仅能够访问包含它们的外部类，还可以访问局部变量。不过，那些局部变量必须事实上为final。这说明它们一旦赋值就不会被改变。</p>
<p><strong>匿名内部类</strong></p>
<p>将局部内部类的使用再深入一步。假如只创建这个类的一个对象，就不必命名了，这种类就是匿名内部类</p>
<p>此语法确实难以理解。其含义是：创建一个实现接口的类的新对象，需要实现的方法定义在括号内。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">new</span> SuperType<span style="color:#f92672">(</span>construction parameters<span style="color:#f92672">){</span>
	inner <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">methods</span> and data
<span style="color:#f92672">}</span>
</code></pre></div><p>其中，SuperType可以是一个接口，也可以是一个需要扩展的类。</p>
<p>由于构造器的名字必须与类名相同，而匿名类没有类名，所以，匿名类不能有构造器。取而代之的是，将构造器参数传递给超类构造器。尤其是在内部类实现接口的时候，不能有任何构造参数。</p>
<p>总之，如果构造参数的闭小括号后面跟一个开大括号，正在定义的就是匿名内部类。</p>
<p>习惯的做法就是用匿名内部类实现事件监听器和其他回调。如今最好还是使用lambda表达式。</p>
<p><strong>静态内部类</strong></p>
<p>有时候，使用内部类是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象。为此，可以将内部类声明为static，以便取消产生的引用。</p>
<p>只有内部类可以声明为static。静态内部类 的对象除了没有对生成它的外围类对象的引用特权外，与其他所有内部类完全一样。必须使用静态内部类，这是由于内部类对象是在静态方法中构造的。</p>
<p>如果没有将内部类类声明为static，那么编译器就会给出错误报告：没有可用的隐式外部类类型对象初始化内部类对象。</p>
<p>在内部类不需要访问外围类对象的时候，应该使用静态内部类。有些程序员用嵌套类表示静态内部类。</p>
<p>与常规内部类不同，静态内部类可以有静态域和方法。</p>
<p>声明在接口中的内部类自动成为static和public类。</p>

    </div>
    <div class="post-footer">
      
    </div>
    <div class="post-comment">
      
      


<span id="/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%AC%94%E8%AE%B0-%E6%8E%A5%E5%8F%A3lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB-/" class="leancloud_visitors" data-flag-title="Java核心技术第六章笔记-接口、lambda表达式和内部类">
    <span class="post-meta-item-text">文章阅读量 </span>
    <span class="leancloud-visitors-count">1000000</span>
    <p></p>
  </span>
<div id="vcomments"></div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script type="text/javascript">
  new Valine({
    el: '#vcomments' ,
    appId: 'cScQmclMsD4OOWCclCP1pNsz-gzGzoHsz',
    appKey: 'dtSaHLmdH3J4ICVVInYg9YFM',
    notify:  false ,
  verify:  false ,
  avatar:'mm',
    placeholder: '说点什么吧...',
    visitor:  true 
  });
</script>

    </div>
  </article>

    </main>
  </body>
</html>
