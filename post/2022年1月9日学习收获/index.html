<!doctype html>
<html lang="en-us">
  <head>
    <title>2022年1月9日学习收获 // Zereal-宋致远技术博客</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.72.0" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75，minimum-scale=0.75, maximum-scale=0.75, user-scalable=no" />
    <meta name="author" content="Zereal" />
    <meta name="description" content="" />
    <meta name="referrer" content="never"/>
    <link rel="stylesheet" href="https://zereals7.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="2022年1月9日学习收获"/>
<meta name="twitter:description" content="【现代操作系统】 线程状态之间的转换与进程状态之间的转换是一样的。
每个线程有其自己的堆栈，每个线程的堆栈有一帧，供各个被调用但是还没有从中返回的过程使用。在该栈帧帧存放了相应过程的局部变量以及过程调用完成之后使用的返回地址。通常每个线程会调用不同的过程，从而有一个各自不同的执行历史。这就是为什么每个线程需要有自己堆栈的原因。
每个进程中的内容：地址空间、全局变量、打开文件、子进程、即将发生的定时器、信号与信号处理程序、账户信息
每个线程中的内容：程序计数器、寄存器、堆栈、状态
所有线程都是平等的
线程无法利用时间中断强制线程让出CPU，需要用线程调用thread.yield,这会允许线程自动放弃CPU从而让另一个线程运行。
有两种主要方法实现线程包：在用户空间中和在内核中。 在用户空间管理进程时，每个进程有其专用的线程表，用来跟踪该进程中的线程。与内核中的进程表类似，不过它仅仅记录各个进程的属性。该线程表由运行时系统管理。当一个线程转换到就绪状态获阻塞状态时，在该线程表中存放重新启动该线程所需的信息，与内核在进程表中存放进程的信息完全一样。
进行现场切换至少比陷入内核要快一个数量级，这是用户级线程包极大的优点。
线程与进程的关键差别，进行切换时不需要陷入内核，不需要进行上下文切换，也不需要对内存高速缓存进行刷新，这就使得线程调度非常快捷。
用户级线程的另一个优点，它允许每个进程有自己定制的调度算法。有垃圾收集线程的应用程序就不用担心线程在不合适的时刻停止。用户级线程还有较好的可扩展性，这是因为在内核空间中内核线程需要一些固定表格空间和堆栈空间。如果内核级线程的数量非常大，就会出现问题。
用户级线程的问题：1.如何实现阻塞系统的调用。使用线程的一个主要目标是，首先要允许每个线程使用阻塞调用，但是还要避免被阻塞的线程影响其他的线程。有了阻塞系统调用，这个目标不是轻易能够实现的。在系统调用周围从事检查的代码称为包装器。
内核中实现线程,不再需要运行时系统.每个进程中也没有线程表.线程通过系统调用更新线程表完成线程创建和撤销工作。
内核中的线程表保存了每个线程的寄存器、状态和其他信息。内核还维护了传统的进程表，以便跟踪进程的状态。
所有能够阻塞线程的调用都以系统调用的形式实现，与运行时系统过程相比，代价是相当可观的。当一个线程阻塞时，内核根据其选择，可以运行同一个进程中的另一个线程或者运行另一个进程中的线程（若有一个就绪进程）或者运行另一个进程中的线程。在用户级线程中，运行时系统始终运行自己进程中的线程，直到内核剥夺它的CPU为止。
线程回收，把要撤销的线程标记为不可运行的，但是其内核数据结构没有受到一些。稍后在必须创建一个新线程时，就重新启动某个旧线程，从而节省一些开销。在用户级线程中线程回收也是可能的，但是由于其线程管理的代价很小，所以没必要进行这项工作。
可以使用内核级线程，然后讲用户级线程与某些或者全部内核级线程多路复用起来。编程人员可以决定有多少个内核级线程和多少个用户级线程彼此多路复用。内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。每个内核级线程有一个可以轮流使用的用户级线程集合。
【深入理解计算机系统】 操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容。
当操作系统决定把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权转移到新进程。新进程就会从它上次停止的地方开始。
以shell和hello进程为例。shell通过系统调用会将控制权传递给操作系统。操作系统保持原来进程的上下文，创建一个新进程及其上下文，然后将控制权传给hello进程。hello进程终止后，操作系统恢复shell进程的上下文，并将控制权传回给他，shell进程会继续等待下一个命令行输入。
从一个进程到另一个进程的转换是由操作系统内核管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的系统调用指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。
内核不是一个独立的进程，相反，它是系统管理全部进程所用代码和数据结构的集合。
一个进程由多个被称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。
多线程之间比多进程之间更容易共享数据，线程一般也比进程更加的高效。
每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区有专门的功能。
程序代码和数据
堆。代码和数据区一开始运行时就被指定了大小，与此不同，堆可以在运行时动态地扩展和收缩。
共享库：地址中间的部分用来存放标准库和数学库这样的共享库的代码和数据的区域。
栈。位于虚拟地址空间顶部。编译器用它来实现函数调用。栈在程序执行期间也可以动态的扩展和收缩。每次我们调用一个函数时，栈就会增长；从一个函数返回时栈就会收缩。
内核虚拟内存：地址底部空间是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。它们必须调用内核来执行这些操作。
文件为字节序列。每个IO设备，包括磁盘、键盘、显示器，甚至是网络都可以看成是文件。系统中所有输入输出都是通过使用一小组称为UnixI/O的系统函数调用读写文件实现的。
同一个程序可以中使用不同磁盘技术的不同系统上运行。
现代系统经常通过网络和其他系统连接到一起。从一个单独的系统来看，网络可视为一个IO设备。
【JavaWeb】 CS结构是客户端和服务器。服务器端采用高性能PC机或工作站，并采用大型数据库系统，客户端需要安装专业的客户端软件。
这种结构可以充分利用两端硬件环境的优势，将任务合理地分配到客户端和服务器，从而降低了系统的通用开销。
BS即浏览器/服务器结构。客户端不需要开发任何用户界面，而是通过Web浏览器向Web服务器发送请求，由Web服务器进行处理，并将处理结果逐级传回客户端。
CS结构的开发和维护成本比BS高。采用CS结构时，对于不同客户端要开发不同的程序，而且软件的安装、调试和升级均需要在所有的客户机上进行。如果换成BS结构，则在软件升级后，只需要将服务器的软件升级到最新的版本。只要重新登录系统，即可使用最新版本的软件。
CS结构的客户端不仅负责与用户的交互，收集用户信息，而且还需要完成通过网络向服务器请求，对数据库、电子表格或文档等信息的处理工作。应用程序越复杂、客户端程序也越庞大，这也给软件的维护工作带来了很大的困难。
而BS结构的客户端把事务处理逻辑部分交给了服务器，由服务器进行处理，客户端只需要进行显示，这样将使应用程序服务器的运行数据负荷较重，一单发生服务器崩溃，后果将不堪设想。因此，许多单位都备有数据库存储服务器，以防万一。
CS安全性高于BS。
Web应用程序大体可以分为两种，即静态网站和动态网站。
【Springboot】 优点：
 创建独立的Spring程序 嵌入的Tomcat、Jetty、或者Undertow,无须部署WAR文件 允许通过Maven来根据需要获取starter 尽可能地自动配置Spring 提供生产就绪型功能，如指标、健康检查和外部配置 绝对没有代码生成，对XML没有要求配置  近年来微服务的留下，越来越多的企业需要快速的开发，而Springboot除了以注解为主的开发，还有其他的绑定，例如对服务器进行了绑定和默认对Spring的最大化配置，所以开发者能尽快进行开发代码、发布和测试自己的项目。这符合现今微服务快速开发、测试和部署的需要。
SpringBoot是一个基于Spring框架搭建起来的应用，其次它会嵌入Tomcat、Jetty或者Undertow等服务器，并且不需要传统的WAR文件进行部署，也就是说搭建SpringBoot项目不需要单独下载Tomcat等传统服务器；同时提供通过Maven或者Gradle依赖的starter,这些starter可以直接获取开发所需的相关包，通过这些starter项目就能以Java Application的形式运行SpringBoot的项目，而无需其他服务器配置；对于配置，SpringBoot提供Spring框架的最大自动化配置，大量使用自动配置，使得开发者对Spring的配置尽量减少；此外还提供了一些监测、自动检测的功能和外部配置，与此同时没有附加代码和XML的配置要求。
约定优于配置，是SpringBoot的主导思想。
对于SpringBoot而言，大部分情况下存在默认配置，你甚至可以在没有任何定义的情况下使用Spring框架，如果需要自定义也只需要在配置文件配置一些属性便可以，十分便捷。而对于部署这些项目必须的功能，SpringBoot提供starter的依赖。例如，spring-boot-starter-web捆绑了Spring MVC所依赖的包，spring-boot-starter-tomcat绑定了内嵌的Tomcat,这样使得开发者能够尽可能快地搭建开发环境，快速进行开发和部署，这就是SpringBoot的特色。
​
【docker】 云时代最为看重的是凭借虚拟化技术所构建的集群处理能力。
容器技术非常优雅，充分利用了操作系统本身已有的机制和特性，可以实现远超传统虚拟机的轻量化虚拟机。
Docker是基于Go语言实现的开源容器项目。
docker对应用的封装、分发、部署、运行生命周期进行管理，达到应用组件级别的一次封装，到处运行。这里的应用程序组件可以是一个Web应用、一个编译环境，也可以是一套数据库平台服务，甚至是一个操作系统集群。
Docker提供了高效、敏捷和轻量级的容器方案，并支持部署到本地环境和多种主流云平台。可以说，Docker首次为应用的开发、运行和部署提供了一站式的解决方案。
容器有效的将由单个操作系统管理的资源划分到孤立的组中，以更好地在孤立的组之间平衡有冲突的资源使用需求。与虚拟化相比，这样既不需要指令级模拟，也不需要即时编译。容器可以在核心CPU本地运行指令，而不需要任何专门的解释机制。此外也避免了准虚拟化和系统调用替换中的复杂性。
Docker提供了各种容器管理工具（如分发、版本、移植等），让用户无须关注底层的操作，更加简单明了地管理和使用容器，其次Docker通过引入分层文件系统构建和高效的镜像机制，降低了迁移难度，极大改善了用户体验。用户操作Docker容器就绪操作应用自身一样简单。
可以将Docker理解为一种轻量级的沙盒。每个容器内运行着一个应用，不同的容器相互隔离，容器之间也可以通过网络互相通信。容器的创建和停止十分迅速，几乎跟创建和终止原生应用一致；另外，容器自身对系统资源的额外需求也十分有限，远远低于传统虚拟机。很多时候，甚至直接把容器当作应用本身也没有任何问题。"/>

    <meta property="og:title" content="2022年1月9日学习收获" />
<meta property="og:description" content="【现代操作系统】 线程状态之间的转换与进程状态之间的转换是一样的。
每个线程有其自己的堆栈，每个线程的堆栈有一帧，供各个被调用但是还没有从中返回的过程使用。在该栈帧帧存放了相应过程的局部变量以及过程调用完成之后使用的返回地址。通常每个线程会调用不同的过程，从而有一个各自不同的执行历史。这就是为什么每个线程需要有自己堆栈的原因。
每个进程中的内容：地址空间、全局变量、打开文件、子进程、即将发生的定时器、信号与信号处理程序、账户信息
每个线程中的内容：程序计数器、寄存器、堆栈、状态
所有线程都是平等的
线程无法利用时间中断强制线程让出CPU，需要用线程调用thread.yield,这会允许线程自动放弃CPU从而让另一个线程运行。
有两种主要方法实现线程包：在用户空间中和在内核中。 在用户空间管理进程时，每个进程有其专用的线程表，用来跟踪该进程中的线程。与内核中的进程表类似，不过它仅仅记录各个进程的属性。该线程表由运行时系统管理。当一个线程转换到就绪状态获阻塞状态时，在该线程表中存放重新启动该线程所需的信息，与内核在进程表中存放进程的信息完全一样。
进行现场切换至少比陷入内核要快一个数量级，这是用户级线程包极大的优点。
线程与进程的关键差别，进行切换时不需要陷入内核，不需要进行上下文切换，也不需要对内存高速缓存进行刷新，这就使得线程调度非常快捷。
用户级线程的另一个优点，它允许每个进程有自己定制的调度算法。有垃圾收集线程的应用程序就不用担心线程在不合适的时刻停止。用户级线程还有较好的可扩展性，这是因为在内核空间中内核线程需要一些固定表格空间和堆栈空间。如果内核级线程的数量非常大，就会出现问题。
用户级线程的问题：1.如何实现阻塞系统的调用。使用线程的一个主要目标是，首先要允许每个线程使用阻塞调用，但是还要避免被阻塞的线程影响其他的线程。有了阻塞系统调用，这个目标不是轻易能够实现的。在系统调用周围从事检查的代码称为包装器。
内核中实现线程,不再需要运行时系统.每个进程中也没有线程表.线程通过系统调用更新线程表完成线程创建和撤销工作。
内核中的线程表保存了每个线程的寄存器、状态和其他信息。内核还维护了传统的进程表，以便跟踪进程的状态。
所有能够阻塞线程的调用都以系统调用的形式实现，与运行时系统过程相比，代价是相当可观的。当一个线程阻塞时，内核根据其选择，可以运行同一个进程中的另一个线程或者运行另一个进程中的线程（若有一个就绪进程）或者运行另一个进程中的线程。在用户级线程中，运行时系统始终运行自己进程中的线程，直到内核剥夺它的CPU为止。
线程回收，把要撤销的线程标记为不可运行的，但是其内核数据结构没有受到一些。稍后在必须创建一个新线程时，就重新启动某个旧线程，从而节省一些开销。在用户级线程中线程回收也是可能的，但是由于其线程管理的代价很小，所以没必要进行这项工作。
可以使用内核级线程，然后讲用户级线程与某些或者全部内核级线程多路复用起来。编程人员可以决定有多少个内核级线程和多少个用户级线程彼此多路复用。内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。每个内核级线程有一个可以轮流使用的用户级线程集合。
【深入理解计算机系统】 操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容。
当操作系统决定把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权转移到新进程。新进程就会从它上次停止的地方开始。
以shell和hello进程为例。shell通过系统调用会将控制权传递给操作系统。操作系统保持原来进程的上下文，创建一个新进程及其上下文，然后将控制权传给hello进程。hello进程终止后，操作系统恢复shell进程的上下文，并将控制权传回给他，shell进程会继续等待下一个命令行输入。
从一个进程到另一个进程的转换是由操作系统内核管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的系统调用指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。
内核不是一个独立的进程，相反，它是系统管理全部进程所用代码和数据结构的集合。
一个进程由多个被称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。
多线程之间比多进程之间更容易共享数据，线程一般也比进程更加的高效。
每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区有专门的功能。
程序代码和数据
堆。代码和数据区一开始运行时就被指定了大小，与此不同，堆可以在运行时动态地扩展和收缩。
共享库：地址中间的部分用来存放标准库和数学库这样的共享库的代码和数据的区域。
栈。位于虚拟地址空间顶部。编译器用它来实现函数调用。栈在程序执行期间也可以动态的扩展和收缩。每次我们调用一个函数时，栈就会增长；从一个函数返回时栈就会收缩。
内核虚拟内存：地址底部空间是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。它们必须调用内核来执行这些操作。
文件为字节序列。每个IO设备，包括磁盘、键盘、显示器，甚至是网络都可以看成是文件。系统中所有输入输出都是通过使用一小组称为UnixI/O的系统函数调用读写文件实现的。
同一个程序可以中使用不同磁盘技术的不同系统上运行。
现代系统经常通过网络和其他系统连接到一起。从一个单独的系统来看，网络可视为一个IO设备。
【JavaWeb】 CS结构是客户端和服务器。服务器端采用高性能PC机或工作站，并采用大型数据库系统，客户端需要安装专业的客户端软件。
这种结构可以充分利用两端硬件环境的优势，将任务合理地分配到客户端和服务器，从而降低了系统的通用开销。
BS即浏览器/服务器结构。客户端不需要开发任何用户界面，而是通过Web浏览器向Web服务器发送请求，由Web服务器进行处理，并将处理结果逐级传回客户端。
CS结构的开发和维护成本比BS高。采用CS结构时，对于不同客户端要开发不同的程序，而且软件的安装、调试和升级均需要在所有的客户机上进行。如果换成BS结构，则在软件升级后，只需要将服务器的软件升级到最新的版本。只要重新登录系统，即可使用最新版本的软件。
CS结构的客户端不仅负责与用户的交互，收集用户信息，而且还需要完成通过网络向服务器请求，对数据库、电子表格或文档等信息的处理工作。应用程序越复杂、客户端程序也越庞大，这也给软件的维护工作带来了很大的困难。
而BS结构的客户端把事务处理逻辑部分交给了服务器，由服务器进行处理，客户端只需要进行显示，这样将使应用程序服务器的运行数据负荷较重，一单发生服务器崩溃，后果将不堪设想。因此，许多单位都备有数据库存储服务器，以防万一。
CS安全性高于BS。
Web应用程序大体可以分为两种，即静态网站和动态网站。
【Springboot】 优点：
 创建独立的Spring程序 嵌入的Tomcat、Jetty、或者Undertow,无须部署WAR文件 允许通过Maven来根据需要获取starter 尽可能地自动配置Spring 提供生产就绪型功能，如指标、健康检查和外部配置 绝对没有代码生成，对XML没有要求配置  近年来微服务的留下，越来越多的企业需要快速的开发，而Springboot除了以注解为主的开发，还有其他的绑定，例如对服务器进行了绑定和默认对Spring的最大化配置，所以开发者能尽快进行开发代码、发布和测试自己的项目。这符合现今微服务快速开发、测试和部署的需要。
SpringBoot是一个基于Spring框架搭建起来的应用，其次它会嵌入Tomcat、Jetty或者Undertow等服务器，并且不需要传统的WAR文件进行部署，也就是说搭建SpringBoot项目不需要单独下载Tomcat等传统服务器；同时提供通过Maven或者Gradle依赖的starter,这些starter可以直接获取开发所需的相关包，通过这些starter项目就能以Java Application的形式运行SpringBoot的项目，而无需其他服务器配置；对于配置，SpringBoot提供Spring框架的最大自动化配置，大量使用自动配置，使得开发者对Spring的配置尽量减少；此外还提供了一些监测、自动检测的功能和外部配置，与此同时没有附加代码和XML的配置要求。
约定优于配置，是SpringBoot的主导思想。
对于SpringBoot而言，大部分情况下存在默认配置，你甚至可以在没有任何定义的情况下使用Spring框架，如果需要自定义也只需要在配置文件配置一些属性便可以，十分便捷。而对于部署这些项目必须的功能，SpringBoot提供starter的依赖。例如，spring-boot-starter-web捆绑了Spring MVC所依赖的包，spring-boot-starter-tomcat绑定了内嵌的Tomcat,这样使得开发者能够尽可能快地搭建开发环境，快速进行开发和部署，这就是SpringBoot的特色。
​
【docker】 云时代最为看重的是凭借虚拟化技术所构建的集群处理能力。
容器技术非常优雅，充分利用了操作系统本身已有的机制和特性，可以实现远超传统虚拟机的轻量化虚拟机。
Docker是基于Go语言实现的开源容器项目。
docker对应用的封装、分发、部署、运行生命周期进行管理，达到应用组件级别的一次封装，到处运行。这里的应用程序组件可以是一个Web应用、一个编译环境，也可以是一套数据库平台服务，甚至是一个操作系统集群。
Docker提供了高效、敏捷和轻量级的容器方案，并支持部署到本地环境和多种主流云平台。可以说，Docker首次为应用的开发、运行和部署提供了一站式的解决方案。
容器有效的将由单个操作系统管理的资源划分到孤立的组中，以更好地在孤立的组之间平衡有冲突的资源使用需求。与虚拟化相比，这样既不需要指令级模拟，也不需要即时编译。容器可以在核心CPU本地运行指令，而不需要任何专门的解释机制。此外也避免了准虚拟化和系统调用替换中的复杂性。
Docker提供了各种容器管理工具（如分发、版本、移植等），让用户无须关注底层的操作，更加简单明了地管理和使用容器，其次Docker通过引入分层文件系统构建和高效的镜像机制，降低了迁移难度，极大改善了用户体验。用户操作Docker容器就绪操作应用自身一样简单。
可以将Docker理解为一种轻量级的沙盒。每个容器内运行着一个应用，不同的容器相互隔离，容器之间也可以通过网络互相通信。容器的创建和停止十分迅速，几乎跟创建和终止原生应用一致；另外，容器自身对系统资源的额外需求也十分有限，远远低于传统虚拟机。很多时候，甚至直接把容器当作应用本身也没有任何问题。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zereals7.github.io/post/2022%E5%B9%B41%E6%9C%889%E6%97%A5%E5%AD%A6%E4%B9%A0%E6%94%B6%E8%8E%B7/" />
<meta property="article:published_time" content="2021-10-07T15:43:10+08:00" />
<meta property="article:modified_time" content="2021-10-07T15:43:10+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://zereals7.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="Zereal" /></a>
      <h1>Zereal</h1>
      <p>Java coder</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/ZerealS7" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">2022年1月9日学习收获</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Oct 7, 2021
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div></div>
    </header>
    <div class="post-content">
      <h1 id="现代操作系统">【现代操作系统】</h1>
<p>线程状态之间的转换与进程状态之间的转换是一样的。</p>
<p>每个线程有其自己的堆栈，每个线程的堆栈有一帧，供各个被调用但是还没有从中返回的过程使用。在该栈帧帧存放了相应过程的局部变量以及过程调用完成之后使用的返回地址。通常每个线程会调用不同的过程，从而有一个各自不同的执行历史。这就是为什么每个线程需要有自己堆栈的原因。</p>
<p>每个进程中的内容：地址空间、全局变量、打开文件、子进程、即将发生的定时器、信号与信号处理程序、账户信息</p>
<p>每个线程中的内容：程序计数器、寄存器、堆栈、状态</p>
<p>所有线程都是平等的</p>
<p>线程无法利用时间中断强制线程让出CPU，需要用线程调用thread.yield,这会允许线程自动放弃CPU从而让另一个线程运行。</p>
<p>有两种主要方法实现线程包：在用户空间中和在内核中。 在用户空间管理进程时，每个进程有其专用的线程表，用来跟踪该进程中的线程。与内核中的进程表类似，不过它仅仅记录各个进程的属性。该线程表由运行时系统管理。当一个线程转换到就绪状态获阻塞状态时，在该线程表中存放重新启动该线程所需的信息，与内核在进程表中存放进程的信息完全一样。</p>
<p>进行现场切换至少比陷入内核要快一个数量级，这是用户级线程包极大的优点。</p>
<p>线程与进程的关键差别，进行切换时不需要陷入内核，不需要进行上下文切换，也不需要对内存高速缓存进行刷新，这就使得线程调度非常快捷。</p>
<p>用户级线程的另一个优点，它允许每个进程有自己定制的调度算法。有垃圾收集线程的应用程序就不用担心线程在不合适的时刻停止。用户级线程还有较好的可扩展性，这是因为在内核空间中内核线程需要一些固定表格空间和堆栈空间。如果内核级线程的数量非常大，就会出现问题。</p>
<p>用户级线程的问题：1.如何实现阻塞系统的调用。使用线程的一个主要目标是，首先要允许每个线程使用阻塞调用，但是还要避免被阻塞的线程影响其他的线程。有了阻塞系统调用，这个目标不是轻易能够实现的。在系统调用周围从事检查的代码称为包装器。</p>
<p>内核中实现线程,不再需要运行时系统.每个进程中也没有线程表.线程通过系统调用更新线程表完成线程创建和撤销工作。</p>
<p>内核中的线程表保存了每个线程的寄存器、状态和其他信息。内核还维护了传统的进程表，以便跟踪进程的状态。</p>
<p>所有能够阻塞线程的调用都以系统调用的形式实现，与运行时系统过程相比，代价是相当可观的。当一个线程阻塞时，内核根据其选择，可以运行同一个进程中的另一个线程或者运行另一个进程中的线程（若有一个就绪进程）或者运行另一个进程中的线程。在用户级线程中，运行时系统始终运行自己进程中的线程，直到内核剥夺它的CPU为止。</p>
<p>线程回收，把要撤销的线程标记为不可运行的，但是其内核数据结构没有受到一些。稍后在必须创建一个新线程时，就重新启动某个旧线程，从而节省一些开销。在用户级线程中线程回收也是可能的，但是由于其线程管理的代价很小，所以没必要进行这项工作。</p>
<p>可以使用内核级线程，然后讲用户级线程与某些或者全部内核级线程多路复用起来。编程人员可以决定有多少个内核级线程和多少个用户级线程彼此多路复用。内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。每个内核级线程有一个可以轮流使用的用户级线程集合。</p>
<h1 id="深入理解计算机系统">【深入理解计算机系统】</h1>
<p>操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容。</p>
<p>当操作系统决定把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权转移到新进程。新进程就会从它上次停止的地方开始。</p>
<p>以shell和hello进程为例。shell通过系统调用会将控制权传递给操作系统。操作系统保持原来进程的上下文，创建一个新进程及其上下文，然后将控制权传给hello进程。hello进程终止后，操作系统恢复shell进程的上下文，并将控制权传回给他，shell进程会继续等待下一个命令行输入。</p>
<p>从一个进程到另一个进程的转换是由操作系统内核管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的系统调用指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。</p>
<p>内核不是一个独立的进程，相反，它是系统管理全部进程所用代码和数据结构的集合。</p>
<p>一个进程由多个被称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。</p>
<p>多线程之间比多进程之间更容易共享数据，线程一般也比进程更加的高效。</p>
<p>每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区有专门的功能。</p>
<p>程序代码和数据</p>
<p>堆。代码和数据区一开始运行时就被指定了大小，与此不同，堆可以在运行时动态地扩展和收缩。</p>
<p>共享库：地址中间的部分用来存放标准库和数学库这样的共享库的代码和数据的区域。</p>
<p>栈。位于虚拟地址空间顶部。编译器用它来实现函数调用。栈在程序执行期间也可以动态的扩展和收缩。每次我们调用一个函数时，栈就会增长；从一个函数返回时栈就会收缩。</p>
<p>内核虚拟内存：地址底部空间是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。它们必须调用内核来执行这些操作。</p>
<p>文件为字节序列。每个IO设备，包括磁盘、键盘、显示器，甚至是网络都可以看成是文件。系统中所有输入输出都是通过使用一小组称为UnixI/O的系统函数调用读写文件实现的。</p>
<p>同一个程序可以中使用不同磁盘技术的不同系统上运行。</p>
<p>现代系统经常通过网络和其他系统连接到一起。从一个单独的系统来看，网络可视为一个IO设备。</p>
<h1 id="javaweb">【JavaWeb】</h1>
<p>CS结构是客户端和服务器。服务器端采用高性能PC机或工作站，并采用大型数据库系统，客户端需要安装专业的客户端软件。</p>
<p>这种结构可以充分利用两端硬件环境的优势，将任务合理地分配到客户端和服务器，从而降低了系统的通用开销。</p>
<p>BS即浏览器/服务器结构。客户端不需要开发任何用户界面，而是通过Web浏览器向Web服务器发送请求，由Web服务器进行处理，并将处理结果逐级传回客户端。</p>
<p>CS结构的开发和维护成本比BS高。采用CS结构时，对于不同客户端要开发不同的程序，而且软件的安装、调试和升级均需要在所有的客户机上进行。如果换成BS结构，则在软件升级后，只需要将服务器的软件升级到最新的版本。只要重新登录系统，即可使用最新版本的软件。</p>
<p>CS结构的客户端不仅负责与用户的交互，收集用户信息，而且还需要完成通过网络向服务器请求，对数据库、电子表格或文档等信息的处理工作。应用程序越复杂、客户端程序也越庞大，这也给软件的维护工作带来了很大的困难。</p>
<p>而BS结构的客户端把事务处理逻辑部分交给了服务器，由服务器进行处理，客户端只需要进行显示，这样将使应用程序服务器的运行数据负荷较重，一单发生服务器崩溃，后果将不堪设想。因此，许多单位都备有数据库存储服务器，以防万一。</p>
<p>CS安全性高于BS。</p>
<p>Web应用程序大体可以分为两种，即静态网站和动态网站。</p>
<h1 id="springboot">【Springboot】</h1>
<p>优点：</p>
<ul>
<li>创建独立的Spring程序</li>
<li>嵌入的Tomcat、Jetty、或者Undertow,无须部署WAR文件</li>
<li>允许通过Maven来根据需要获取starter</li>
<li>尽可能地自动配置Spring</li>
<li>提供生产就绪型功能，如指标、健康检查和外部配置</li>
<li>绝对没有代码生成，对XML没有要求配置</li>
</ul>
<p>近年来微服务的留下，越来越多的企业需要快速的开发，而Springboot除了以注解为主的开发，还有其他的绑定，例如对服务器进行了绑定和默认对Spring的最大化配置，所以开发者能尽快进行开发代码、发布和测试自己的项目。这符合现今微服务快速开发、测试和部署的需要。</p>
<p>SpringBoot是一个基于Spring框架搭建起来的应用，其次它会嵌入Tomcat、Jetty或者Undertow等服务器，并且不需要传统的WAR文件进行部署，也就是说搭建SpringBoot项目不需要单独下载Tomcat等传统服务器；同时提供通过Maven或者Gradle依赖的starter,这些starter可以直接获取开发所需的相关包，通过这些starter项目就能以Java Application的形式运行SpringBoot的项目，而无需其他服务器配置；对于配置，SpringBoot提供Spring框架的最大自动化配置，大量使用自动配置，使得开发者对Spring的配置尽量减少；此外还提供了一些监测、自动检测的功能和外部配置，与此同时没有附加代码和XML的配置要求。</p>
<p>约定优于配置，是SpringBoot的主导思想。</p>
<p>对于SpringBoot而言，大部分情况下存在默认配置，你甚至可以在没有任何定义的情况下使用Spring框架，如果需要自定义也只需要在配置文件配置一些属性便可以，十分便捷。而对于部署这些项目必须的功能，SpringBoot提供starter的依赖。例如，spring-boot-starter-web捆绑了Spring MVC所依赖的包，spring-boot-starter-tomcat绑定了内嵌的Tomcat,这样使得开发者能够尽可能快地搭建开发环境，快速进行开发和部署，这就是SpringBoot的特色。</p>
<p>​</p>
<h1 id="docker">【docker】</h1>
<p>云时代最为看重的是凭借虚拟化技术所构建的集群处理能力。</p>
<p>容器技术非常优雅，充分利用了操作系统本身已有的机制和特性，可以实现远超传统虚拟机的轻量化虚拟机。</p>
<p>Docker是基于Go语言实现的开源容器项目。</p>
<p>docker对应用的封装、分发、部署、运行生命周期进行管理，达到应用组件级别的一次封装，到处运行。这里的应用程序组件可以是一个Web应用、一个编译环境，也可以是一套数据库平台服务，甚至是一个操作系统集群。</p>
<p>Docker提供了高效、敏捷和轻量级的容器方案，并支持部署到本地环境和多种主流云平台。可以说，Docker首次为应用的开发、运行和部署提供了一站式的解决方案。</p>
<p>容器有效的将由单个操作系统管理的资源划分到孤立的组中，以更好地在孤立的组之间平衡有冲突的资源使用需求。与虚拟化相比，这样既不需要指令级模拟，也不需要即时编译。容器可以在核心CPU本地运行指令，而不需要任何专门的解释机制。此外也避免了准虚拟化和系统调用替换中的复杂性。</p>
<p>Docker提供了各种容器管理工具（如分发、版本、移植等），让用户无须关注底层的操作，更加简单明了地管理和使用容器，其次Docker通过引入分层文件系统构建和高效的镜像机制，降低了迁移难度，极大改善了用户体验。用户操作Docker容器就绪操作应用自身一样简单。</p>
<p>可以将Docker理解为一种轻量级的沙盒。每个容器内运行着一个应用，不同的容器相互隔离，容器之间也可以通过网络互相通信。容器的创建和停止十分迅速，几乎跟创建和终止原生应用一致；另外，容器自身对系统资源的额外需求也十分有限，远远低于传统虚拟机。很多时候，甚至直接把容器当作应用本身也没有任何问题。</p>
<h1 id="计算机网络">【计算机网络】</h1>
<p>端系统通过通信链路和分组交换机连接到一起。</p>
<p>通信链路由不同类型的物理媒体组成，这些物理媒体包括同轴电缆、铜线、光纤和无线电频谱。不同的链路能够以不同的速率传输数据，链路的传输速率以比特每秒度量。</p>
<p>当一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节。由此形成的信息包就是分组。</p>
<p>这些分组通过网络发送到目的端系统，在那里被装配成初始数据。</p>
<p>分组交换机:网络层路由器，链路层交换机。</p>
<p>发送端到接收端的叫做路径。</p>
<p>端系统通过英特网服务提供商ISP接入互联网。</p>
<p>端系统、分组交换机和其他因特网部件都要运行一系列协议，这些协议控制因特网中信息的接收和发送。</p>
<p>TCP和IP是因特网中两个最为重要的协议。</p>
<p>IP协议定义了在路由器和端系统之间发送和接收的分组格式。因特网的主要协议统称为TCP/IP。</p>
<p>如应用程序涉及多个相互交换的端系统，故它们被称为分布式应用程序。</p>
<p>与因特网相连的端系统提供了一个套接字接口，该接口规定了运行在一个端系统上的程序请求因特网基础设施向运行在另一个端系统上的程序交付数据的方式。</p>
<p>协议 通信实体的活动都要受协议的制约。</p>
<p>协议定义了在两个或多个通信实体之间交换报文的格式和顺序，以及报文发送或接收一条报文或其他事件所采取的动作。</p>
<h1 id="前端基础">【前端基础】</h1>
<p>HTML文档一般都应包含两部分：头部区域和主体区域。</p>
<p>基本结构包括三个标签：<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->。</p>
<p>其中<!-- raw HTML omitted -->标签标识HTML文档</p>
<!-- raw HTML omitted -->
<pre><code>&lt;body&gt;标识主体区域
    包含网页显示的内容
</code></pre>
<p>在HTML中绝大多数元素都有起始和结束标签合在一起构成一个标签。</p>
<p>元素的属性包括属性名称和属性值，中间通过等号进行连接。多个属性之间通过空格行进行分隔。</p>
<p>HTML4文档的创作应包括如下内容：</p>
<p>必须在首行定义文档的类型，过渡型文档可省略。</p>
<!-- raw HTML omitted -->
<p>必须定义文档的字符编码</p>

    </div>
    <div class="post-footer">
      
    </div>
    <div class="post-comment">
      
      


<span id="/post/2022%E5%B9%B41%E6%9C%889%E6%97%A5%E5%AD%A6%E4%B9%A0%E6%94%B6%E8%8E%B7/" class="leancloud_visitors" data-flag-title="2022年1月9日学习收获">
    <span class="post-meta-item-text">文章阅读量 </span>
    <span class="leancloud-visitors-count">1000000</span>
    <p></p>
  </span>
<div id="vcomments"></div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script type="text/javascript">
  new Valine({
    el: '#vcomments' ,
    appId: 'cScQmclMsD4OOWCclCP1pNsz-gzGzoHsz',
    appKey: 'dtSaHLmdH3J4ICVVInYg9YFM',
    notify:  false ,
  verify:  false ,
  avatar:'mm',
    placeholder: '说点什么吧...',
    visitor:  true 
  });
</script>

    </div>
  </article>

    </main>
  </body>
</html>
