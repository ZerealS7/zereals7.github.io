<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Zereal-宋致远技术博客</title>
    <link>https://zereals7.github.io/</link>
    <description>Recent content on Zereal-宋致远技术博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 14 Apr 2021 21:56:15 +0800</lastBuildDate>
    
	<atom:link href="https://zereals7.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>SSM入门和Redis</title>
      <link>https://zereals7.github.io/post/ssm/</link>
      <pubDate>Wed, 14 Apr 2021 21:56:15 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/ssm/</guid>
      <description>1.1 Spring框架 1.1.1 Spring IOC简介 IOC是一个容器，在Spring中，它会认为一切Java资源都是Java Bean,容器的目标就是管理这些Bean和它们之间的关系。
各个Java Bean之间会存在一定的依赖关系，容器能够对其进行管理。SPringIOC管理对象和依赖关系，采用的不是认为主动创建，而是SPring IOC自己通过描述创建的。
当需要某个实现类，可以通过配置实现依赖的注入 。这是一种被动的行为，控制权在IOC容器，它会根据描述找到使用者需要的资源。
当需要使用某个实现类时，通过配置信息就可以完成了。不需要用new来创建对象，依赖关系也可以通过配置完成，从而即插即拔地管理它们之间的关系。
总结：你不需要去找资源，只要向SPring IOC容器描述所需资源，SPring IOC自己会找到你需要的资源，这就是SPring IOC的理念。这样就把Bean之间的依赖关系解耦了，更容易写出结构清晰的程序。除此之外，SPring IOC还提供对Java Bean生命周期的管理，可以延迟加载，可以在其生命周期内定义一些行为等，更加方便有效地使用和管理Java资源，这就是SPring IOC的魅力。
1.1.2 SPring AOP IOC的目标时为了管理Java Bean,而Bean是Java面向对象的基础设计。但是，有些情况面向对象没办法处理。举个例子，生产部门的订单、生产部门、财务部门三者符合OOP的设计理念。订单发出，生产部门审批通过准备付款，但是财务部门发现订单的价格超支了，需要取消当你孤单。显然超支限定已经不只是影响财务部门了，还会影响生产部门之前所做的审批，需要把它们作废。我们把预算超支这个条件称为切面，它影响了订单、生产部门、财务部门三个OOP对象。在现实中，这样的切面条件跨越了3个甚至更多的对象，并且影响了它们的协作。所以只用OOP并不完善，还需要面向切面的编程，通过它去管理在切面上的某些对象的协作。
Spring AOP常用于数据库事务的编程，在默认的情况下，只要Spring接收到了异常信息，它会将数据库的事务回滚，从而保证数据的一致性。Spring提供了隔离级别和传播行为去控制复杂的事务。
1.2 MyBatis简介 MyBatis优势在于灵活，他几乎可以代替JDBC，同时提供了接口编程。目前MyBatis的数据访问层DAO是不需要实现类的，只需要一个接口和XML，或是注解。MyBatis提供自动映射，动态SQL、级联、缓存、注解、代码和SQL分离等特性。同时也可以对SQL进行优化。一位内具有封装少、映射多样化、支持存储过程、可以进行SQL优化等特点。
1.2.1 Hibernate简介 在MyBatis或者HIberNate中使用注解或者XML都是可以的。MyBatis中注解方式会受到一定的限制，所以MyBatis通常用XML方式实现映射关系。
我们把POJO对象和数据表相互映射的框架称为对象关系映射ORM。MyBatis和HIbernate都是ORM框架，只是Hibernate完全面向POJO，而前者不是。Hibernate基本不需要编写SQL就可以通过映射关系来操作数据库，是一种全表映射，而MyBatis不同，需要提供SQL去运行。
没有SQL是因为Hibernate会根据映射关系来生成对应的SQL。
1.2.2 Mybatis 在移动互联网时代，Mybatis是互联网Java持久框架的首选，与HIbernate消除SQL不同，MyBatis不屏蔽SQL。不屏蔽SQL的优势在于，程序员可以自己制定SQL规则，无须HIbernate自动生成规则，这样能够更加精确地定义SQL，从而优化性能。它更符合移动互联网、大数据、高并发、高性能、高响应的要求。
与HIbernate一样，MyBatis需要一个映射文件把POJO和数据库的表对应起来。
resultMap元素用于定义映射规则，Mybatis在满足一定规则下，完成自动映射。
mapper元素中的namespace属性，要和一个接口的全限定类名保持一致。里面的SQL的id也要和接口定义的方法保持完全一致。
定义了MyBatis的映射文件，就不再需要定义一个实现类。
Mybatis需要提供接口和SQL，意味着它的工作量会比HIbernate大，但是由于自定义SQL、映射关系，所以其灵活性、可优化性就超过了HIbernate。
1.2.3 HIbernate和MyBatis的区别 两者的增删查改对于业务逻辑层来说大同小异，对于映射层而言HIbernate的配置不需要接口和SQL，相反MyBatis是需要的。对于HIbernate而言，不需要编写大量的SQL就可以完全映射，同时提供了日志、缓存、级联等特性（级联比Mybatis强大）等特性，此外还提供了HQL对POJO操作，使用十分方便，但也有致命的缺陷。
由于无须SQL，当多表关联超过3个的时候，通过HIbernate的级联会造成太多的性能丢失，又或者我现在访问财务的表，然后它会关联财产信息表，财产又分为机械、原料等，显然机械和原料的字段不一样，这样关联的字段只能根据特定的条件变化而变化，而HIbernate无法支持这样的变化。遇到存储过程HIbernate只能作罢。
Mybatis可以自由书写SQL、支持动态SQL、处理列表、动态生成表名、支持存储过程。这样可以灵活定义查询语句，满足各类需求和性能优化的需要，这些在互联网系统中十分重要.
Mybatis也有缺陷。首先，要编写SQL和映射规则，其工作量稍微大于HIbernate。其次，支持的工具有限，不能像HIbernate那样有许多的插件可以帮助生成映射代码和关联关系，而即使使用生成工具，往往也需要开发者进一步简化，Mybatis通过手工编码，工作量相对大些。
所以对于性能要求不太苛刻的系统，比如管理系统、ERP等推荐HIbernate；而对于性能要求高、响应快、灵活的系统则推荐使用Mybatis。
1.3 Spring MVC简介 SPring MVC结构层次清晰，类比较简单，并且与SPring的核心IOC和AOP无缝对接。
MVC模式把应用程序分成不同的方面，同时提供这些元素的松耦合。
Model，封装了应用程序的数据和由它们组成的POJO
View，负责把模型数据渲染到视图上，将数据以一定的形式展现给用户。
Controller，负责处理用户请求，并建立适当的模型把它传递给试图渲染。
在SpringMVC中可以定义逻辑视图，通过其提供的试图解析器能够很方便地找到对应的视图进行渲染，或者使用其消息转换的功能，比如在Controller的方法内加入注解@ResponseBody后，SPring MVC就可以通过其消息转换系统，将数据转换为JSON，提供给前端Ajax请求使用。
SpriingMVC包括控制器、视图解析器、视图等重要内容。
1.4 最流行的NoSQL-Redis Redis是当前互联网最为流行的NoSQL。NoSQL在互联网系统中的作用很大，因为它可以在很大程度上提高互联网系统的性能。它具备一定持久层的功能，也可以作为一种缓存工具。对于NOSQL数据库而言，作为持久层，它存储的是半结构化的，这意味着计算机在读入内存中有更少的规则，读入速度更快。对于那些结构化、多范式规则的数据库系统而言，它更具性能优势。作为缓存，它可以支持大数据存入内存中，只要命中率高，就能快速响应，因为在内存中的数据读写比数据库读写磁盘的速度快几十上百倍。
Redis具有以下特点：
1、响应快速：Redis响应非常快，每秒课执行大约110000个写入操作，或者81000个读操作，其速度远超数据库。如果存入一些常用的数据，就能有效提高系统的性能。
2、支持6种数据结构：包括字符串、哈希结构、列表、集合、可排序集合和基数。比如对于字符串可以存入一些Java基础数据类型，哈希可以存储对象，列表可以存储List对象等。这使得在应用中很容易根据在自己的需要选择存储的数据类型，方便开发。既可以满足存储各种数据结构体的需要，又因为数据类型少，使得规则就少，需要的判断和裸机就少，这样读写速度就更快。
3、操作都是原子的：所有Redis的操作都是原子的，从而确保当两个客户同时访问Redis服务器时，得到的是更新后的值。在需要高并发的场合可以考虑使用Redis的事务，处理一些需要锁的事务。
4、MultiUtility工具：Redis可以在如缓存、消息传递队列中使用（支持“发布+订阅”的消息模式），在应用程序如Web应用程序会话、网站页面点击数等任何短暂的数据中使用。</description>
    </item>
    
    <item>
      <title>操作系统-进程与线程</title>
      <link>https://zereals7.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Sat, 10 Apr 2021 12:05:23 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</guid>
      <description>计算机上所有可运行的软件，通常也包括操作系统，被组织成若干顺序进程，简称进程。一个进程就是一个正在执行程序的实例，包括程序计数器，寄存器和变量的当前值。
从概念上来说，每个进程有自己的虚拟CPU。实际上真正的CPU在各进程间来回切换。
1、进程的创建 操作系统需要有一种方式来创建进程。
4种主要事件导致进程的创建：1、系统初始化 2、正在运行的程序执行了创建进程的系统调用 3、用户请求创建一个新进程 4、一个批处理作业的初始化
启动操作系统时，有些是前台进程，也就是与用户交互并且替他们完成工作的那些进程。其他的是后台进程，这些进程与特定的用户没有关系，却具有某些专门的功能。在大型系统中通常有很多守护进程，他们停留在后台，在请求到达时被唤醒。
从技术上看，新进程都是由于一个已存在的进程执行了一个用于创建进程的系统调用而创建的。这个进程可以是一个运行的用户进程、一个由键盘或鼠标启动的系统或者一个批处理管理进程。这个进程所做的工作是，执行一个用来创建新进程的系统调用。这个系统调用通知操作系统创建一个新进程，并且直接或间接地指定该进程中运行的程序。
UNIX系统中，只有一个系统调用可以用来创建新进程：fork。这个系统调用会创建一个与调用进程相同的副本。在调用了fork后，父进程和子进程拥有相同的内存映像、同样的环境字符串和同样的打开文件。
子进程接着执行execve或一个类似的系统调用，以修改其内存映像并运行一个新的程序。
当一个用户在shell中键入命令sort时，shell就创建一个子进程，然后，这个子进程执行sort。之所以要安排两步建立进程，是为了在fork之后但在execve之前允许该进程处理其文件描述符，这样可以完成对标准输入文件、标准输出文件和标准错误文件的重定向。
进程创建后，父进程和子进程有各自不同的地址空间。如果其中某个进程在其他地址空间修改了一个字，这个修改对其他进程而言是不可见的。在UNIX中。子进程的初始地址空间是父进程的一个副本，但是涉及两个不同的地址空间，不可写的内存区是共享的。某些UNIX的实现使程序正文在两者间共享，因为它不能被修改。或者，子进程共享父进程的所有内存，单这种情况下内存通过写时复制共享，这意味着一旦两者之一想要修改部分内存，则这块内存首先被明确的复制，以确保修改发生在私有内存区域。再次强调，可写的内存时不可以共享的。但是，对于一个新创建的进程而言，确实有可能共享其创建者的其他资源，诸如打开的文件等。在windows中，从一开始父进程的地址空间和子进程的地址空间就是不同的。
2、进程的终止 进程在创建之后，它开始运行，完成其工作。但永恒是不存在的，进程也一样。迟早这个新的进程会终止，通常由下列条件引起。
1、正常退出 2、出错退出 3、严重错误 4、被其他进程杀死
多数进程是由于完成了他们的工作而终止。
3、进程的层次结构 某些系统中，当进程创建了另一个进程后，父进程和子进程就以谋者形式继续保持关联。子进程自身可以创建更多的进程，组成一个进程的层次结构。进程只有一个父进程，但是可以有多个子进程。
在UNIX中，进程和它所有子进程以及后裔共同组成一个进程组。当用户从键盘发出一个信号时，该信号被送给当前与键盘相关进程组的所有成员。每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被该信号杀死。
一个称为init的特殊进程出现在启动映像中。当它开始运行时，读入一个说明终端数量的文件。接着，为每个终端创建一个新进程。这些进程等待用户登录。如果有一个用户登录成功，该登录进程就执行一个shell准备接收命令。所接受的这些命令会启动更多的进程，一次类推。这样在整个系统中，所有进程都属于以init为根的一棵树。
windows中没有进程层次的概念，所有进程都是地位相同的。唯一类似于进程层次的暗示是在创建进程的时候，父进程得到一个特别的令牌（称为句柄），该句柄可以用来控制子进程。但是它有权把这个令牌传送给某个其他进程，这样就不存在进程层次了。在UNIX中，进程不能剥夺其子线程的继承权。
4、进程的状态 每个进程是一个独立的实体，有自己的程序计数器和内部状态，但是，进程之间经常需要相互作用。一个进程的输出结果可能作为另一个进程的输入。进程有三种状态：1.运行态。该时刻进程实际占用CPU，啥都不缺。2.就绪态，可运行，但因为其他进程正在运行而暂时停止，缺CPU。3、阻塞态，除非某种外部事件发生，否则进程不能运行，缺资源，缺CPU。
前两中状态进程都可以运行，只是第二种状态暂时没有CPU分配给它。第三种状态与前两种状态不同，处于该状态的进程不能运行，即使CPU空闲也不行。
在操作系统发现进程不能运行下去时发生转换1.在某些系统，进程可以执行一个诸如pause的系统调用来进入阻塞状态。在其他系统，包括UNIX中，当一个进程从管道设备文件读取数据时，如果没有有效的输入存在，则进程会被自动阻塞。
转换2和3时由进程调度程序引起的，进程调度程序是操作系统的一部分，进程甚至感觉不到调度程序的存在。
当进程等待的一个外部事件发生时（如一些输入到达），则发生转换4.如果此时没有其他进程运行，则立即触发3转换3，该进程便开始运行。否则该进程将处于就绪态，等待CPU空闲并且轮到它运行。
操作系统的最底层是调度程序，在它上面有许多进程。所有关于中断处理、启动进程和停止进程的具体细节都隐藏在调度程序中。实际上，调度程序是一段非常短小的程序。操作系统的其他部分被简单地组织成进程的形式。不过，很少有真实的系统是以这样的理想方式构造的。
5、进程的实现 为了实现进程模型，操作系统维护者一张进程表（一个结构数组）。每个进程占用一个进程表项（进程控制块）。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开的文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。
![2021-04-1025 (Copy)](C:/Users/Zereal/Desktop/2021-04-1025 (Copy).jpg)
在了解进程表后，就可以对在单个CPU上如何维持多个顺序进程的错觉做更多的阐述。与每一IO类关联的是一个称作中断向量的位置（靠近内存底部的固定区域）。它包含中断服务程序的入口地址。
假设当一个磁盘中断发生时，用户进程3正在运行，则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈，计算机随后跳转到中断向量所指示的地址。这些是硬件完成的所有操作，然后软件，特别是中断服务例程就接管一切剩余的工作。
所有的中断都从保存寄存器开始，对于当前进程而言，通常是保存在进程表项中。
随后会从堆栈中删除由中断硬件机制存入堆栈的那部分信息，并将堆栈指针指向一个由进程处理程序所使用的临时堆栈。
一个进程在执行过程中可能被中断数千次，但关键是每次中断后，被中断的进程都返回到与中断发生前完全相同的状态。</description>
    </item>
    
    <item>
      <title>操作系统——引论</title>
      <link>https://zereals7.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Fri, 02 Apr 2021 18:22:48 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
      <description>完全基于《现代操作系统》第四版，摘取精华，掺杂个人理解。适用于自学党，和想要系统学习操作系统的人。
一、引论 1.为什么要有操作系统？操作系统的任务是什么？ 需求：现代计算机系统的组成极为复杂（处理器，主存，磁盘，输入输出设备&amp;hellip;）,应用程序员没有精力去掌握系统的所有细节。而且，管理这些部件并加以使用，是一件挑战性极强的工作。
所以计算机需要安装一层软件——操作系统。来满足这些需求。（注意：操作系统是系统软件，非应用软件）
任务：为用户程序提供一个更好、更简单、更清晰的计算机模型（操作系统）来实现对计算机所有设备的管理。
一言以蔽之，就是封装硬件运行和管理的细节，服务于上层的应用程序。
抽象是管理复杂性的一个关键，操作系统的任务就是创建好的抽象，并实现和管理它所创建的抽象对象。隐藏硬件，呈现给程序以及程序员良好/清晰/优雅/一致的抽象。
2.用户与操作系统交互的方式——用户接口程序 1.基于文本的——shell（命令行）
2.基于图标的——GUI（图形用户接口）
它们都属于用户接口程序，处于用户态程序中的最低层次。用户可以通过它们运行其他程序，如Web浏览器/音乐播放器等，这些程序也在大量使用操作系统。
3.操作系统内核态和用户态的区别 软件的最基础部分——操作系统，运行在内核态（也称管态，核心态）。核心态下，操作系统具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令。（为所欲为）
所以是有危险性的。
所以在用户态下，只使用了一部分机器指令，尤其是那些影响机器控制以及和IO操作有关系的指令，在用户态中的程序是禁止的。
4.操作系统所处的位置 由底层向上：硬件（裸机）——操作系统（软件，运行在内核态）——用户接口程序（软件，属于用户态最底层，靠近操作系统）——应用程序（软件，用户态）
总之，操作系统运行在裸机（纯硬件）之上，为其他所有软件提供基础的运行环境。
与普通软件的区别：操作系统软件不能被修改，受硬件保护，防止用户试图对其进行修改。
然而，在嵌入式系统（没有内核态）或解释系统（如基于Java的操作系统，它采用解释方式而非硬件方式区分组件）中，上述区别是模糊的。
操作系统一般比用户程序大型，复杂和长寿。（Linux和Windows内核源码都超过了500万行）
5.操作系统的实际用户——应用程序 应用程序直接与操作系统及其抽象打交道，而用户与用户接口所提供的抽象打交道（命令行shell或GUI）。虽然用户接口不同，但是操作系统下面的抽象是相同的。
6.操作系统是资源管理者——把潜在的混乱有序化 资源管理多路复用资源：在时间（CPU时间片）和空间（分割内存）上复用。
操作系统会分配CPU和内存，并协调管理使其有序，以提高运行的效率。
7.操作系统的历史 第一代：真空管和穿孔卡片 ——第二代：晶体管和批处理系统——第三代：集成电路和多道程序设计——第四代：个人计算机——第五代：移动计算机
8.处理器基础知识 CPU是计算机的大脑，它从内存中取出指令并且执行之。
三大流程：取指（从内存中）/解码（确定其类型和操作数）/执行
每个CPU都有特有的指令集，所以x86不能执行ARM程序，反之亦然。而且访存取指的时间比执行指令花费的时间长得多。因此。所有CPU的内部都有一些用来保存关键变量和临时数据的寄存器。
8.1 CPU中的寄存器介绍 除了用来保存变量和临时结果的通用寄存器外，还有一些程序员可见的专用寄存器。其中之一是程序计数器，它保存了将要取出的下一条指令的内存地址。
在取完指令后，程序计数器被更新以指向后继的指令。
另一个寄存器是堆栈指针，它指向内存中当前栈的顶端。该栈包含了每个执行过程的栈帧。一个过程的栈帧中保存了有关的输入参数、局部变量以及那些没有保存在寄存器中的临时变量。
当然还有程序状态字(PSW)寄存器。这个寄存器包含了条件码位、CPU优先级、模式（用户态或内核态），以及各种其他控制位。用户程序通常读入整个PSW，但是只对其中少量字段写入。在系统调用和I/O中，PSW的作用很重要。
操作系统必须知晓所有的寄存器。在时间多路复用CPU中，操作系统经常会中止正在运行的某个程序并再启动另一个程序，每次停止一个正在运行着的程序时，操作系统必须保存所有的寄存器值。这样在稍后该程序被再次运行时，可以把这些寄存器重新装入。
为了改善性能，现代CPU有同时取出多条指令的机制。例如，一个CPU可以有单独的取指单元、解码单元和执行单元，于是当它执行指令N时，可以对指令N+1进行解码，并且可以在内存读取指令N+2。这样的机制称为流水线。
一旦一条指令被取进流水线中，它就必须被执行完毕，即便前一条取出的指令是条件转移，它也必须被执行完毕。
还有更先进的**超标量CPU，有多个取指，解码，执行单元。**只要有一个执行单元空闲，就检查保持缓冲区中是否还有可处理的指令，如果有就把指令从缓冲区中移出并执行之。这种设计程序的指令经常不按顺序执行。多数情况下，硬件负责保证这种运算的结果与顺序执行指令时的结果相同，但是，仍然有部分令人烦恼的复杂情形被强加给操作系统处理（暂不讨论）。
在PSW中有一个二进制位控制CPU的内核态和用户态两种模式。内核态中运行的CPU可以执行指令集中的每一条指令，并且使用硬件的每种功能。值得一提的是，在台式机和服务器中，操作系统在内核态下运行，而在大多数嵌入式系统中，一部分操作系统运行在内核态，其余部分则运行在用户态。
相反**，用户程序在用户态下运行，仅允许执行指令集的一个子集和访问所有功能的一个子集**。一般而言，在用户态中有关IO和内存保护的所有指令是禁止的。当然，将PSW中的模式位设置成内核态也是禁止的。
为了从操作系统中获得服务，用户程序必须使用系统调用以陷入内核并调用操作系统。
只有TRAP指令能把用户态切换成内核态，并启用操作系统。在有关工作完成后，系统调用后面的指令把控制权返还给用户程序。
8.2 多线程和多核芯片 多线程允许CPU保持两个不同的线程状态，然后在纳秒级的时间尺度内来回切换。多线程不提供真正的并行处理。在同一时刻只有一个进程在运行，但是线程的切换时间则减少到纳秒数量级。
**GPU擅长处理大量并行的简单计算，比如在图像应用中渲染多边形。它们不太能胜任串行任务，并且很难编程。**虽然GPU对操作系统很有用（比如加密或者处理网络传输） ，但操作系统本身不太可能运行在GPU上。
8.3存储器 速度由快到慢：寄存器——高速缓存（Cache）——主存（RAM）——磁盘。每位成本也是由高到低。
缓存有利于改善性能。RAM具有电易失性，ROM则非易失。此外ROM速度快且便宜，用于启动计算机的引导加载模块就存放在ROM中。另外，一些I/O卡也采用ROM处理底层设备控制。
EEPROM和闪存也是非易失性的，与ROM相反，他们可以擦除和重写。不过重写比写入RAM要更高数量级的时间。
闪存速度介于RAM和磁盘之间。另外，与磁盘存储器不同，如果闪存擦除的次数过多，就被磨损了。
还有一类存储器是CMOS，它是易失性的。许多计算机利用CMOS存储器保持当前时间和日期。CMOS存储器和递增时间的时钟电路由一块小电池驱动，即使计算机没有上电，时间也可以正确的更新。CMOS存储器还可以保持配置参数。如哪一个是启动磁盘等。之所以采用CMOS是因为它电能消耗非常少，一块原装电池往往能使用数年。CMOS电池没电后，计算机将会不知道由哪个磁盘启动。
磁盘同RAM相比，每个二进制位的成本低了两个数量级。而且通常容量也大几个数量级。唯一的问题是访问数据时间大约慢了三个数量级。低速的原因是因为磁盘是一种机械装置。
磁盘有一个或多个金属盘片，以较高的速度旋转。信息写在磁盘一系列同心圆上。在任意一个给定臂的位置，每个磁头可以读取一段环形区域，称为磁道。把一个给定臂位置上的所有磁道合并起来，组成了一个柱面。
每个磁道划分为若干扇区，典型大小为512字节。现代磁盘中，较外的柱面拥有更多的扇区。机械臂从一个柱面移动到相邻的柱面大概需要1ms。而随机移到一个柱面的典型时间为5-10ms，具体时间取决于驱动器的转速。一旦所需要的扇区移到磁头之下，就开始读写。
固态硬盘没有可以移动的机械臂，是属于闪存，和磁盘同样具有非易失性。
虚拟内存机制：将程序放在磁盘上，将主存作为缓存，用来保存最频繁使用的部分程序。这种机制需要快速的映像内存地址，以便把程序生成的地址转换成为有关字节在RAM中的物理地址。这种映像由CPU中一个叫内存管理单元（MMU）的部件来完成。
缓存和MMU的出现对系统的性能有着重要的影响。在多道程序系统中，从一个程序切换到另一个程序，称为上下文切换。有必要对来自缓存的修改过的块进行写回磁盘的操作。并修改MMU中的映像寄存器。而上下文切换的代价很高，程序员应该努力避免这些操作。
8.4 I/O设备 I/O设备一般包括两个部分，设备控制器和设备本身。
控制器是插在电路板上的一块芯片和一组芯片，这块电路板物理地控制设备，从操作系统接受命令。控制器中一般存在一个小的嵌入式计算机。控制器的任务是为操作系统提供接口。
设备本身也有一个接口，但是功能比较简单。设备本身有个相对简单的接口，接口既不能做很多工作，又已经被标准化。实际的接口隐藏在控制器中。操作系统看到的是对控制器的接口，这个接口可能和设备接口有很大的差别。</description>
    </item>
    
  </channel>
</rss>