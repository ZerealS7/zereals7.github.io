<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Zereal-宋致远技术博客</title>
    <link>https://zereals7.github.io/</link>
    <description>Recent content on Zereal-宋致远技术博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 15 Jan 2022 13:43:37 +0800</lastBuildDate>
    
	<atom:link href="https://zereals7.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>2022年1月26</title>
      <link>https://zereals7.github.io/post/2022%E5%B9%B41%E6%9C%8826/</link>
      <pubDate>Sat, 15 Jan 2022 13:43:37 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/2022%E5%B9%B41%E6%9C%8826/</guid>
      <description>【支持向量机】 间隔与支持向量
给定训练集D，分类学习最基本的想法就是基于训练集D在样本空间中找到一个划分超平面，将不同类别的样本分开，但能将训练样本分开的划分超平面可能有很多，应该找哪个。
直观来看，应该去找位于两类训练样本正中间的划分超平面，因为该划分超平面对训练样本局部扰动的容忍性拍最好。例如，由于训练集的局限性和或噪声的因素，训练集外的样本可能比训练样本更接近两个类的分解，这将使许多划分超平面出现错误，而红色的超平面受影响最小。换言之，这个划分超平面是最鲁棒的，对未见示例泛化能力最强。
划分超平面可通过线性方程来描述。W为法向量，决定了 超平面的方向，b为位移项，决定了超平面与原点之间的距离。显然，划分超平面可被法向量w与位移b确定。
训练样本到超平面的距离为支持向量。两个异类支持向量到超平面的距离之和为间隔。
欲找到具有最大间隔的划分超平面，也就是要找到w,b使γ最大。找到最大间隔来区分，这样分类效果很好。
核函数
存在一个划分超平面能将训练样本正确分类，然而现实任务中，原始样本空间中也许并不存在一个能准确划分两类样本的超平面。然而现实任务中，原始样本空间内也许并不存在一个准确划分两类样本的超平面。
模型最优解可通过训练样本的核函数展开。这一展式亦称支持向量展式。、
任何一个核函数都隐式地定义了一个称为再生希尔伯特空间的特征空间。
我们希望样本在特征空间内线性可分，因此特征空间好坏对支持向量机的性能至关重要需注意的是，在不知道特征映射的形式时，我们并不知道什么样的核函数是合适的，而核函数也仅是隐式地定义了这个特征空间。于是，核函数选择成为支持向量机的最大变数。若核函数选择不合适，则意味着将样本映射到了一个不合适的特征空间，很可能导致性能不佳。
常用核函数有以下几种
线性核，多项式核，高斯核，拉普拉斯核，sigmod核，高斯核也叫RBF核。
软间隔与正则化
前面的讨论中，我们一直假定训练样本在样本空间或特征空间中是线性可分的，即存在一个超平面能将不同类的样本完全划分开。然而，在现实任务中往往很难确定合适的核函数使得训练样本在特征空间中线性可分，退一步说即便恰好找到了某个核函数使训练集在特征空间中线性可分，也很难断定这个貌似线性可分的结果不是由于过拟合所造成的。
缓解该问题的一个办法是允许支持向量机在一些样本上出错。为此，要引入软间隔的概率。
具体来说，若所有样本都必须划分正确，这称为硬间隔，而软间隔则允许某些样本不满足约束。
当然，在最大化间隔的同时，不满足约束的样本应尽可能少。
替代损失函数一般具有较好的数学性质，如它们通常是凸的连续函数，且是L01的上界。
三种常用的替代损失函数：hinge损失、指数函数、对率损失。
这就是常用的软间隔支持向量机。软间隔支持向量机的最终模型仅与支持向量有关，即通过采用hinge损失函数仍保持稀疏性。
如果使用对率损失函数来替代式中的01损失函数，则几乎就得到了对率回归模型。实际上，支持向量机与对率回归的优化目标相近，通常情形下它们的性能也相当。对率回归的优势主要在于其输出具有自然的概率意义。欲得到概率输出需进行特殊处理。此外，对率回归能直接用于多分类任务，支持向量机为此则需进行推广。hinge损失有一块平坦的零区域，这使得支持向量机的解具有稀疏性，而对率损失是光滑的单调递减函数，不能导出类似支持向量的概念因此对率回归的解依赖于更多的训练样本，其预测开销更大。。
可一替换损失函数得到别的模型，这些模型的性质与所用的替代函数直接相关，但它们具有一个共性：优化目标中的第一项用来描述划分超平面的间隔大小，另一项用来表述训练集上的误差。
结构风险用于描述模型的某些性质，经验风险用于描述模型与训练数据的契合程度。C用于对二者进行折中。结构风险表述了我们希望获得具有何种性质的模型，这为引入领域知识和用户意图提供了途径。另一方面，该信息有助于削减假设空间，从而降低了最小化训练误差的过拟合风险。
支持向量回归
对样本，传统回归模型通常直接基于模型输出与真实输出Y之间的差别来计算损失，当且晋档完全相同时，损失才为0.
与此不同，支持向量回归，假设我们能容忍模型输出与真实输出最多有E的偏差，即仅当差别绝对值大于E才计算损失。这相当于以模型输出为中心，构建了一个宽度为2E的间隔带，若训练样本落入此间隔带，则认为是被预测正确的。
核方法
给定训练样本。若不考虑偏移项b，则无论SVM还是SVR，学得的模型总能表示成核函数的线性组合。不仅如此，事实上我们有下面这个称为表示定理的更一般 结论：
表示定理对损失函数没有现在，对正则化项仅要求单调递增，甚至不要求Ω是凸函数，意味着对于一般的损失函数和正则化项，优化问题的最优解都可表示为核函数的线性组合，这显示出核函数的巨大威力。
人们发展出一系列基于核函数的学习方法，统称为核方法。最常见的，是通过核化来将线性学习器拓展为非线性学习器。下面我们以线性判别分析为例来演示如何通过核化来对其进行非线性拓展，从而得到核线性判别分析。
支持向量机的求解通常是借助于凸优化技术。如何提高效率，使SVM能适用于大规模数据一直是研究重点。对线性核SVM已有很多成果，例如基于割平面法的是SVM具有线性复杂度，基于随机梯度下降的Pegasos速度甚至更快，而坐标下降法则是在稀疏数据上有很高的效率。
支持向量机是针对二分类设计的，对多分类任务要进行专门的推广，对带结构输出的任务也已有相应的算法。
核函数直接决定了支持向量机与核方法的最终性能，但遗憾的是，核函数的选择是一个未决问题。多核学习使用多核核函数并通过学习获得其最优凸组合作为最终的核函数。这实际上是在借助集成学习机制。
替代损失函数在机器学习中被广泛使用，但是，通过求解替代损失函数得到的是否仍是原问题的解？这在理论上称为替代损失的一致性问题。
贝叶斯分类器 贝叶斯决策论
贝叶斯决策论是概率框架下实施决策的基本方法。对分类任务来说，在所有相关概率都已知的理想情形下，贝叶斯决策论考虑如何基于这些概率和误判损失来选择最优类别标记。
对每个样本x，若h能最小化总体风险，则总体风险也将被最小化。这就产生了贝叶斯判定准则：为最小化总体风险，只需在每个样本上选择那个能使条件风险最小的类别标记。此时H称为贝叶斯最优分类器，与之对应的总体风险称为贝叶斯风险。1-RH反映了分类器所能达到的最好性能，即通过机器学习所能产生的模型精度的理论上限。
具体来说，若目标是最小化分类错误，则误判损失。
最小化分类错误率的贝叶斯最优分类器是，对每个样本选择能使后验概率最大的类别标记。
不难看出，欲使用贝叶斯判定准则来最小化决策风险，首先要获得后验概率P。然而，在现实任务中，这通常难以直接获得。从这个角度来看，机器学习所要实现的是基于有限训练样本集尽可能准确地估计出后验概率P,大体来说，有两种主要策略，给定x，直接建模P来预测c，这样得到的是判别式模型。也可先对联合概率分布建模，由此得到P，这样得到的是生成式模型。显然，前面介绍的决策树、BP神经网络、支持向量机都可归入判别式模型的范畴。
估计类条件概率的一种常用策略是先假定其具有某种确定的概率分布形式，再基于训练样本对概率分布的参数进行估计。我们的任务是利用训练集D估计参数。
事实上概率模型的训练过程就是参数估计过程。对于参数估计，统计学界的两个学派分别提供了不同的解决方案：频率主义学派认为参数虽然未知，但却是客观存在的固定值，因此可通过优化似然函数等准则来确定参数值；贝叶斯学派则认为参数是未观察到的随机变量，其本身也可有分布，因此，可假定参数服从一个先验分布，然后基于观测到的数据来计算参数的后验分布。这是根据采样来估计概率分布参数的经典方法。
极大似然估计是试图在所有可能取值中，找到一个能使数据出现的可能性最大的值。
连乘操作易造成下溢.
极大似然估计得到的正太分布均值就是样本均值。参数化的方法虽然能使类条件概率估计变得相对简单，但估计结果的准确性严重依赖于所假设的概率分布形式是否符合潜在真实数据分布。
在现实生活中。，欲作出能较好地接近潜在真实分布的假设，往往需在一定程度上利用关于应用任务本身的经验知识，否则仅靠猜测来假设分布形式，很可能产生误导性的结果。
朴素贝叶斯分类器 基于贝叶斯公式来估计后验概率的主要困难在于：类条件概率是所有属性上的联合概率，难以从有限的训练样本直接估计得到。为避开这个障碍，朴素贝叶斯分类器采用了属性条件独立性假设。对已知类别，假设每个属性独立地对分类结果产生影响。朴素贝叶斯分类器的训练过程就是基于训练集D来估计类先验概率，并为每个属性估计条件概率。
令D表示训练集D中第C类样本组成的集合，若有充足的独立同分布样本，则可容易地估计出类先验概率。
若P好瓜大于P坏瓜，则可判定为好瓜。若某个属性值在训练集没有与某个类同时出现过，假如对连乘式计算得到概率值为0.哪怕在其他属性明显像好瓜，分类的结果都将是好瓜等于否，这显然不太合理。
为了避免其他属性携带的信息被训练集中未出现的属性值抹去，在估计概率值时通常要进行平滑，常用拉普拉斯修正。
拉普拉斯修正避免了因训练集样本不充分而导致概率估值为零的问题，并且在训练集变大时，修正过程所引入的先验的影响也会变得可忽略，使得估值渐渐趋于实际概率值。
在现实任务中，朴素贝叶斯分类器有多种使用方式。例如，若任务对预测速度要求较高，则对给定训练集，可将朴素贝叶斯法分类器涉及的所有概率估值事先计算好存储起来。，这样在进行预测时只需查表即可进行判别；若任务数据更替频繁，则可采用懒惰学习方式，先不进行任何训练，待收到预测请求时，再根据当前数据集进行概率估值，若数据不断增加，则可在现有估值基础上，仅对新增样本的属性值所涉及的概率估值进行计数修正，即可实现增量学习。
半朴素贝叶斯分类器
为了降低贝叶斯公式估计后验概率的困难，朴素贝叶斯分类器采用了属性条件独立性假设，但在现实任务中这个假设往往很难成立。于是，人们尝试对属性条件独立性假设进行一定程度的放松，由此产生了一类称为半朴素贝叶斯分类器的学习方法。
半朴素贝叶斯分类器的基本想法是适当考虑一部分属性间的相互依赖信息，从而既不需要进行完全联合概率计算，又不至于彻底忽略了比较强的属性依赖关系。独依赖估计是半朴素贝叶斯分类器最常用的一种策略。顾名思义，所谓独依赖就是假设每个属性在类别之外最多仅依赖于一个其他属性。
问题的关键就转化为如何确定每个属性的父属性，不同的做法产生不同的独依赖分类器。
最直接的做法是假设所有属性都依赖于同一个属性，称为超父，然后通过交叉验证等模型选择方法来确定超父属性，由此形成了SPODE方法。
TAN则是在最大带权生成树算法的基础上，通过以下步骤将属性间的依赖关系约简为树形结构。
1.计算任意两个属性之间的条件互信息
2.以属性为结点构建完全图，任意两个结点之间边的权重设为I。
3.构建此完全图的最大带权生成树，挑选根变量，将边置为有向
4.加入类别结点y，增加从y到每个属性的有向边。
容易看出，条件互信息I刻画了属性在已知类别情况下的相关性，因此通过最大生成树算法，TAN实际上仅保留了强相关属性之间的依赖性。
AODE是一种基于集成学习机制、更为强大的独依赖分类器。与SPODE通过模型选择确定超父属性不同，AODE尝试将每个属性作为超父来构建SPODE，然后将那些具有足够训练数据支撑的SPODE集成起来作为最终结果。与朴素贝叶斯分类器类似，AODE的训练过程也是计数，即在训练数据集上对符合条件的样本进行计数的过程。与朴素贝叶斯分类器相似，AODE无需模型选择，既能通过预计算节省预测时间，也能采取懒惰学习方式在预测时再进行计数，并且易于实现增量学习。</description>
    </item>
    
    <item>
      <title>2022.1.15</title>
      <link>https://zereals7.github.io/post/2022%E5%B9%B41%E6%9C%8815%E6%97%A5%E5%AD%A6%E4%B9%A0%E6%94%B6%E8%8E%B7/</link>
      <pubDate>Sun, 09 Jan 2022 13:12:00 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/2022%E5%B9%B41%E6%9C%8815%E6%97%A5%E5%AD%A6%E4%B9%A0%E6%94%B6%E8%8E%B7/</guid>
      <description>【现代操作系统】 调度程序激活工作的目标是模拟内核线程的功能，但是为线程包提供通常在用户空间中才能实现的更好的性能和更大的灵活性。
特别的，如果用户线程从事某种系统调用时是完全的，那就不应该进行专门的非阻塞调用或者进行提前检查。无论如何，如果线程阻塞在某个系统调用或页面故障上，只要在同一个进程中有任何就绪的线程，就应该有可能运行其他的线程。由于避免了在用户空间和内核空间的不必要的转换，从而提高了效率。例如，如果某个线程由于等待另一个线程的工作而阻塞，此时没有理由请求内核，这样就减少了内核-用户转换的开销。用户件的运行时系统可以阻塞同步的线程而另外调度一个新线程。
当使用调度程序激活机制时，内核给每个进程安排一定数量的虚拟处理器，并且让运行时系统将线程分配到处。这一机制也可以用在多理器中，此时虚拟处理器可能成为恶真实的CPU。分配给一个进程的虚拟处理器的初始数量是一个，但是该进程可以申请更多的处理器并且在不用时退回。内核也可以取回已经分配出去的虚拟处理器，以便把它们分给需要更多处理器的进程。
使该机制工作的基本思路是，当内核了解到一个线程被阻塞之后，内核通知该进程的运行时系统。并且在堆栈中以参数形式传递有问题的线程编号和所发生事件的一个描述。内核通过在一个已知的起始地址启动运行时系统，从而发出了通知。这是对UNIX中信号的一种粗略模拟。这个机制称为上行调用。
一旦如此激活,运行时系统就重新调度其线程，这个过程通常是这样：把当前的线程标记为阻塞并从就绪表中取出另一个线程，设置寄存器，然后启动之。稍后，当内核知道原来的线程又可运行时，内核就又一次上行调用运行时系统，通知它这一事件。此时该运行时系统按照自己的判断，或者立即重启动被阻塞的线程，或者把它放入就绪表中稍后运行。
在某个用户线程运行的同时发生一个硬件中断时，被中断的CPU切换进内核态。如果被中断的进程对引起该中断的事件不感兴趣，比如，是另一个进程的IO完成了，那么在中断处理程序结束之后，就把被中断的线程恢复到中断之前的状态。不过，如果该进程对中断感兴趣，比如是该进程中的某个线程所需要的页面到达了，那么被中断的线程就不再启动，代之为挂起被中断的进程。而运行时系统则启动对应的虚拟CPU，此时被中断的线程状态还保存在堆栈中。随后，运行时系统决定在该CPU上调度哪个线程：被中断的线程、新就绪的线程还是某个第三种选择。
弹出式线程：一个消息的到达导致系统创建一个处理该消息的线程，这种线程称为弹出式线程。
弹出式线程的关键好处是，由于这种线程相当新，没有历史——没有必须存储的寄存器、堆栈诸如此类的内容，每个线程从全新开始，每个线程彼此之间完全一样。这样，就有可能快速创建这类线程。对该新线程指定所要处理的消息。使用弹出式线程的结果是，消息到达与处理开始的时间非常短。
在内核空间中运行弹出式线程通常比在用户空间中容易且快捷，而且内核空间中弹出式线程可以很容易访问所有的表格和IO设备，这些也许在中断处理时有用。而另一方面，出错的内核线程会比出错的用户线程造成更大的损害。例如，如果某个线程运行时间太长，又没有办法抢占它，就可能造成进来的信息丢失。
【机器学习】 经验误差与过拟合
样本数占样本总数的比例称为错误率
精度=1-错误率
学习器实际预测输出与样本的真实输出之间的差异称为误差
学习器在训练集上的误差称为训练误差或经验误差，在新样本上的误差为泛化误差。
我们实际希望的是在新样本上能表现得很好的学习器。为了达到这个目的，应该从训练样本尽可能学出适用于所有潜在样本的普遍规律，这样才能在遇到新样本的时候做出正确的判别。
然而，当学习器把样本学得太好了的 时候，很可能已经把训练样本自身的一些特点当做了所有潜在样本会具有的一般性质，这样就会导致泛化的性能下降。这种现象在机器学习中称为过拟合。与过拟合相对的是欠拟合，这是指的对训练样本的一般性质尚未学好。
有多种因素可能导致过拟合，其中最常见的是学习能力过于强大，以至于把训练样本所包含的不太一般的特性都学到了，而欠拟合则是由于学习能力低下造成的，欠拟合比较容易客服，例如在决策树学习中，扩展分支，在神经网络学习中增加训练轮数等，而过拟合则很麻烦。过拟合是机器学习面临的关键障碍，各类学习算法都必然带有一些针对过拟合的措施，然而必须认识到，过拟合是无法彻底避免的，我们所做的只是缓解，或者说减小其风险。
机器学习面临的问题通常是NP甚至更难，而有效的学习算法必然是在多项式时间内运行完成，若可彻底避免过拟合，则通过经验误差最小化就能获最优解，这就意味着我们构造性证明了P=NP；因此只要相信P不等于NP，过拟合就不可避免。
评估方法
通常，可通过实验测试来对学习器的泛化误差进行评估并进而做出选择。
为此需要使用一个测试集来测试学习器对新样本的判别能力，然后以测试集上的测试误差作为泛化误差的近似。
通常我们假设测试样本也是从样本真实分布中独立同分布采样而得。但需要注意的是，测试集应该尽可能与训练集互斥，即测试样本进来不在训练集中出现，未在训练中使用过。
显然若测试样本被用作训练了，则得到的将是过于乐观的估计结果。
如果有一个包含M个样本的数据集D，既要训练又要测试，则要对D进行适当的处理，从中产生训练集S和测试集T
几种常见的划分方法
1.留出法
直接将D划分为两个互斥的集合。在S上训练出模型后，用T来评估其测试误差，作为对泛化误差的估计。
需注意的是训练测试集的划分要尽可能保持数据分布的一致性，避免因数据划分过程引入额外偏差而对最终结果产生影响，例如在分类任务中，至少要保持样本的类别比例相似。
例如通过对D进行分层采用而获得含70%样本的训练集S和含30%样本的测试集T，若D包含500个正例、500个反例，则分层采样得到的S应该包含350个正例、350个反例，而T则包含150个正例和150个反例；若S、T样本类别比例差别很大，则误差估计将由于训练、测试数据分布的差异而产生偏差。
另一个需要注意的问题是，即便在给定训练测试样本的比例后，仍存在多种划分方式对初始数据集D进行分割，例如在上面的例子中，可以把D中的样本排序，然后把前350个正例放在训练集中，也可以把最后350个正例放在训练集中，这些不同的划分会导致不同的训练测试集。相应的评估模型也会有差别，因此单次使用留出法得到的估计结果往往不够稳定可靠，在使用留出法时，一般采用若干次随机划分，重复进行实验评估后取平均值作为留出法的评估结果。
留出法可能导致一些窘境：若令训练集S包含绝大多数样本，则训练出的模型可能更接近D训练出的模型，但由于T比较小，评估结果可能不够稳定准确；若令测试集T多包含一些样本。则训练集S与D差别更大了，被评估的模型与D训练出的模型相比可能有较大差别，从而降低了评估结果的保真性，这个问题没有完美的解决方案，常见做法是将大约2/3-4/5的样本用于训练，剩余样本用于测试。
2.交叉验证法
交叉验证法先将数据集D划分为K个大小相似的互斥子集，每个自己Di都尽可能保持数据分布的一致性，即从D中通过分层采样得到。然后，每次用K-1个子集的并集作为训练集，余下的那个子集作为测试集；这样就可获得k组训练测试集，从而可进行K次训练和测试，最终返回的是这K个测试结果的均值，显然，交叉验证法评估结果的稳定性和保真性在很大程度上取决于k的取值。
为强调这一点，通常把交叉验证法称为K折交叉验证，K最常用的取值是10，此时称为10折交叉验证；其他常用的k值有5、20等。
与留出法相似，将数据集D划分为k个子集同样存在多种划分方式。为减小因样本划分不同而引入的差别，k折交叉验证通常要随机使用不同的划分重复P次，最终的评估结果是这P次K折交叉验证的结果的均值，例如10次10折交叉验证。
比如10折有很多随机划分的10折。
假定数据集D中包含M个样本，若令k=m，则得到了交叉验证法的一个特例：留一法。显然留一法不受随机样本划分方式的影响，因为只有一种划分方式。每个子集包含一个样本。留一法使用的训练集和初始数据集只少了一个样本，这就使得在绝大多数情况下，留一法中被实际评估的模型与期望评估的用D训练出的模型很相似。因此留一法的评估结果往往认为比较准确。然而留一法也有其缺陷：在数据集比较大时，训练m个模型的计算开销可能是难以忍受的（一百万个样本则需要训练100万个模型），而这还是在未考虑算法调参的情况下，另外，留一法的估计结果也未必永远比其他评估方法准确。
3.自助法
我们希望评估的是用D训练出的模型，但在留出法和交叉验证法中，由于保留了一部分样本用于测试，因此实际评估的模型所使用的训练集比D小，这必然会引入一些因训练样本规模不同而导致的估计偏差。留一法受训练样本的规模变化影响较小，但计算复杂度又太高了，有没有什么办法可以减少训练样本规模不同造成的影响，同时还能比较高效地进行实验估计呢？
自助法是一个比较好的解决方案，它直接以自助采样法为基础。给定包含m个样本的数据集D，我们对它采用产生数据集D‘:每次随机从D中挑选一个样本，将其拷贝放入D’，然后再将该样本放回初始数据集D中，使得该样本在下次采样时仍有可能采到；这个过程重复执行M次后，我们就得到了包含m个样本的数据集D‘，这就是自助采样的结果。显然D中有一部分样本会在D’中多次出现，而另一部分样本不出现。可以做一个简单的估计，样本在m次采用中始终不被采到的概率是（1-1/m）的m次方，取极限得到为1/e，约等于0.368。
即通过自助采样，初始数据集D中约有36.8%的样本未出现在采样数据集D‘中。于是我们可将D’作为训练集，D/D‘用作测试集；这样实际评估 模型与期望评估的模型都使用m个训练样本，而我们仍有数据总量约1/3的、没在训练集中出现的样本用于测试。这样的测试结果，亦称包外估计。
自助法在数据集较小、难以有效划分训练、测试集时很有用；此外，自助法能从初始初始数据集中产生多个不同的训练集，这对集成学习等方法有很大的好处。然而，自助法产生的数据集改变了初始数据集的分布，这会引入估计偏差。因此在初始数据量足够时，留出法和交叉验证法更常用一些。
调参与最终模型
参数配置不同，学得模型的性能往往有显著差别。因此在进行模型评估与选择时，撤了要对适用学习的算法进行选择，还需对碎发参数进行设定，这就是通常所说的参数调节或者说调参。
调参和算法选择没什么本质区别：对每种参数配置都训练出模型，然后把对应最好模型的参数作为结果，这样考虑基本是正确的。担忧一点需注意：学习算法的很多参数是在实数范围内取值，因此，对每种参数配置都训练出模型来是不可行的。现实中常用的做法是对每个参数选定一个范围和变化步长。显然，这样选定的参数值往往不是最佳值，但是这是在计算开销和性能估计之间折中的结果，通过这个折中，学习过程才变得可行。事实上，即便在进行这样的折中后，调参往往仍然很困难。
可以简单估算一下，假定算法有3个参数，每个参数仅考虑5个候选值，这样对每组训练测试有125个模型需考察，很多强大的学习算法有不少参数需设定，这将导致极大的调参工程量，以至于不少应用任务中，参数调的好不好往往对最终模型性能有关键性影响。
给定包含M个样本的数据集D，在模型评估与选择过程中由于需要留出一部分数据进行评估测试，事实上我们只使用了一部分数据训练模型，因此在模型选择完成后，学习算法和参数配置已选定，此时应该用数据集D重新训练模型。这个模型在训练过程中使用了所有M个样本，这才是最终提交给用户的模型。
另外需要注意的是，我们通常把学得模型在实际使用中遇到的数据称为测试数据，为了加以区分，模型评估与选择用于评估测试的数据集常称为验证集。例如，在研究对比不同算法的泛化性能时，我们用测试集上的判别效果来估计模型在实际使用时的泛化能力，而把训练数据另外划分为训练集和验证集，基于验证集上的性能来进行模型选择和调参。
即训练数据先分出训练集和验证集调参以及选模型，最后再用整个的训练数据再次作为训练集训练，用测试集评估模型的泛化能力。
性能度量
对学习器泛化性能进行评估，不仅需要有效可行的实验估计方法，还需要有衡量模型泛化能力的评价标准，这就是性能度量。
性能度量反映了任务需求，在对比不同模型的能力时，使用不同的性能度量往往会导致不同的评判结果；这意味着模型的好坏是相对的，什么样的模型是好的，不仅取决于算法和数据，还决定于任务需求。
要评估学习器f的性能，就要把学习器预测的结果与真实标记y进行比较。
回归任务最常用的性能度量是均方误差
每一对误差的平方再求均值。
分类任务中常用的性能度量有以下一些：
错误率与精度
这是分类任务中最常用的两种性能度量，既适用于二分类任务，也适用于多分类任务。错误率是分类错误的样本数占样本总数。
精度则是分类正确的样本数占样本总数的比例。
查准率查全率与F1
错误率和精度虽常用，但并不能满足所有任务需求。以西瓜问题为例，假定瓜农拉来一车西瓜，我们用训练好的模型对这些西瓜进行判别，显然，错误率衡量了有多少比例的瓜被判别错误。但是若我们关心的是挑出来的西瓜有多少比例是好瓜或者好瓜中有多少比例被挑了出来。那么错误率显然不够用了。
对于二分类矩阵分为真正例，假正例，真反例，假反例四种情况。
查准率P与查全率R分别定义为
P=TP/TP+FP 真正例除以所有表面的正例
R=TP/TP+FN 真正例除以所有真正的正例</description>
    </item>
    
    <item>
      <title>2022年1月9日学习收获</title>
      <link>https://zereals7.github.io/post/2022%E5%B9%B41%E6%9C%889%E6%97%A5%E5%AD%A6%E4%B9%A0%E6%94%B6%E8%8E%B7/</link>
      <pubDate>Thu, 07 Oct 2021 15:43:10 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/2022%E5%B9%B41%E6%9C%889%E6%97%A5%E5%AD%A6%E4%B9%A0%E6%94%B6%E8%8E%B7/</guid>
      <description>【现代操作系统】 线程状态之间的转换与进程状态之间的转换是一样的。
每个线程有其自己的堆栈，每个线程的堆栈有一帧，供各个被调用但是还没有从中返回的过程使用。在该栈帧帧存放了相应过程的局部变量以及过程调用完成之后使用的返回地址。通常每个线程会调用不同的过程，从而有一个各自不同的执行历史。这就是为什么每个线程需要有自己堆栈的原因。
每个进程中的内容：地址空间、全局变量、打开文件、子进程、即将发生的定时器、信号与信号处理程序、账户信息
每个线程中的内容：程序计数器、寄存器、堆栈、状态
所有线程都是平等的
线程无法利用时间中断强制线程让出CPU，需要用线程调用thread.yield,这会允许线程自动放弃CPU从而让另一个线程运行。
有两种主要方法实现线程包：在用户空间中和在内核中。 在用户空间管理进程时，每个进程有其专用的线程表，用来跟踪该进程中的线程。与内核中的进程表类似，不过它仅仅记录各个进程的属性。该线程表由运行时系统管理。当一个线程转换到就绪状态获阻塞状态时，在该线程表中存放重新启动该线程所需的信息，与内核在进程表中存放进程的信息完全一样。
进行现场切换至少比陷入内核要快一个数量级，这是用户级线程包极大的优点。
线程与进程的关键差别，进行切换时不需要陷入内核，不需要进行上下文切换，也不需要对内存高速缓存进行刷新，这就使得线程调度非常快捷。
用户级线程的另一个优点，它允许每个进程有自己定制的调度算法。有垃圾收集线程的应用程序就不用担心线程在不合适的时刻停止。用户级线程还有较好的可扩展性，这是因为在内核空间中内核线程需要一些固定表格空间和堆栈空间。如果内核级线程的数量非常大，就会出现问题。
用户级线程的问题：1.如何实现阻塞系统的调用。使用线程的一个主要目标是，首先要允许每个线程使用阻塞调用，但是还要避免被阻塞的线程影响其他的线程。有了阻塞系统调用，这个目标不是轻易能够实现的。在系统调用周围从事检查的代码称为包装器。
内核中实现线程,不再需要运行时系统.每个进程中也没有线程表.线程通过系统调用更新线程表完成线程创建和撤销工作。
内核中的线程表保存了每个线程的寄存器、状态和其他信息。内核还维护了传统的进程表，以便跟踪进程的状态。
所有能够阻塞线程的调用都以系统调用的形式实现，与运行时系统过程相比，代价是相当可观的。当一个线程阻塞时，内核根据其选择，可以运行同一个进程中的另一个线程或者运行另一个进程中的线程（若有一个就绪进程）或者运行另一个进程中的线程。在用户级线程中，运行时系统始终运行自己进程中的线程，直到内核剥夺它的CPU为止。
线程回收，把要撤销的线程标记为不可运行的，但是其内核数据结构没有受到一些。稍后在必须创建一个新线程时，就重新启动某个旧线程，从而节省一些开销。在用户级线程中线程回收也是可能的，但是由于其线程管理的代价很小，所以没必要进行这项工作。
可以使用内核级线程，然后讲用户级线程与某些或者全部内核级线程多路复用起来。编程人员可以决定有多少个内核级线程和多少个用户级线程彼此多路复用。内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。每个内核级线程有一个可以轮流使用的用户级线程集合。
【深入理解计算机系统】 操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容。
当操作系统决定把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权转移到新进程。新进程就会从它上次停止的地方开始。
以shell和hello进程为例。shell通过系统调用会将控制权传递给操作系统。操作系统保持原来进程的上下文，创建一个新进程及其上下文，然后将控制权传给hello进程。hello进程终止后，操作系统恢复shell进程的上下文，并将控制权传回给他，shell进程会继续等待下一个命令行输入。
从一个进程到另一个进程的转换是由操作系统内核管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的系统调用指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。
内核不是一个独立的进程，相反，它是系统管理全部进程所用代码和数据结构的集合。
一个进程由多个被称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。
多线程之间比多进程之间更容易共享数据，线程一般也比进程更加的高效。
每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区有专门的功能。
程序代码和数据
堆。代码和数据区一开始运行时就被指定了大小，与此不同，堆可以在运行时动态地扩展和收缩。
共享库：地址中间的部分用来存放标准库和数学库这样的共享库的代码和数据的区域。
栈。位于虚拟地址空间顶部。编译器用它来实现函数调用。栈在程序执行期间也可以动态的扩展和收缩。每次我们调用一个函数时，栈就会增长；从一个函数返回时栈就会收缩。
内核虚拟内存：地址底部空间是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。它们必须调用内核来执行这些操作。
文件为字节序列。每个IO设备，包括磁盘、键盘、显示器，甚至是网络都可以看成是文件。系统中所有输入输出都是通过使用一小组称为UnixI/O的系统函数调用读写文件实现的。
同一个程序可以中使用不同磁盘技术的不同系统上运行。
现代系统经常通过网络和其他系统连接到一起。从一个单独的系统来看，网络可视为一个IO设备。
【JavaWeb】 CS结构是客户端和服务器。服务器端采用高性能PC机或工作站，并采用大型数据库系统，客户端需要安装专业的客户端软件。
这种结构可以充分利用两端硬件环境的优势，将任务合理地分配到客户端和服务器，从而降低了系统的通用开销。
BS即浏览器/服务器结构。客户端不需要开发任何用户界面，而是通过Web浏览器向Web服务器发送请求，由Web服务器进行处理，并将处理结果逐级传回客户端。
CS结构的开发和维护成本比BS高。采用CS结构时，对于不同客户端要开发不同的程序，而且软件的安装、调试和升级均需要在所有的客户机上进行。如果换成BS结构，则在软件升级后，只需要将服务器的软件升级到最新的版本。只要重新登录系统，即可使用最新版本的软件。
CS结构的客户端不仅负责与用户的交互，收集用户信息，而且还需要完成通过网络向服务器请求，对数据库、电子表格或文档等信息的处理工作。应用程序越复杂、客户端程序也越庞大，这也给软件的维护工作带来了很大的困难。
而BS结构的客户端把事务处理逻辑部分交给了服务器，由服务器进行处理，客户端只需要进行显示，这样将使应用程序服务器的运行数据负荷较重，一单发生服务器崩溃，后果将不堪设想。因此，许多单位都备有数据库存储服务器，以防万一。
CS安全性高于BS。
Web应用程序大体可以分为两种，即静态网站和动态网站。
【Springboot】 优点：
 创建独立的Spring程序 嵌入的Tomcat、Jetty、或者Undertow,无须部署WAR文件 允许通过Maven来根据需要获取starter 尽可能地自动配置Spring 提供生产就绪型功能，如指标、健康检查和外部配置 绝对没有代码生成，对XML没有要求配置  近年来微服务的留下，越来越多的企业需要快速的开发，而Springboot除了以注解为主的开发，还有其他的绑定，例如对服务器进行了绑定和默认对Spring的最大化配置，所以开发者能尽快进行开发代码、发布和测试自己的项目。这符合现今微服务快速开发、测试和部署的需要。
SpringBoot是一个基于Spring框架搭建起来的应用，其次它会嵌入Tomcat、Jetty或者Undertow等服务器，并且不需要传统的WAR文件进行部署，也就是说搭建SpringBoot项目不需要单独下载Tomcat等传统服务器；同时提供通过Maven或者Gradle依赖的starter,这些starter可以直接获取开发所需的相关包，通过这些starter项目就能以Java Application的形式运行SpringBoot的项目，而无需其他服务器配置；对于配置，SpringBoot提供Spring框架的最大自动化配置，大量使用自动配置，使得开发者对Spring的配置尽量减少；此外还提供了一些监测、自动检测的功能和外部配置，与此同时没有附加代码和XML的配置要求。
约定优于配置，是SpringBoot的主导思想。
对于SpringBoot而言，大部分情况下存在默认配置，你甚至可以在没有任何定义的情况下使用Spring框架，如果需要自定义也只需要在配置文件配置一些属性便可以，十分便捷。而对于部署这些项目必须的功能，SpringBoot提供starter的依赖。例如，spring-boot-starter-web捆绑了Spring MVC所依赖的包，spring-boot-starter-tomcat绑定了内嵌的Tomcat,这样使得开发者能够尽可能快地搭建开发环境，快速进行开发和部署，这就是SpringBoot的特色。
​
【docker】 云时代最为看重的是凭借虚拟化技术所构建的集群处理能力。
容器技术非常优雅，充分利用了操作系统本身已有的机制和特性，可以实现远超传统虚拟机的轻量化虚拟机。
Docker是基于Go语言实现的开源容器项目。
docker对应用的封装、分发、部署、运行生命周期进行管理，达到应用组件级别的一次封装，到处运行。这里的应用程序组件可以是一个Web应用、一个编译环境，也可以是一套数据库平台服务，甚至是一个操作系统集群。
Docker提供了高效、敏捷和轻量级的容器方案，并支持部署到本地环境和多种主流云平台。可以说，Docker首次为应用的开发、运行和部署提供了一站式的解决方案。
容器有效的将由单个操作系统管理的资源划分到孤立的组中，以更好地在孤立的组之间平衡有冲突的资源使用需求。与虚拟化相比，这样既不需要指令级模拟，也不需要即时编译。容器可以在核心CPU本地运行指令，而不需要任何专门的解释机制。此外也避免了准虚拟化和系统调用替换中的复杂性。
Docker提供了各种容器管理工具（如分发、版本、移植等），让用户无须关注底层的操作，更加简单明了地管理和使用容器，其次Docker通过引入分层文件系统构建和高效的镜像机制，降低了迁移难度，极大改善了用户体验。用户操作Docker容器就绪操作应用自身一样简单。
可以将Docker理解为一种轻量级的沙盒。每个容器内运行着一个应用，不同的容器相互隔离，容器之间也可以通过网络互相通信。容器的创建和停止十分迅速，几乎跟创建和终止原生应用一致；另外，容器自身对系统资源的额外需求也十分有限，远远低于传统虚拟机。很多时候，甚至直接把容器当作应用本身也没有任何问题。</description>
    </item>
    
    <item>
      <title>暑期悬梁计划实施细则</title>
      <link>https://zereals7.github.io/post/%E6%82%AC%E6%A2%81%E8%AE%A1%E5%88%92%E5%AE%9E%E6%96%BD%E7%BB%86%E5%88%99/</link>
      <pubDate>Sat, 17 Jul 2021 20:01:42 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/%E6%82%AC%E6%A2%81%E8%AE%A1%E5%88%92%E5%AE%9E%E6%96%BD%E7%BB%86%E5%88%99/</guid>
      <description>一、作息篇
其一，起床，5点30，洗漱吃饭上厕所6点出门走路去图书馆
路上记记自己的笔记
其二，花一天时间专注于一项重要技能。每日都要有所精进，注重学习方法，注重实效。把自己培养成博学而精专之人。
其三，中午12点午饭，12点半到1点午睡半小时
其四，下午1点学到晚上9点。9点半回到家中，做饭吃。路上记记自己的笔记。用讯飞有声读。
其五，晚上10点半洗澡入睡。
如有时间可以把自己一天的经过拍成视频，回来吃完晚饭花半个小时剪辑。
如觉得学习累了，做做小猿搜题的兼职赚赚外快。
二、学习总目标
过完之后，需掌握坚实计算机软硬件基础，Java编程全方位疏通（达到找工作水平），机器学习入门，office三件套以及ps，cdr加上visio等一系列软件熟练。
此外要学好概率论加离散数学。掌握linux。python，c语言以及前端知识。
算法数据结构要达到一定水平。
三、具体学习方法
注重知识整合，知识回顾，要学通。
多参考各方资料，网课+博客+书+题目全方位练习。
各知识点要善于利用思维导图清晰化知识脉络，善于写总结笔记。善于思考各知识之间的联系。融会贯通。
当一个知识点达到精通可以出一期视频精讲（费曼学习法）
四、具体学习顺序
 第一阶段：考研残余及计算机本科专业知识查漏补缺。  此阶段主要针对于之前考研一知半解的知识进行深度回顾与复习。在某些具有价值的考点的地方可以多加回顾总结。出讲408的视频甚至可以精讲某个知识专题。
先操作系统——计算机组成原理——数据结构——计算机网络
王道书＋视频+黑皮书加教材+个人学霸视频多元素一起使用。以专题模块化思维解决问题。
2.第二阶段： Java深化学习
回顾之前Java学习中不甚明白的点，加以重新复习，深化自己的学习。
先JavaSE——JavaEE——前端WEB——数据库操作——SSM框架——Springboot——Java虚拟机——docker——Maven&amp;amp;git深化学习
——算法——中间件——linux系统深入学习——项目实战
要注重操作和深度理解，同样携带某一专题资料模块化解决。
中间要加强个人博客总结，记录个人有收获的小技巧。记录遇到的坑。
3.第三阶段：机器学习入门
先学习概率论——python——李宏毅全套课程网课配合两本教材
4.第四阶段：各软件操作深化学习
各编程软件数据库软件的优化和功能深入了解，操作熟练。
office套件办公能力学习加强，尤其加强ppt和excel
visio和mind manager 加上project思维导图流程图软件深入学习，学会甘特图
origin加上matlab深度掌握
cad cdr ps三大设计软件深度学习
论文检索以及科研能力培养，网上视频知乎大神经验总结。知道如何写出一篇好论文的全流程。
5、第五阶段：算法入门
熟悉各类算法，加上开始刷leetcode和牛客网的题目。
五、每日总结
每天花10分钟总结记录今日收获（可拍视频），10分做好明日学习计划（Things to do）,画出计划表。精确到小时。</description>
    </item>
    
    <item>
      <title>悬梁计划</title>
      <link>https://zereals7.github.io/post/%E6%82%AC%E6%A2%81%E8%AE%A1%E5%88%92/</link>
      <pubDate>Fri, 16 Jul 2021 23:25:25 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/%E6%82%AC%E6%A2%81%E8%AE%A1%E5%88%92/</guid>
      <description>此计划旨在逆袭人生，当让人刮目相看。
以此步骤开始学习，第一阶段巩固计算机基础知识
王道四门主要专业课和习题花10天过一过，期间结合b站讲的比较精的视频加深理解
第二阶段巩固Java学习成果
第三阶段开始学习机器学习
第四阶段努力学习必要软件的使用</description>
    </item>
    
    <item>
      <title>Java核心技术第十三章笔记-事件处理部署Java应用程序</title>
      <link>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E9%83%A8%E7%BD%B2java%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Thu, 15 Jul 2021 15:27:03 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E9%83%A8%E7%BD%B2java%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</guid>
      <description>JAR文件
将应用程序进行打包时吗，使用者希望仅提供其一个单独的文件，而不是一个含有大量类文件的目录。JAR文件就是为此目的而设计的 。一个JAR文件既可以包含类文件，也可以包含诸如图像换个声音这些其他类型的文件。此外，JAR文件是压缩的，它使用了大家熟悉的ZIP压缩格式。
创建JAR文件
可以使用jar工具制作JAR文件。创建一个新的JAR文件常见的命令格式为jar。
可以将应用程序，程序组件以及代码库打包在JAR文件中。例如，JDK的运行时库包含在一个非常庞大的文件rt.jar中。
清单文件
除了类文件、图像和其他资源外i，每个JAR文件还包含一个用于描述归档特征的清单文件。
清单文件被命名为 MANIFEST.MF，它位于JAR文件的一个特殊META-INF子目录中。最小的符合标准的清单文件是简单的：
Manifest-Version:1.0
复杂的清单文件可能包含更多条目。这些清单条目被分为多个节。第一节被称为主节。它作用于整个JAR文件。随后的条目用来指定已经命名条目的属性。这些已命名的条目可以是某个文件、包或者URL。它们都必须起始于名为Name的条目。节与节之间用空格分开
无论怎样，人们对JAR文件中的Java程序和本地文件有不同的感觉。在Windows平台中，可以使用第三方的包装器工具将JAR文件转换成Windows可执行文件。包装器是一个大家熟知的扩展名为.exe的Windows程序，它可以查找和加载Java的虚拟机，或者在没有找到JVM时，告诉用户应该做些什么。
应用首选项的存储
属性映射时一种存储键值对的数据结构。属性映射通常用来存储配置信息，它有3个特性：键和值是字符串。映射可以很容易地存入文件以及从文件加载。有一个二级表保存默认值。
实现属性映射的Java类名为Properties。
利用Properties类可与很容易地加载和保存配置文件。不过，使用属性文件有以下缺点：有些操作系统没有主目录的概念，所以和南宁找到一个统一的配置文件位置。
关于配置文件的命名没有标准阅读，用户安装多个Java应用时，就更容易发生命名冲突。</description>
    </item>
    
    <item>
      <title>Java核心技术第十四章笔记-并发</title>
      <link>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0-%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Fri, 09 Jul 2021 18:51:26 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0-%E5%B9%B6%E5%8F%91/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Java核心技术第十一章笔记-事件处理</title>
      <link>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</link>
      <pubDate>Thu, 08 Jul 2021 15:39:46 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</guid>
      <description>像Java这样的面向对象语言，都将事件的相关信息封装在一个事件对象中。在Java中，所有的事件对象都最终派生于一个类java.util.EventObject类。当然，每个事件类型还有子类，例如，ActionEvent和WindowsEvent。
不同的事件源可以产生不同类别的事件。例如图，按钮可以发送一个ActionEvent对象，而窗口可以发送WindowsEvent对象。、
下面是AWT事件处理机制的概要
 监听器对象是以一个实现了特定监听器接口的类的实例。 事件源是一个能够注册监听器对象并发送事件对象的对象 当事件发生时，事件源将事件对象传递给所有注册的监听器。 监听器对象将利用事件对象中的信息决定如何对事件做出响应。  ActionListener listener=...;JButton button =new JButton(&amp;quot;OK&amp;quot;);button.addActionListener(listener);现在只要按钮产生了一个动作事件，listener对象就会得到通告。对于按钮来说，正像我们所想到的，动作事件就是点击按钮。
为了实现ActionListener接口，监听器类必须有一个被称为actionPerformed的方法，改方法接受一个ActionEvent对象参数。
只要用户点击按钮，JButton对象就会创建一个ActionEvent对象，然后调用listener.action Performed(event)传递事件对象。可以将多个监听器对象添加到一个按钮这样的事件源中。
这样一来，只要用户点击按钮，按钮就会调用所有监听器的actionPerformed方法。
简洁地指定监听器
一个监听器有多个实例的情况并不多见。更常见的情况是：每个监听器执行一个单独的动作。在这种情况下，没有必要分别建立单独的类。只需要使用一个Lambda表达式：
exitButton.addActionListener(event→System.exit(0) )AWT将事件分为底层事件和语义事件。语义事件是表示用户动作的事件，例如，点击按钮。以那次，ActionEvent是一种语义事件。底层事件是形成那些事件的事件。在点击按钮时，包含了按下鼠标、连续移动鼠标、抬起鼠标事件。或者在用户利用TAB键选择按钮，并利用空格键激活它时，发生的敲击键盘事件。同样，调节滚动条是一种语义事件，但拖动鼠标是底层事件。</description>
    </item>
    
    <item>
      <title>Java核心技术第九章笔记-集合</title>
      <link>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E4%B9%9D%E7%AB%A0%E7%AC%94%E8%AE%B0-%E9%9B%86%E5%90%88/</link>
      <pubDate>Sat, 03 Jul 2021 23:59:02 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E4%B9%9D%E7%AB%A0%E7%AC%94%E8%AE%B0-%E9%9B%86%E5%90%88/</guid>
      <description>Java集合类库是接口与实现分离的。一旦构建了集合就不需要知道究竟使用哪种实现。可以是顺序表可以是链表，可以是队列，可以是循环数组。
集合类的基本接口是Colection接口，有两个基本方法
add 方法向集合中添加元素。如果添加元素改变了集合就返回true，如果集合没有发生变化就返回false。例如，如果试图向集中添加一个对象，而这个对象在集中已经存在，这个添加请求就没有失效，因为集中不允许有重复的对象。iterator方法用于返回一个实现了Iterator接口的对象。可以用这个迭代器对象以此访问集合中的元素。
迭代器
通过反复调用next方法，可以逐个访问集合中的每个元素。但是如果到达了集合末尾，next方法将抛出一个五元素的以此。因此，在调用next之前调用hasNext方法。如果迭代器对象还有多个供访问的元素，这个方法就返回true。如果想要查看集合中的所有元素，就请求一个迭代器，并在hasnext返回true时反复调用next方法。
用for each循环可以更加简练地表示同样的循环操作：
for (String element:collection){do something with element}编译器简单地将for each循环翻译为带有迭代器的循环.
for each 循环可以与任何实现了Iterable接口的对象一起工作。
Collection接口扩展了Iterable接口。因此，对于标准类库中的任何集合都可以使用for each循环。
应该将Java迭代器认为是位于两个元素之间。当调用next时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用。
Iterator接口的remove方法将会删除上次调用next方法时返回的元素。
更重要的时，对next方法和remove方法的调用具有互相依赖性。如果调用remove之前没有调用next将是不合法的。
如果向删除两个相邻的元素，中间必须用next越过将要删除的元素。
集合框架中的接口
Java集合框架为不同类型的集合定义了大量接口
集合有两个基本接口：Collection和Map
List是一个有序集合。元素会增加到容器中的特定位置。可以采用两种方式访问元素：使用迭代器访问，或者使用一个整数索引来访问。后遗症被称为随机访问，因为这样可以按照任意顺序访问元素。
链表尽管也是有序的，但是随机访问很慢，所以最好使用迭代器来遍历。
set接口等同于Collection接口。其add方法不允许增加重复的元素。只要两个集合包含同样的元素就认为是相等的，不需要元素有相同的顺序。hashcode方法的定义要包装包含相同元素的两个集会得到相同的散列码。
建立一个set接口可以让程序员编写只接受集的方法。
SortedSet和SortedMap接口会提供用于排序的比较器对象，这两个接口定义了可以得到集合子集视图的方法。
链表与泛型集合之间有一个重要的区别，链表是一个有序集合。
如果链表中只有很少几个元素，就完全没有必要为get方法和set方法的开销而烦恼，但是优先使用链表的唯一理由是尽可能减少 在列表之间插入或删除元素所付出的代价。如果列表中只有少数几个元素，完全可以使用ArrayList。
建议避免使用以整数索引表示链表中位置的所有方法。如果对集合进行随机访问，就使用数组或ArrayList，而不要使用链表。
List接口用于描述一个有序集合，并且集合中每个元素的位置十分重要。有两种访问元素的协议：一种是用迭代器，另一种是用get和set方法随机访问每个元素。后者不适用于链表，但对数组很有用。集合类库提供了一种大家熟悉的ArrayList类，这个类也实现了List接口。ArrayList封装了一个动态再分配的对象数组。
注意：对于一个经验丰富的Java程序员，在需要动态数组时，可能会使用Vector类。为什么要用ArrayList取代Vector呢？原因很简单：Vector类的所有丰富都是同步的。可以由两个线程安全地访问一个Vector对象。但是，如果有一个线程访问Vector,代码要在同步操作上耗费大量的实际。而ArrayList方法不是同步的。因此，建议在不需要同步时使用ArrayList,而不要使用Vector。
散列集
链表和数组可以按照人们的意愿排列元素的次序。单数，如果想要查看某个指定的元素，却又忘记了它的位置，就需要访问所有的元素，知道找到为止。如果集合中包含的元素很多，将会消耗很多的时间。如果不在意元素的顺序，可以又集中能够快速 查找元素的数据结构。其缺点是无法控制元素出现的次序。它们将按照有利于其操作目的的原则组织数据。
有一种众所周知的数据结构，可以快速地查找所需要的对象，这就是散列表。散列表为每个对象计算一个整数，称为散列码。散列码是由对象的实例域产生一个整数。更准确地说，具有不同的数据域将产生不同的散列码。
最重要的问题是散列码要能够快速地计算出来，并且这个计算只与要散列的对象状态有关，与散列表中的其他对象无关。
在Java中，散列表用链表数组实现。每个列表被称为桶。要想查找标准对象的位置，就要先计算它的散列码，然后与桶的zoo那个书取余，所得到的结果就是保存这个元素的桶的索引。
有时候会遇到桶被占满的情况，这也是不可避免的。这种现象被称为散列冲突。
这是，需要用新对象与桶中的所有对象进行比较，查看这个对象是否已经存在。如果散列码是合理且随机分布的，桶的数目也足够大，需要比较的次数就会很少。
在Javase8中，桶满时会从链表变为平衡二叉树。如果选择的散列函数不当，或者如果有恶意代码试图在散列表中填充多个有相同散列码的值，会产生很多冲突。
想要更多的控制散列表的运行性能，就要指定一个初始的桶数。桶数是指用于收集具有相同散列值的桶的数目。如果要插入到散列表中的元素太多，就会增加冲突的可能性，降低运行性能。
如果大致指定最终由多少个元素插入到散列表中，就可以设置桶数。通常，将桶数设定为预计元素个数的75%-150%。最好将桶数设置为一个素数。以防止键的聚集。
如果散列表太慢，就需要再散列，如果要对散列表再散列，就需要创建以恶个桶数更多的表，并将所有元素插入到这个信标中，然后丢弃原来的表。装填因子决定合适对散列表进行再散列。例如，如果装填因子为0.75，而表中超过75%的位置已经填入元素，这个表就会用双倍的桶数自动地进行再散列。对于大多数应用程序来说，装填因子为0.75是比较合理的。
散列表可以用于实现几个重要的数据结构，其中最简单的是set类型。set是没有重复元素的元素结合。set的add方法首先在集中查找要添加的对象，如果不存在，就将这个对象添加进去。
Java集合类库提供了一个HashSet类，它实现了基于散列表的集。可以用add方法添加元素。contains方法已经被重新定义，用来快速的查看是否某个元素已经出现在集中。它只在某个桶中查找元素，而不必查看集合中的所有元素。
散列集迭代器将以此访问所有的桶。由于散列将元素分散在表的各个位置上，所以访问它们的顺序几乎是随机的。只有不关心集合中的元素的顺序时，才应该使用HashSet。
在更改集中元素时要格外小心，如果元素的散列码发生了改变，元素在数据结构中的位置也会发生变化。
树集
TreeSet与散列集十分类似，不过，它比散列集有所改进。树集是一个有序集合。可以以任意顺序将元素插入到集合中。在对集合进行遍历时，每个值将自动按照排序后的顺序呈现。
排序时用树结构完成的，当前实现使用的是红黑树。每次将一个元素添加到树中时，都被放置到正确的位置上。因此，迭代器总是以排好序的顺序访问每个元素。
将一个元素添加到树中要比添加到散列表中慢。如果树中包含n个元素，查找新元素的正确位置平均需要log2n次比较。
要使用树集，必须能够比较元素。这些元素必须实现Comparable接口。或者构造集时必须提供一个Comparator。
是否应该用树集取代散列集。比较添加一个元素所花费的时间看上去不长，而且元素是自动排序的。到底应该怎么做将取决于所要收集的数据。如果不需要对数据进行排序，就没有必要付出排序的开销。更重要的是，对于某些数据来说，对其排序要比散列更加困难。散列函数只是将对象适当地打乱存放，而比较却要精确地判别每个对象。
队列
队列可以乳糖人们有效地在尾部添加一个元素，在头部删除一个元素。由两个端头的队列，即双端队列，可以让人们有效地在头部和尾部同时添加或删除元素。不支持在队列中间添加元素。
优先级队列
优先级队列中的元素可以按照任意的顺序进行插入，却总是按照排序的顺序进行检索。也就是说，无论何时调用remove方法，总会获得当前优先级队列中最小的元素。然而，优先级队列并没有对所有的元素进行排序。如果用迭代的方式处理这些元素，并不需要对它们进行排序。优先级队列使用了一个优雅且高效的数据结构称为堆。堆是一个可以自我调整的二叉树，对树执行添加和删除操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序。
与TreeSet一样，一个优先级队列既可以保存实现了Comparable接口的类对象，也可以保存在构造器中提供的Comparator对象。
使用优先级队列的典型示例是任务调度。每个任务有一个优先级，任务以随机顺序添加到队列中。每当启动一个新的任务时，都将优先级最高的任务从队列中删除 。由于习惯上将1设为最高优先级，所有会将最小的元素删除。</description>
    </item>
    
    <item>
      <title>Java核心技术第八章笔记-泛型程序设计</title>
      <link>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%85%AB%E7%AB%A0%E7%AC%94%E8%AE%B0-%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Fri, 02 Jul 2021 19:24:20 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%85%AB%E7%AB%A0%E7%AC%94%E8%AE%B0-%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</guid>
      <description>泛型机制编写的程序代码要比那些杂乱地使用Object变量，然后再进行强制类型转换的代码具有更好的安全性和可读性。泛型对于集合类尤其有用，例如，ArrayList就是一个无处不在的集合类。
泛型很像C++中的模板。与Java一样，在C++中，模板也是最先被添加到语言中支持强类型集合的。但是，多年以后人们发现模板那还有其他的用武之地。
泛型程序设计意味着编写的代码可以被很多不同的类型的对象所重用。例如，我们并不希望为聚集String和File对象分别设计不同的类。实际上，也不需要这样做，因为一个ArrayList类可以聚集任何类型的对象。
实际上，在Java增加泛型类之前已经有一个ArrayList类。
数组列表比数组好在可以进行自动扩展。
实现一个泛型类没有那么容易，一个泛型程序员的任务就是预测出所用类的未来可能有的所有用途。
定义简单泛型类
一个泛型类就是具有一个或多个类型变量的类。泛型类可以有多个类型变量。例如，可以定义Pair类，其中第一个域和第二个域使用不同的类型。
类型变量使用大写形式，且比较短，这是很常见的。在Java库中，使用变量E表示集合的元素类型。K和V 分别表示表的关键字和值的类型。T表示任意类型。
泛型方法
泛型方法可以定义在普通类中，也可以定义在泛型类中。
当调用一个泛型方法时，在方法名前的尖括号中放入具体的类型。 ·
类型变量的限定
有时，类或方法需要对类型变量加以约束。变量smallest类型从为T。这意味着它可以是任何一个类的对象。怎么才能确信T所属的类有compareTo方法呢？
解决这个问题的方案是将T限制为实现了Comparable接口的类。可与通过对类型变量T设置限定实现这一点：
实际上Comparable接口本身就是一个泛型类型。目前，我们忽略其复杂性以及编译器产生的警告。
&amp;lt;T extends BoundingType&amp;gt;表示T一个是绑定类型的子类型。T和绑定类型可以是类，也可以是接口。选择关键字extends的原因是更接近子类的概念，并且Java的设计者也不打算在语言中再添加一个新的关键字。 （如sub）
一个类型变量或通配符可以有多个限定，例如：
T extends Comparable &amp;amp; Serializable限定类型用”&amp;amp;“分隔，而逗号用来分隔类型变量。
泛型代码和虚拟机
虚拟机没有泛型类型对象——所有对象都属于普通类。再泛型实现的早期版本中，甚至能够将使用泛型的程序编译为在1.0虚拟机上运行的类文件。这个向后兼容性在Java泛型开发的后期被放弃了。
类型擦除
无论何时定义一个泛型类型，都自动提供了一个相应的原始类型。原始类型的名字就是删去类型参数后的泛型类型名。擦除类型变量，并替换为限定类型（无限定的变量用Object）
对于Pair因为T是一个无限定的变量，所以直接用Object替换。
结果是一个普通的类，就好像泛型引入Java语言之前已经实现的那样。
在程序中可以包含不同类型的Pair，例如Pair或Pair,而擦除类型后就变成原始的Pair类型了。
Java泛型与C++模板有很大区别。C++每个模板的实例化产生不同的类型，这一现象称为模板代码膨胀。Java不存在这个问题的困扰。
原始类型用第一个限定的类型变量来替换，如果没有给定限定就用Object替换。例如，类Pair中的类型变量没有显式的限定，因此，原始类型用Object替换T。假定声明了一个不同的类型。
翻译泛型表达式
当程序调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换。例如下面这个语句序列
Pair&amp;lt;Employee&amp;gt; buddies=...;Employee buddy =buddies.getFirst();擦除getFirst的返回类型后将返回Object类型。编译器自动插入Employee的强制类型转换。也就是说，编译器把这个方法调用翻译为两条虚拟机指令：
对原始方法Pair.getFirst的调用
对返回的Object类型强制转换为Employee类型。
当存取一个泛型域时也要插入强制类型转换。假设Pair类的first域和second域都是公有的。表达式
Employee buddy =buddies.first;会在结果字节码中插入强制类型转换。
翻译泛型方法
类型擦除也会出现在泛型方法中。通常认为下述的泛型方法是一个完整的方法族
public static &amp;lt;T extends Copmparable&amp;gt;T min(T[] a)而擦除类型之后，只剩下一个方法:
public static Comparable min(Comparable[] a)注意，类型参数T已经被擦除了，只留下了限定类型Comparable</description>
    </item>
    
    <item>
      <title>异常、断言和日志</title>
      <link>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%AC%94%E8%AE%B0-%E5%BC%82%E5%B8%B8%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97-/</link>
      <pubDate>Sat, 19 Jun 2021 20:04:09 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%AC%94%E8%AE%B0-%E5%BC%82%E5%B8%B8%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97-/</guid>
      <description>对于异常情况，Java使用一种称为异常处理的错误捕获机制。
在测试期间，需要进行大量的检测以验证程序操作的正确性。然而，这些检测可能非常耗时，在测试完成后也不必保留它们，因此，可以将这些检测删掉，并在其他测试需要时将它们粘贴回来，这是一件很乏味的事。可以使用断言来有选择地启用检测。
当程序出现错误时，并不总是能够与用户或终端进行沟通，此时，可能希望记录下出现的问题，以备日后进行分析。
处理错误
如果由于出现错误而使得某些操作没有完成，程序应该：
 返回到一种安全状态，并能够让用户执行一些其他的命令 或者允许用户保存所有操作的结果，并以妥善的方式终止程序。  异常处理的任务就是将控制权从错误产生的地方转移给能够处理这种情况的错误处理器。
以下为常见的错误：
1.用户输入错误 假设有一个用户请求连接一个URL，而语法却不正确。在程序代码中应该对此进行检测，如果没有检查，网络层就会给出警告。 2.设备错误 例如，打印机在打印过程中可能没有纸了 3.物理限制 磁盘满了，可用存储空间已被用完。 4.代码错误 异常结构
所有的异常都由Throwable继承而来，但在下一层立即分解为两个分支：Error和Exception。
Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出这种类型的对象。如果出现了这样的内部错误，除了通告给用户，并尽力使程序安全终止之外，再也无能为力了。这种情况很少出现 。
而Exception又分为运行时RuntimeException异常，另一个分支IOException包含其他异常。划分两个分支的规则是：由出现错误导致的异常属于RuntimeException;而程序本身没有问题，但由于像IO错误这类问题导致的异常属于其他异常。
派生于RuntimeException的异常下面几种情况：
错误的类型转换 数组访问越界 访问null指针
不派生于RuntimeException的异常包括：
 试图在文件尾部读取数据 试图打开一个不存在的文件 试图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在。  如果出现运行时异常一般是程序员本身的问题。这些都一个在运行之前通过检测避免。如何处理不存在的文件呢？难道不能先检测文件是否存在再打开它吗？这个文件可能在你检查它是否存在之前就已经被删除了。是否存在取决于环境，而不只是取决于你的代码。
Java语言规范件将派生于Error类或RuntimeException类的所有异常称为非受查异常（unchecked），所有其他的异常称为受查异常。编译器将核查是否为所有的受查异常提供了异常处理器。
RuntimeException很容易混淆。实际上所有的错误都发生在运行时。
声明受查异常
如果遇到了无法处理的情况，那么Java的方法可以抛出一个异常。一个方法不M仅需要告知编译器将要返回什么值，还要告诉编译器有可能发生什么错误。
方法应该在首部声明所有可能抛出的异常。这样可以从首部反映出这个方法可能抛出哪类受查异常。 如
public FileInputStream(String name) throw FileNotFoundException 这个声明表示这个构造器将根据给定的String参数产生一个FileInputStream对象，但也可能抛出一个FileNotFoundException异常。如果发生了这种糟糕情况，构造器将不会初始化一个新的FileInputStream对象，而是抛出一个FileNotFoundException异常。如果发生了这种糟糕情况，构造器将不会初始化一个新的FileInputStream对象，而是抛出一个FileNotFoundException类对象。如果这个方法真的抛出来这样一个异常对象，运行时系统就会开始搜索异常处理器，以便知道如何处理FileNotFoundException类对象。
在自己编写方法是，不必将所有可能抛出的异常都进行声明。至于什么时候需要在方法中用throw子句声明异常，什么异常必须使用throw子句声明，需要记住以下4种情况需要抛出异常。
1.调用一个抛出受查异常的方法
2.程序运行过程发现错误并且利用throw语句抛出下一个受查异常。
3.程序出现错误
4.Java虚拟机和运行时库出现的内部错误
如果出现前两种情况之一，则必须告诉调用这个方法的程序员有可能抛出异常。为什么？因为任何一个抛出异常的方法都有可能是一个死亡陷阱。如果没有处理器捕获这个异常 ，当前执行的线程就会结束。
对于哪些可能被他人使用的Java方法，应该更具异常规范，在方法的首部声明这个方法可能抛出的异常。
如果一个方法有可能抛出多个受查异常类型，那么就必须在方法首部列出所有的异常类，每个异常类之间用逗号隔开。
但是不需要声明Java的内部错误，即从Error继承的错误。任何程序代码都具有抛出那些异常的潜能，而我们对其没有任何控制能力。
同时也不应该声明从RuntimeException继承的那些非受查异常。这些错误完全在我们的控制之下。如果特别关注数组下标引发的错误，就应该将更多的事件花费在修正程序的错误上，而不是说明这些错误发生的可能性上。
总之，一个方法必须声明所有可能抛出的受查异常，而非受查异常要么不可控制，要么就一个避免发生。
除了声明异常，还可以进行捕获。这样会使异常不被抛到方法之外，也不需要throw规范。
如果在子类中覆盖了超类的一个方法，子类方法中声明的受查异常不能比超类方法中声明的异常更通用。也就是说子类方法可以抛出更特定具体的异常或根本不抛出任何异常。
对于一个已经存在的异常类，将其抛出非常容易。
1.找到一个合适的异常类 2.创建这个类的一个对象 3.将对象抛出 一旦方法抛出了异常，这个方法就不可能返回调用者。也就是说，不必为返回的默认值或错误代码担忧。
创建异常类
在程序中，可能遇到标准异常类不能清楚描述问题。这种情况下，创建自己的异常类就是顺理成章的事情。我们需要做的只是定义一个派生于Exception的类，或者派生于EXception子类的类。
例如，定义一个派生于IOException的类。习惯上，定义的类应该包含两个构造器，一个是默认的构造器；另一个是带有详细描述信息的构造器。
捕获异常
只要将异常抛出就不用理睬了。但是有些代码必须捕获异常。如果某个异常发生的时候没有在任何地方进行捕获， 那程序就会终止执行，并在控制台上打印出异常信息，其中包括异常的类型和堆栈的内容。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zereals7.github.io/post/2022-1-24-2022%E5%B9%B41%E6%9C%8822-222857/</link>
      <pubDate>Sun, 06 Jun 2021 16:23:47 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/2022-1-24-2022%E5%B9%B41%E6%9C%8822-222857/</guid>
      <description>【机器学习】 线性模型形式简单、易于建模。许多功能更为强大的非线性模型可在线性模型的基础上通过引入层级结构或高维映射而得。此外，由于w直观表达了各属性在预测中的重要性，因此线性模型有很好的可解释性。
线性回归
对离散属性，若属性间存在序的关系，可通过连续化将其转化为连续值例如二值属性.
均方误差有非常好的几何意义，它对应了常用的欧几里得距离。基于均方误差最小化来进行模型求解的方法称为最小二乘法。
线性回归中，最小二乘法就是试图找到一条直线，使所有样本到直线的欧氏距离之和最小。
决策树
决策树是一类常见的机器学习方法，以二分类任务为例，我们希望从给定巡礼那数据集学得一个模型用以对新示例进行分类。一般的，一颗决策树包含一个根结点、若干个内部结点和若干个叶结点。
决策树学习的目的是为了产生一颗泛化能力强，即处理未见示例能力强的决策树，其基本流程遵循简单而直观的分而治之策略。
显然，决策树的生成是一个递归过程，在决策树算法中，有三种情况会导致递归返回。
、1.当前结点包含的样本全属于同一类别，无需划分。
2.当前属性集为空，或是所有样本在所有属性上取值相同，无法划分。
3.当前结点包含的样本集合为空，不能划分。
一般而言，随着划分过程不断进行，我们希望决策树的分支结点所包含的样本尽可能属于同一类别，即结点的纯度越来越高。
**信得的纯度提升越大。
一般而言，信息增益越大，则意味着使用属性a来进行划分获得的纯度提升越大。
计算出最大的信息增益对应的属性可作为进行划分的。然后再以子节点最大信息增益对应的属性进行划分，最后可以得到决策树。
实际上，信息增益准则对可取值数目较多的属性有所偏好，为减少这种偏好可能带来不利影响，决策树算法不使用信息增益，而是使用增益率来选择最优划分属性。增益率准则对可取值较少的属性有所偏好，算法并不是直接选择增益率最大的候选划分属性，而是使用一个启发式：先从候选划分属性中找出信息增益高于平均水平的属性，再从中选择增益率最高的。
基尼指数
决策树使用基尼指数来选择划分属性
数据集D的纯度可用基尼值来度量。
基尼越小数据集D的纯度越高。我们再候选属性集合A中，选择那个使得划分后基尼指数最小的属性作为最优划分属性。
剪枝处理
剪枝是决策树算法对付过拟合的主要手段，再决策树学习中，为了尽可能正确分类训练样本，结点划分过程将不断重复，有时会造成决策树分支过多，这时就可能因训练样本学得太好了，以至于把训练集自身的一些特点当作所有数据都具有的一般性质而导致过拟合。因此，可通过主动去掉一些分支来降低过拟合的风险。
【神经网络】 神经网络是由具有适应性的简单单元组成的广泛并行互连的网络，它的组织能够模拟生物神经系统对真实世界物体所作出的交互反应。
神经网络中最基本的是神经元模型。生物神经网络这，每个神经元与其他神经元相连，当它兴奋时，就会向相连的神经元发送化学物质，从而改变这些神经元的电位。如果某神经元电位超过了一个阈值，那么它就会被激活，即兴奋起来，向其他神经元发送化学物质。
神经元接收到的总输入值将与神经元的阈值进行比较，然后通过激活函数处理以产生神经元的输出。
理想的激活函数是阶跃函数，它将输入值映射为输出值0或1，显然1对应神经元兴奋，0对应于神经元抑制。然而阶跃函数具有不连续、不光滑等不太好的性质。因此时常使用sigmod挤压函数来作为激活函数。。它把较大范围变化的输入值挤压到（0,1）输出值范围内，因此有时也称为挤压函数。
把许多个神经元按一定层次结构连接起来，就得到了神经网络。
只需将一个神经网络视为包含了许多参数的数学模型，这个模型是若干个函数，相互代入得到。
感知机与多层网络
感知机由两层神经元组成。输入层接收外界输入信号后传递给输出层，输出层是MP神经元，也称阈值逻辑单元。
感知机能容易地实现逻辑与或非运算。
更一般的，给定训练数据集，权重以及阈值可通过学习得到。
若感知机对训练样例的预测准确，则感知机不发生变化，否则将根据错误的程度进行权重调整。
要注意的是，感知机只有输出层神经元进行激活函数处理，即只拥有一层功能神经元，其学习能力非常有限。
事实上与或非等问题都是线性可分问题。若两类模式是线性可分的，即存在一个超平面能将其分开。
感知机的学习过程一定会收敛，且求得适当的权向量。否则感知机学习过程将会发生震荡。
要解决非线性可分的问题，需考虑使用多层功能神经元。输出层与输入层之间的一层神经元被称为隐含层，隐含层和输出层神经元都具有激活函数的功能神经元。
更一般的，常见的神经网络是层级结构，每层神经元与下一层神经元全互连，神经元之间不存在同层连接，也不存在跨层连接。这样的神经网络结构通常称为多层前馈神经网络。
其中输入层神经元接收外界输入，隐层和输出层神经元对信号进行加工。最终结果由输出层神经元输出；换言之，输入层神经元仅是接受输入，不进行函数处理，隐层与输出层包含功能神经元。只需包含隐层即可称为多层网络，神经网络的学习过程，就是根据训练数据来调整神经元之间的连接权以及每个功能神经元的阈值。换言之，神经网络学到的东西，蕴含在连接权与阈值中。
误差逆传播算法
多层网络的学习能力比单层感知机强的多。要训练多层网络，简单感知机学习规则显然不够，需要更为强大的学习算法。误差逆传播（BP）算法就是其中杰出的代表，它是迄今最成功的神经网络学习算法。现实任务中，使用神经网络时，大多是在使用BP算法进行训练
值得指出的是，BP算法不仅可用于多层前馈神经网络，还可用于其他类型的神经网络。例如训练递归神经网络。但通常说BP网络时，一般是指用BP算法训练的多层前馈神经网络。
BP算法探秘
BP是一个迭代学习算法，在迭代的每一轮中采用广义的感知机学习规则对参数进行更新估计。
BP算法基于梯度下降策略，以目标负梯度方向对参数进行调整。
学习率n控制算法每一轮迭代中的更新步长，若太大则容易振荡，太小则收敛速度又会过慢。对于学习率即步长非常敏感。
不能保证全局最低，只能是局部最低。
BP算法基本工作流程
对每个训练样例 ，BP算法执行以下操作：先将输入示例提供给输入层神经元，然后逐层将信号前传，直至产生输出层结果；然后计算输出层的误差，再将误差逆向传播至隐层神经元，最后根据隐层神经元误差来对连接权和阈值进行调整。该迭代过程循环进行，直到达到某些停止条件为止。例如训练误差已达到一个很小的值。
BP算法的目标是要最小化训练集D上的累积误差 损失函数
标准BP算法每次仅针对一个训练样例更新连接权和阈值。
累积BP算法和标准BP算法都很常用，一般来说，标准BP算法每次更新只针对单个样例，参数更新得非常频繁，而且对不同样例进行更新的效果可能出现抵消现象。因此，为了达到同样的累积误差极小点，标准BP算法往往需要进行更多次数的迭代。
累积BP算法直接针对累积误差最小化，它在读取整个训练集D一遍后才对参数进行更新，一步下降会非常缓慢。这时标准BP往往会更快获得较好的解，尤其是在训练集D非常大时更明显。
只需一个包含足够多神经元的隐层，多层前馈网络就能以任意复杂度的连续函数。然而，如何设置隐层神经元的个数仍是个未决问题，实际应用中通常靠试错法调整。
正是由于其强大的表示能力，BP神经网络经常遭遇过拟合，其训练误差持续降低，但测试误差却可能上升。有两者策略常用来缓解BP网络的过拟合 。第一种策略是早停：将数据分为训练集和验证集，训练集用来计算梯度、更新连接权和阈值，验证集用来估计误差。若训练集误差降低但验证集误差升高，则停止训练，同时返回具有最小验证集误差的连接权和阈值。
第二种策略是正则化，其基本思想是在误差目标函数中增加一个用于描述网络复杂度的部分，例如连接权与阈值的平方和。
全局最小与局部极小
若用E表示神经网络在训练集上的误差，则它显然是关于连接权和阈值的函数。此时，神经网络的训练过程可看作一个参数寻优过程，即在参数空间中，寻找一组最优参数使得E最小。
显然参数空间内梯度为0的点只要其误差函数值小于邻点的误差函数值，就是局部极小点。但却只会有一个全局最小值。
基于梯度的搜索是使用最为广泛的参数寻优方法。在此类方法中，我们从某些初始解出发，迭代寻找最优参数值。每次迭代中。我们先计算误差函数在当前点的梯度，然后根据梯度确定搜索方向。例如，由于负梯度方向是函数值下降最快的方向，因此梯度下降法就是沿着负梯度方向搜索 最优解。若误差函数在当前点的梯度为0则已到局部极小，更新量将为0，这意味着参数的迭代更新在此停止。显然，如果误差函数仅有一个局部极小，那么此时找到的局部极小就是全局最小 。然而，如果误差具有多个局部极小，则不能保证找到的解是全局最小。对后一种情况，我们称参数陷入了局部极小，这不是我们所希望的。
现实任务中，人们常用一下策略试图跳出局部极小，从而进一步接近全局最小。
以多组不同参数值初始化多个神经网络，按标准方法训练后，取其中误差最小的解作为最终参数。这相当于从多个不同的初始点开始搜索，这样就可能陷入不同的局部极小，从中进行选择有可能获得更接近全局最小的结果。</description>
    </item>
    
    <item>
      <title>2022年1月22</title>
      <link>https://zereals7.github.io/post/2022%E5%B9%B41%E6%9C%8822/</link>
      <pubDate>Sun, 06 Jun 2021 16:23:47 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/2022%E5%B9%B41%E6%9C%8822/</guid>
      <description>【机器学习】 线性模型形式简单、易于建模。许多功能更为强大的非线性模型可在线性模型的基础上通过引入层级结构或高维映射而得。此外，由于w直观表达了各属性在预测中的重要性，因此线性模型有很好的可解释性。
线性回归
对离散属性，若属性间存在序的关系，可通过连续化将其转化为连续值例如二值属性.
均方误差有非常好的几何意义，它对应了常用的欧几里得距离。基于均方误差最小化来进行模型求解的方法称为最小二乘法。
线性回归中，最小二乘法就是试图找到一条直线，使所有样本到直线的欧氏距离之和最小。
决策树
决策树是一类常见的机器学习方法，以二分类任务为例，我们希望从给定巡礼那数据集学得一个模型用以对新示例进行分类。一般的，一颗决策树包含一个根结点、若干个内部结点和若干个叶结点。
决策树学习的目的是为了产生一颗泛化能力强，即处理未见示例能力强的决策树，其基本流程遵循简单而直观的分而治之策略。
显然，决策树的生成是一个递归过程，在决策树算法中，有三种情况会导致递归返回。
、1.当前结点包含的样本全属于同一类别，无需划分。
2.当前属性集为空，或是所有样本在所有属性上取值相同，无法划分。
3.当前结点包含的样本集合为空，不能划分。
一般而言，随着划分过程不断进行，我们希望决策树的分支结点所包含的样本尽可能属于同一类别，即结点的纯度越来越高。
信息熵
是度量看样本集合纯度最常用的一种指标。信息熵越小纯度越高。
一般而言，信息增益越大，则意味着使用属性a来进行划分获得的纯度提升越大。
计算出最大的信息增益对应的属性可作为进行划分的。然后再以子节点最大信息增益对应的属性进行划分，最后可以得到决策树。
实际上，信息增益准则对可取值数目较多的属性有所偏好，为减少这种偏好可能带来不利影响，决策树算法不使用信息增益，而是使用增益率来选择最优划分属性。增益率准则对可取值较少的属性有所偏好，算法并不是直接选择增益率最大的候选划分属性，而是使用一个启发式：先从候选划分属性中找出信息增益高于平均水平的属性，再从中选择增益率最高的。
基尼指数
决策树使用基尼指数来选择划分属性
数据集D的纯度可用基尼值来度量。
基尼越小数据集D的纯度越高。我们再候选属性集合A中，选择那个使得划分后基尼指数最小的属性作为最优划分属性。
剪枝处理
剪枝是决策树算法对付过拟合的主要手段，再决策树学习中，为了尽可能正确分类训练样本，结点划分过程将不断重复，有时会造成决策树分支过多，这时就可能因训练样本学得太好了，以至于把训练集自身的一些特点当作所有数据都具有的一般性质而导致过拟合。因此，可通过主动去掉一些分支来降低过拟合的风险。</description>
    </item>
    
    <item>
      <title>Java核心技术第六章笔记-接口、lambda表达式和内部类</title>
      <link>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%AC%94%E8%AE%B0-%E6%8E%A5%E5%8F%A3lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB-/</link>
      <pubDate>Sun, 16 May 2021 23:10:42 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%AC%94%E8%AE%B0-%E6%8E%A5%E5%8F%A3lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB-/</guid>
      <description>接口主要用来描述类具有什么功能，而并不给出每个功能的具体实现。一个类可以实现一个或多个接口，并在需要接口的地方，随时使用实现了相应接口的对象。
lambda表达式是一种表示可以在将来某个时间点执行代码块的简洁方法。使用lambda表达式，可以用一种精巧而简洁的方式表示使用回调或变量行为的代码。
内部类定义在另一个类的内部，其中的方法可以访问到包含它们外部类的域。内部类技术主要用于设计具有相互协作关系的类集合。
代理，这是一种实现任意接口的对象。代理是一种非常专业的构造工具，它用来构建系统级的工具。
**接口 **
接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的同一格式进行定义。
如果类遵从某个特定的接口，那么就履行这项服务。
Array类的sort方法承诺可以对对象数组进行排序，但要求类必须实现Comparable接口。
任何实现Comparable接口的类都需要包含compareTo方法。
接口中的所有方法自动地属于public。因此，在接口中声明方法时，不必提供关键字public。
有些接口可能包含多个方法。在接口中声明方法时，不必提供关键字public。
提供实例域和方法实现的任务应该由实现接口的那个类来完成。可以将接口看做是没有实例域的抽象类。
假设希望使用Arrays类的sort方法对Employee对象数组进行排序，Employee就必须实现Comparable接口。
为了 让类是实现一个接口，通常需要下面的步骤：
1.将类声明为实现给定的接口
2.对接口中的所有方法进行定义
接口的特性
接口不是类，不能用new运算符实例化一个接口。
尽管不能构造接口的对象，却能声明接口的变量：
Comparable x; 接口变量必须引用实现了接口的类对象
x =new Employee(&amp;hellip;)
与可以建立类的继承关系一样，接口也可以被扩展。这里允许存在多条从具有较高通用性的接口到较高专用性的接口的链。例如，假设有一个被称为Moveable的接口
public interface Moveable{ void move（double x,double y）; } 然后，可以以它为基础扩展一个叫做Powered的接口：
public interface Powerd extends Moveable{double milesPerGallon();}虽然接口中不能包含实例域或静态方法，但却可以包含常量。
与接口中的方法都能自动的设置为public一样，接口中的域将被自动的设为public static final。
有些接口只定义了常量，而没有定义方法。这样的接口似乎偏离了接口概念的初衷，最好不要这样使用它。
尽管每个类只能够拥有一个超类，但却可以实现多个接口。这能为定义类的行为提供极大的灵活性。
Java有一个非常重要的内置接口，称为 Cloneable。如果某个类实现了这个cloneable接口。Object类中的clone方法就可以创建类对象的一个拷贝。如果希望自己设计的类拥有克隆和比较的能力，只要实现这两个接口就可以了。使用逗号将实现的各个接口分隔开。
class Employee implements Cloneable,Comparable 接口与抽象类
使用抽象类表示通用属性存在一个问题：每个类只能扩展于一个类。假设已经扩展于一个类，就不能再扩展第二个类了。但每个类可以实现多个接口。实际上，接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。
静态方法
允许在接口中增加静态方法。目前为止，通常做法都是将静态方法放在伴随类中。在标准库中，会看到成对出现的接口和实用工具类。如Collection或Path。
Path类只包含两个工厂方法。可以由一个字符串序列构造一个文件或目录的路径。
默认方法
可以为接口提供一个默认实现。必须用default修饰符标记这样一个方法。
public interface Comparable&amp;lt;T&amp;gt;{ default int compareTo(T other){ return 0; } } Comparable 的每个实际实现都要覆盖这个方法。不过有些情况下，默认方法可能很有用。</description>
    </item>
    
    <item>
      <title>Java核心技术第五章笔记-继承</title>
      <link>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%AC%94%E8%AE%B0-%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Sun, 09 May 2021 03:40:06 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%AC%94%E8%AE%B0-%E7%BB%A7%E6%89%BF/</guid>
      <description>利用继承，可以基于已存在的类构造一个新类。继承已存在的类就是复用这些类的方法和域。在此基础上，还可以添加一些方法和域，以满足新的需求。
关键字extends表明正在构造的新类派生于一个已存在的类。已存在的类称为超类、基类或父类；新类称为子类、派生类、或孩子类。超类和子类是最常用的术语。
在设计类的时候，应该将通用的方法放在超类中，而将具有特殊用途的方法放在 子类中。
覆盖方法
超类中的有些方法对子类Manager不一定适用。为此需要提供一个新的方法来覆盖超类中的这个方法。子类的访问器方法不能直接访问父类的私有域。要用到公有的接口，也就是父类的访问器方法。比如
super.getSalary（） super不是一个对象的引用，不能将super献给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。
在子类中可以怎么增加域、增加方法或覆盖超类的方法，然而绝对不能删除继承的任何域和方法。
子类构造器
由于子类的构造器不能访问父类的私有域，所以必须利用父类的构造器对这部分私有域进行初始化，我们可以通过super实现对超类构造器的调用，使用super调用构造器的语句必须是子类构造器的第一条语句。。
如果子类的构造器没有显式地调用超类的构造器，则将自动的调用超类默认（没有参数）的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用超类里的其他构造器，则Java编译器将报告错误。
关键字this有两个用途：一是引入隐式参数，二是调用该类其他的构造器(重载解析)。
super关键字也有两个用途：一是调用超类的方法，二是调用超类的构造器（实际上也是一种特殊的方法）。
注意：调用构造器只能作为另一个构造器的第一条语句出现。 构造参数既可以传递给本类的其他构造器，也可以传递给超类的构造器。
虚拟机知道对象引用的实际类型，因此可以正确调用相应的方法。
一个对象变量可以指示多种实际类型的现象称为多态。在运行时能够自动地选择调用哪个方法的现象称为动态绑定。
Java不需要将方法声明为虚拟方法。动态绑定是默认的处理方式。
如果不需要让一个方法具有虚拟特征，可以将其标记为final。
继承层次
有一个公共积累派生出来的所有类的集合被称为继承层次。在继承层次中，从某个特定的类到其祖先的路径被称为该类的继承链。一个祖先类可以拥有多个子孙继承链。
多态
在Java中，对象变量是多态的。一个Employee变量既可以引用一个Employee类对象，也可以引用一个Employee类的任何一个子类的对象。（父类引用指向子类对象）
不能将一个超类的引用赋给子类变量。因为不是所以的父类都是子类。
子类数组的引用可以转换为超类数组的引用，而不需要采用强制类型转换。
所有数组都要牢记创建它们的元素类型，并负责监督仅将类型兼容的引用存储到数组中。否则可能引发数组存储异常。
绑定——方法调用
将一个方法调用同一个方法主体连接到一起称为绑定。如果在程序运行之前执行绑定，由编译器决定方法调用的程序，称为静态绑定。如果绑定过程在程序运行期间，以对象的类型为基础，称为动态绑定。
如果一种语言实现了后期绑定，同时必须提供一些机制，可以在运行期间判断对象的实际类型，并分别调用适当的方法，即便一起此时不知道对象的类型，但方法调用机制能够自己去调查，找到正确的方法主体。Java方法的执行主要采用动态绑定技术，在程序运行时，虚拟机将调用对象实际类型所限定的方法。
下面是调用的过程
1.编译器查看对象的声明类型和方法名。通过声明类型找到方法列表。
2.编译器查看调用方法时提供的参数类型。如果在所有相同方法名中存在一个提供的参数类型完全匹配，就选择这个方法。这个过程被称为重载解析。
3.如果是private方法、static方法、final方法或者构造器，那么编译器可以准确知道应该调用哪个方法。这种调用方式被称为静态绑定。与此对应的是，调用的方法依赖于隐式参数的实际类型，在运行时实现动态绑定。
动态绑定过程
4.当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。假设x的实际elixir时D，它是C类的子类。如果D类定义了了方法f（String）,就直接调用它；否则，将在D类的超类中寻找f（String）,以此类推。
每次调用方法的时候，虚拟机仅查找这个表就行了。在前面的例子中，虚拟机搜索的D类的方法表，以便寻找与调用f（String）相匹配的方法。这个方法即有可能是D.f(String)，又有可能是X.f(String)，这里的X是D的超类。如果调用super.f(param)，编译器将对隐式参数超类的方法表进行搜索。566
实际过程为：
1.虚拟机提取对象实际类型的方法表
2.虚拟机搜索方法签名，知道应该调用哪个方法。
3.虚拟机调用方法。
动态绑定有一个非常重要的特性，无须对现存的代码进行修改就可以对程序进行扩展。假设新增一个新类。并且变量e有可能引用这个类的对象，我们不需要对包含调用e.getSalary()的代码进行重新编译。如果e恰好引用一个Executive类的对象，就会自动调用Exective.getSalary（）方法。
注意：在覆盖一个方法时，子类方法不能低于超类方法的可见性。特别是，如果超类是public，子类方法一定要声明为public。经常会发生这类错误：在声明子类方法的时候，遗漏了public修饰符。此时，编译器会把它解释为试图提供更严格的访问权限。
阻止继承：final类和方法
有时候，可能希望阻止人们利用某个类定义子类。不允许扩展的类被称为final类。如果在定义类的时候使用了final修饰符就表明这个类是final类。
类中的特定方法也可以被声明为final。如果这样做，子类就不能覆盖这个方法。final类中的所有方法都将自动地成为final方法。域也可以被声明为final。对于final域来说，构造对象之后就不允许改变它们的值了。不过，如果将一个类声明为final，只有其中的方法自动地成为final，而不包括域。
将方法和类声明为final的主要目的是：确保它们不会在子类中改变语义。String类是final类，这意味着不允许任何人定义String的子类。换言之，如果由一个String的引用，它引用的一定是一个String对象，而不可能是其他类的对象。
在早期的Java中，有些程序员为了避免动态绑定带来的系统开销而使用final关键字，如果一个方法没有被覆盖而且很短，编译器就能够对它进行优化处理，这个过程称为内联。
虚拟机的即时编译器比传统编译器的处理能力强得多。这种编译器能明确知道类之间的继承关系，并且能够检测出类中是否真正地存在覆盖给定的方法。如果方法很简短、被频繁调用且没有真正地被覆盖，那么即时编译器就会将这个歌方法进行内联处理。（将动态绑定改为静态绑定）。如果虚拟机加载了另外一个子类，而在这个子类中包含了对内联方法的覆盖。那么优化器将取消对覆盖方法的内联。这个过程很慢，但却很少发生。
强制类型转换
进行类型转换的唯一原因是：暂时忽视对象的实际类型之后，使用对象的全部功能。
将一个值存入变量时，编译器将检查是否允许该操作。将一个子类的引用赋给一个超类变量，编译器是允许的。但将一个超类的引用赋给一个子类变量，必须进行类型转换，这样才能通过运行时的检查。
如果试图在继承链上进行向下的类型转换。在进行类型转换之前，先查看一些是否能够成功转换。
if (staff[1] instanceof Manager) { ... } 最后，如果这个类型转换不可能成功,编译器就不会进行进行这个转换。
String c=(String) staff[1]; 将会产生编译错误，这是因为String不是Empoyee的子类。
综上所述：
只能在继承层次内进行类型转换
在将超类转换成子类之前，应该使用instanceof进行检查。
如果x为null，那么进行下列测试
x instanceof c 不会产生异常，只是返回false。之所以这样处理是因为null没有引用任何对象，当然也不会引用C类型的对象。</description>
    </item>
    
    <item>
      <title>Java核心技术第四章笔记-对象和类</title>
      <link>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/</link>
      <pubDate>Wed, 05 May 2021 23:11:17 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/</guid>
      <description>面向对象
Java是完全面向对象的。面向对象的抽象是由对象组成的。
每个对象包含对用户公开的特定功能部分和隐藏的实现部分。程序中的很多对象来自标准库，还有一些是自定义的。
从根本上说，只要对象满足要求，就不必关心其功能的具体实现过程。在OOP中，不必关心对象的具体实现，只要满足用户的需求即可。
对于一些规模较小的问题，将其分解为过程开发比较理想。而面向对象更加适用于解决规模较大的问题。要想实现一个WEB浏览器大约需要2000个过程。这些过程可能需要对一些全局数据进行操作。采用面向对象的设计风格，可能大约100个类，每个类平均包含20个方法。后者更易于程序员掌握，也容易找到bug。假设给定对象的数据出错了，访问过这个数据项的20个方法中查找错误要比在2000个过程中查找容易得多。
类
类是构造对象的模板和蓝图。我们可以将类想象成制作小甜饼的切割机，将对象想象为小甜饼。由类构造对象的过程为创建类的实例。
用Java编写的所有代码都位于某个类的内部。标准的Java库提供了几千个类，可以用于用户界面设计、日期、日历和网络程序设计。尽管如此，还是需要在Java程序中创建一些自己的类，解决实际问题。
封装是与对象有关的一个重要概念。从形式上看，封装不过是将数据和行为组合在以恶个包中，并对对象的使用这隐藏了数据的实现方式。对象中的数据称为称为实例域，操纵数据的过程称为方法。每个特定的类实例都有一组特定的实例域值。这些值的集合就是这个对象的当前状态。无论合适，只要向对象发送一个消息，它的状态就有可能发生改变。
实现封装的关键在于绝对不能让类中的方法直接访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。封装给对象赋予了黑盒特征，这是提高重用性和可靠性的关键。
这意味着一个类可以全面地改变存储数据的方式，只要仍旧使用同样的方法操作数据，其他对象就不会知道或介意所发生的变化。
对象
要想使用OOP，一定要清楚对象的三个主要特性
 对象的行为——可以对对象施加哪些操作，或可以对对象施加哪些方法？ 对象的状态——当是加急那些方法时，对象如何响应？ 对象标识——如何辨别具有相同行为与状态的不同对象？  每个对象都保存着描述当前特征的信息。这就是对象的状态。对象的状态可能会随着时间而发生改变。但这种改变不会是自发的。对象状态的改变必须通过调用方法实现。如果不经过方法调用就可以改变对象状态，只能说明封装性遭到了破坏。
但是，对象的状态并不能完全描述一个对象。每个对象都有一个唯一的身份。
需要注意，作为一个类的实例，每个对象的标识永远是不同的，状态常常也存在着差异。
对象的这些关键特性在彼此之间相互影响着。例如，对象的状态影响它的行为（如果一个订单“已送货”或已付款，就应该拒绝调用而具有增删订单中条目的方法。反过来，如果订单是“空的”，即还没有加入预定的物品，这个订单就不应该进入已送货状态）
识别类
识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。
类之间的关系
 依赖——如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类 聚合——聚合关系意味着类A的对象包含类B的对象 继承——类A扩展类B，类A不但包含从类B继承的方法，还会有一些额外的功能。  对象与对象变量
要想使用对象，必须首先构造对象，并指定其初始状态。然后、对对象应用方法。
构造器是一种特殊的方法，用来构造并初始化对象。
构造器的名字应该与类名相同。因此Date类的构造器名为Date。
new Date（）
这个表达式构造了一个新对象。这个对象被初始化为当前的日期和时间
如果需要的话，也可以将这个对象传递给一个方法：
System.out.println(new Date()); Date类中有一个toString方法。这个方法将返回日期的字符串描述
String s =new Date().toString();一定要认识到：一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。
在Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个引用。
可以显式地将对象变量设置为null，表明这个对象变量目前没有引用任何对象。
局部变量不会自动地初始化为null，而必须通过调用new或将它们设置为null进行初始化
更改器方法与访问器方法
更改器方法是访问并修改对象的方法，与只访问对象而不修改对象的方法是访问器方法。
关键字public意味着任何类的任何方法都可以调用
关键字private确保只有类自身的方法能够访问
为了保证封装性，建议将实例域标记为private
构造器与类同名。在构造类的对象时，构造器会允许，以便将实例域初始化为所希望的状态。
构造器与其他方法有一个重要的不同。它总是伴随着new操作符的执行被调用。不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。
务必记住！
 构造器与类同名 每个类可以有一个以上的构造器 构造器可以有0个、1个或多个参数 构造器没有返回值 构造器总是伴随着new操作一起调用  注意，不要再构造器中定义与实例域重名的局部变量。如
public Employee(String n,double s,...){String name = n;// Errordouble salary =s;//Error}隐式参数与显式参数</description>
    </item>
    
    <item>
      <title>Java核心技术第三章笔记-Java的基本程序设计结构</title>
      <link>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0-java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/</link>
      <pubDate>Fri, 30 Apr 2021 22:08:43 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0-java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/</guid>
      <description>关键字class后面紧跟类名。Java中定义类名的规则很宽松。名字必须以字母开头，后面可以跟字母和数字的任意组合。长度基本上没有限制。但是不能使用Java保留字，例如（public和class）
命名规范
类名必须是以大写字母开头的名词。如果名字由多个单词组成，每个单词的第一个字母都应该大写，这种在一个单词中间使用大写字母的方式称为骆驼命名法。
源代码的文件名必须与公共类的名字相同，并用.java作为扩展名。
运行已编译的程序时，Java虚拟机将从指定类中的main方法开始执行。为了代码能够执行，在类的源文件中必须包含一个main方法。当然，也可以将用户自定义的方法加入到类中，并且在main方法中调用它们。
数据类型
在Java中一共由8中基本类型，其中有4种整型（int4\short2\byte1\long8）、两种浮点类型、1种用于表示Unicode编码的字符char和一种用于表示真值的boolean类型。
在Java种，整型的范围与运行Java代码的机器无关，由于Java程序必须保证在所有机器上都能够得到相同的运行结果，所以各种数据类型的取值范围必须固定。
长整型数值有一个后缀L或l，16进制数值有一个前缀0x或0X。八进制有一个前缀0。从Java7开始，加上前缀0b或者0B就可以些二进制数。还可为数字加入下划线，这些下划线只是为了让人更易读。Java编译器会取出这些下划线。如（1_000_000）
注意，Java中没有无符号（unsigned）类型的整型。
double表示这种类型的数值精度时float类型的两倍。绝大部分应用程序都采用double类型。在很多情况下，float类型的精度很难满足需求。实际上，只有很少的情况适合使用float类型，例如，需要单精度数据的库，或者需要存储大量数据。
float类型的数值有一个后缀的F或f。没有后缀的浮点数值默认为double类型。，当然也可以在浮点数值后面加D或者d。
下面是用于表示溢出和出错情况的三个特殊的浮点数值
正无穷大
负无穷大
NaN（不是一个数字）
例如，有个正整数除以0的结果为正无穷大。计算0/0或者附属的平方根结果为NaN。
浮点数值不适用于无法接受舍入误差的金融计算中，如果数值计算中不允许有任何舍入误差就应该使用BigDecimal类。
变量
变量必须以一个字母或者下划线或者$开头，不能以数字开头。变量名对大小写敏感。且不能使用关键字和保留字。
声明一个变量之后，必须用赋值语句对变量进行显式初始化，千万不要使用未初始化的变量。
在Java中可以将声明放在代码中的任何地方。
在Java中，变量的声明尽可能地靠近变量第一次使用的地方，这是一种良好的程序编写风格。在Java中不区分变量的声明和定义。
常量
关键字final指示常量，表示这个变量只能够被赋值一次。一旦被赋值之后，就不能够再更改了。习惯上，常量名使用全大写。
在Java中，经常希望某个常量可以在一个类的多个方法使用，通常将这些常量称为类常量。 可以使用关键字static final设置一个类常量。
需要注意，类常量的定义位于main方法的外部。因此，在同一个类的其他方法中也可以使用这个常量。而且，如果一个常量被声明为public，那么其他类的方法也可以使用这个常量。
在Java中，必须使用final定义常量。
strictfp关键字标记的方法或者类，则其内的计算必须使用严格的浮点计算。
数值类型转换的优先级是double\float\long\int
小数值向大数值转化不会有丢失。
强制类型转换
当数值转换出现丢失类型的适合，需要通过强制类型转换（cast）实现这个操作。
有时候，变量的取值只在一个有限的集合内。针对这种情况可以自定义枚举类型。枚举类型包括有限个命名的值
如：enum Size{SMALL,MEDIUM,LARGE,EXTRA_LARGE};
现在可以声明这种类型的变量
Size s =Size.MEDIUM
字符串
Java字符串其实就是Unicode字符序列。Java没有内置的字符串类型，而是在标准Java类库中提供了一个预定义类，很自然地叫做String。
每个用双引号括起来的字符串都是String类的一个实例。
字串
String类的subString方法可以从一个较大的字符串提取出一个字串
subString方法的第二个参数是不想复制的第一个位置。它的工作方式有一个优点：容易计算字串的长度。
拼接
Java允许使用+号连接两个字符串 。当将一个字符串与一个非字符串进行拼接时，后者被转换为字符串，任何一个Java对象都可以转换成字符串。
如果需要把多个字符串放在一起，用一个定界符分隔，可以使用join方法。
String all=String.join(&amp;quot;/&amp;quot;,&amp;quot;S&amp;quot;,&amp;quot;M&amp;quot;,&amp;quot;L&amp;quot;,&amp;quot;XL&amp;quot;);// 相当于字符串&amp;quot;S/M/L/XL&amp;quot;不可变字符
String类没有提供用于修改字符串的方法。由于不能修改Java中的字符，所以Java文档中将String类对象称为不可变字符串，当然可以修改字符串变量，让它引用另外一个字符串。
不可变字符串有一个优点：编译器可以让字符串共享。
可以将各种字符串存放在公共的存储池中。字符串变量指向存储池中相应的位置。如果复制一个字符串变量，原始字符串与复制的字符串共享相同的字符。
总而言之，Java设计者认为共享带来的高效率远远胜过提取、拼接字符串所带来的低效率
检测字符串是否相等
可以使用equals方法检测两个字符串是否相等。对于表达式：
s.equals(t)
如果字符串s和字符串t相等，则返回true，否则返回false。需要注意，s和t可以是字符串变量，也可以是字符串字面量。例如，下面的表达式是合法的：
&amp;ldquo;hello&amp;rdquo;.equals（greeting)
要想检测两个字符串是否相等，而不区分大小写，可以使用equalsIgnoreCase方法.
&amp;ldquo;Hello&amp;rdquo;.equalsIgnoreCase（&amp;ldquo;hello&amp;rdquo;）
一定不要使用==运算符检测两个字符串是否相等。这个运算符只能够确定两个字符串是否放置在同一个位置上。当然，如果字符串放置在同一个位置上，它们必然相等。但是完全有可能将内容相同的多个字符串拷贝放置在不同的位置上。
空串与Null串</description>
    </item>
    
    <item>
      <title>常见Dos命令总结</title>
      <link>https://zereals7.github.io/post/%E5%B8%B8%E8%A7%81dos%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 30 Apr 2021 18:50:46 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/%E5%B8%B8%E8%A7%81dos%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</guid>
      <description>常用的内部命令有MD、CD、RD、DIR、PATH、COPY、TYPE、EDIT、REN、DEL、CLS、VER、DATE、TIME、PROMPT。 常用的外部命令有DELTREE、FORMAT、DISKCOPY、LABEL、VOL、SYS、XCOPY、FC、ATTRIB、MEM、TREE。
切换到其他盘符D：
1．MD——建立子目录 功能：创建新的子目录 类型：内部命令ü 格式：MD[盘符：][路径名]〈子目录名〉 FOR 1： C:&amp;gt;md y /&amp;mdash;建立y子目录&amp;mdash;/
2．CD——改变当前目录 功能：显示当前目录ü 类型：内部命令ü 格式：CD[盘符：][路径名][子目录名] 说明：CD命令不能改变当前所在的盘，CD..退回到上一级目录，CD\表示返回到当前盘的目录下，CD无参数时显示当前目录名。 FOR 2： C:&amp;gt;cd y /&amp;mdash;显示当前目录y&amp;mdash;/
3．RD——删除子目录命令 功能：从指定的磁盘删除了目录。 类型：内部命令ü 格式：RD[盘符：][路径名][子目录名] FOR 3： C:&amp;gt;rd y
4．DIR——显示磁盘目录命令 功能：显示磁盘目录的内容。 类型：内部命令ü 格式：DIR [盘符][路径][/P][/W] FOR 4： C:&amp;gt;dir y
5．PATH——路径设置命令 功能：设备可执行文件的搜索路径，只对文件有效。 类型：内部命令ü 格式：PATH[盘符1]目录[路径名1]{[；盘符2：]，〈目录路径名2〉…} FOR 5： C:&amp;gt;path PATH=C:\WINDOWS;C:\WINDOWS\COMMAND;C:\PROGRAMFILES\MTS 6．COPY文件复制命令 ü 功能：拷贝一个或多个文件到指定盘上。 类型：内部命令ü 格式：COPYü [源盘][路径]〈源文件名〉[目标盘][路径][目标文件名] FOR 6_1： C:&amp;gt;copy yyy.txt yyy 1 file(s) copied C:\yyy&amp;gt;dir yyy YYY TXT 8 11-23-03 19:21 /&amp;mdash;现在用DIR命令查看复制的情况&amp;mdash;/ 说明： 如果是将多个文件复制到一个新的文件，命令是这样的COPY [源盘][路径]〈源文件A〉+[源盘][路径]〈源文件B〉[目标盘][路径][目标文件名] FOR 6_2： C:&amp;gt;copy x.</description>
    </item>
    
    <item>
      <title>Java核心技术第一章笔记-概述</title>
      <link>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0-%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Fri, 30 Apr 2021 18:28:02 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0-%E6%A6%82%E8%BF%B0/</guid>
      <description>Java并不只是一种语言。它是一个完整的平台，有一个庞大的库，其中包含很多可重用的代码和一个诸如安全性、跨操作系统的可移植性以及自动垃圾收集等服务的执行环境。Java是一种功能齐全的出色语言，是一个高质量的执行环境，还提供一个庞大的库。
Java的11个关键词
 简单性 面向对象 分布式 健壮性 安全性 体系结构中立 可移植性 解释型 高性能 多线程 动态性   1.简单性
Java是C++的一个纯净版本。这里没有头文件、指针运算、结构、联合、操作符重载、虚基类等。然而设计者并没有试图清除c++中所有不适当的特性。例如switch语句的语法在Java中就没有改变。
简单的另一方面是小。Java的目标之一是支持开发能够在小型机器上独立运行的软件。基本的解释器以及类支持大约仅为40KB；再加上基础的标准类库和对线程的支持（基本上是一个自包含的微内核）大约需要增加175KB。
在当时，这是一个了不起的成就。当然，由于不断的扩展，类库已经相当庞大了。还有一个独立的具有较小类库的Java微型版JME，这个版本适用于嵌入式设备。
2.面向对象
简单地讲，面向对象设计是一种程序设计技术。它将重点放在数据（即对象）和对象的接口上。开发Java时面向对象技术已经相当成熟。Java的面向对象特性与C++旗鼓相当。Java与C++的主要不同点在于多重继承，在Java中，取而代之是更简单的接口概念。与C++相比，Java提供了更丰富的运行时自省概念。
3.分布式
Java有一个丰富的例程库，用于处理像HTTP和FTP之类的TCP/IP协议。Java应用能够通过URL打开和访问网络上的对象，其便捷程度就好像访问本地文件一样。
4.健壮性
Java投入了大量的精力进行早期的问题检测、后期动态的（运行时）检测，并消除了容易出错的情况·······Java和C++最大的不同在于Java采用的指针模型可以消除重写内存和损坏数据的可能性。
Java编译器能够检测许多在其他语言仅在运行时才能够检测出来的问题。至于第二点，对于曾经花费几个小时来检查由于指针BUG而引起内存冲突的人来说，一定很喜欢Java的这一特性。
5.安全性
Java适用于网络/分布式环境。为了达到这个目标，在安全方面投入了很大精力。使用Java可以构建防病毒、防篡改的系统。
从一开始，Java就设计成能够防范各种攻击，其中包括：
 运行时堆栈溢出。如蠕虫和病毒常用攻击手段。 破坏自己的进程空间之外的内存。 未经授权读写文件  遭遇多次高调攻击之后。浏览器开发商和oracle都越来越谨慎。Java浏览器插件不再信任远程代码、除非代码有数字签名而且用户同意执行这个代码。
6.体系结构中立
编译器生成一个体系结构中立的目标文件格式，这是一种编译过的代码，只要有Java运行时系统，这些编译后的代码可以在许多处理器上运行。Java编译器通过生成与特定的计算机体系结构无关的字节码指令来实现这一特性。精心编写的字节码不仅可以很容易在任何机器上解释执行，而且还可以动态地翻译成本地机器代码。
当时，为虚拟机生成代码并不是一个新思路。诸如Lisp、Smalltalk和Pascal等编程语言多年前就已经采用了这种技术。
当然解释虚拟机指令肯定会比全速运行机器指令慢很多。然而，虚拟机有一个选项，可以将执行最频繁的字节码序列翻译成机器码，这一过程称为即时编译。
Java虚拟机还有一些其他的有点。它可以检测指令序列的行为，从而增强其安全性。
7.可移植性
Java是一种强类型语言。数据类型具有固定的大小，而与编译器无关，如int永远为32位的。这消除了代码移植时令人头痛的主要问题。二进制数据以固定的格式进行存储和传输、消除了字节顺序的困扰。字符串是用标准的Unicode格式存储的。
作为系统组成部分的类库，定义了可移植的接口。例如，有一个抽象的Window类，并给出了在UNIX、Windows和Macintosh环境下的不同实现。
除了与用户界面有关的部分外，所有其他Java库都能很好的支持平台独立性。你可以处理文件、正则表达式、XML、日期和时间、数据库、网络连接、线程等，而不用操心底层操作系统。不仅程序是可移植的，JavaAPI往往也比原生API质量更高。
8.解释型
Java解释器可以在任何移植了解释器的机器上执行Java字节码。由于链接是一个增量式且轻量级的过程。所以，开发过程也变得更加快捷，更加具有探索性。
9.高性能
字节码可以在运行时动态的翻译成对应运行这个应用的特定CPU的机器码。
现在的即时编译器已经非常出色，以至于成了传统编译器的竞争对手。在某些情况下，甚至超越了传统编译器，原因是它们含有更多的可用信息。例如，即时编译器可以监控经常执行哪些代码并优化这些代码以提高速度。更为复杂的优化是消除函数调用（即“内联”）。即时编译器知道哪些类已经加载。基于当前加载的类集，如果特定的函数不会被覆盖，就可以使用内联。必要时，还可与撤销优化。
10.多线程
多线程可以带来更好的交互响应和实时行为。
11.动态性
从各种角度看，Java与C或C++相比更加具有动态性。它能够适应不断发展的环境。库中可以自由地添加新方法和实例变量，而对客户端却没有任何影响。在Java中找出运行时类型信息十分简单。
2.关于Java的常见误解 1.Java是HTML的扩展
Java是一种程序设计原因；HTML是一种描述网页结构的方式。除了用于在网页上放置Java applet的HTML扩展之外，两者没有仍和共同之处。
2.使用XML，所有不需要Java
Java是一种程序设计语言；XML是一种描述数据的方式。可以使用任何一种程序设计语言处理XML数据，而Java API对XML处理提供了很好的支持。
3.Java是一种非常容易学习的程序设计语言
像Java这种功能强大的语言大豆不太容易学习。首先，必须将编写玩具式程序的轻松和开发实际项目的艰难区分开来。Java类库包含了数千种类和接口以及数万个函数。虽然不需要知道全部，但是要想Java解决实际问题，还是需要了解不少内容的。
4.Java将成为适用于所有平台的通用性编程语言
从理论上讲，这是完全可能的。但是实际上某些领域其他语言有更出色的表现，比如Swift在IOS设备有着无可取代的地位。浏览器的处理几乎完全由JavaScript掌控。Windows程序通常都用C++或C#编写。Java在服务器编程和跨平台客户端应用领域很有优势。</description>
    </item>
    
    <item>
      <title>SSM第七章-MyBatis的解析和运行原理</title>
      <link>https://zereals7.github.io/post/ssm%E7%AC%AC%E4%B8%83%E7%AB%A0-mybatis%E7%9A%84%E8%A7%A3%E6%9E%90%E5%92%8C%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</link>
      <pubDate>Fri, 30 Apr 2021 17:12:32 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/ssm%E7%AC%AC%E4%B8%83%E7%AB%A0-mybatis%E7%9A%84%E8%A7%A3%E6%9E%90%E5%92%8C%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</guid>
      <description></description>
    </item>
    
    <item>
      <title>SSM第六章-动态SQL</title>
      <link>https://zereals7.github.io/post/ssm%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%8A%A8%E6%80%81sql/</link>
      <pubDate>Thu, 29 Apr 2021 15:06:05 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/ssm%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%8A%A8%E6%80%81sql/</guid>
      <description>if元素 if元素是最常用的判断语句，相当于Java中的if语句，常常与test属性联合使用。
&amp;lt;select id=&amp;#34;findRoles&amp;#34; parameterType=&amp;#34;String&amp;#34; resultMap=”roleResultMap&amp;#34;&amp;gt; select role_no,role_name,note from t_role where 1=1 &amp;lt;if test=&amp;#34;roleName !=null and roleName !=&amp;#39;&amp;#39;&amp;#34;&amp;gt; and role_name like concat(&amp;#39;%&amp;#39;,#{roleName},&amp;#39;%&amp;#39;)\ &amp;lt;/if&amp;gt; &amp;lt;/select&amp;gt; 当参数roleName传递进映射器时，如果参数不为空，则采取构造对roleName的模糊查询，否则就不要去构造这个条件。显然这样的场景在实际工作中十分常见，通过MyBatis的if元素节省了许多拼接SQL的工作，集中在XML里面维护。
choose ,when,otherwise元素 上面的if语句，不是这个就是哪个。有时候还需要第三种选择，甚至更多选择，也就是需要类似switch&amp;hellip;case&amp;hellip;default&amp;hellip;功能的语句。在映射器的动态语句中choose\when\otherwise这三个元素承担了这个给功能。假设这样一个场景
 如果角色编号不为空，则只用角色编号作为条件查询 当角色编号为空，而角色名称不为空，则用角色名称作为条件进行模糊查询 当角色编号和角色名称都为空，则要求角色备注不为空  这个场景也许有点不切实际，但是没关系，这里主要集中于如何使用动态元素来实现它。使用这3个元素，这样MyBatis就会更具参数的设置进行判断来组装SQL，以满足不同的业务要求。远比Hibernate和JDBC等需要大量判断Java代码，要清晰和明确得多，进而提高程序的可读性和可维护性。
&amp;lt;select id=&amp;#34;findRoles&amp;#34; parameterType=&amp;#34;role&amp;#34; resultMap=”roleResultMap&amp;#34;&amp;gt; select role_no,role_name,note from t_role where 1=1 &amp;lt;choose&amp;gt; &amp;lt;when test=&amp;#34;roleNo!=null and roleNo !=&amp;#39;&amp;#39;&amp;#34;&amp;#34;&amp;gt; AND role_no =#{roleNo} &amp;lt;/when&amp;gt; &amp;lt;when test=&amp;#34;roleName !=null and roleName !=&amp;#39;&amp;#39;&amp;#34;&amp;gt; AND role_name like concat(&amp;#39;%&amp;#39;,#{roleName},&amp;#39;%&amp;#39;)\ &amp;lt;/when&amp;gt; &amp;lt;otherwise&amp;gt; AND note is not null &amp;lt;/otherwise&amp;gt; &amp;lt;/select&amp;gt; trim、where、set元素 上面代码SQL语句上的动态元素的SQL中都加入了一个条件“1=1”，如果没有加入这个条件，就可能如下面的错误</description>
    </item>
    
    <item>
      <title>SSM第五章-映射器</title>
      <link>https://zereals7.github.io/post/ssm%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%98%A0%E5%B0%84%E5%99%A8/</link>
      <pubDate>Thu, 22 Apr 2021 18:36:47 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/ssm%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%98%A0%E5%B0%84%E5%99%A8/</guid>
      <description>映射器是MyBatis最复杂且最重要的组件。它由一个接口加上XML文件（或者注解）组成。在映射器中可以配置参数、各类的SQL语句、存储过程、缓存、级联等复杂的内容，并且通过简易的映射规则映射到指定的POJO或者其他对象上，映射器能有效消除JDBC底层的代码。
在MyBatis应用程序开发中，映射器的开发工作量占全部工作量的80%。在MyBatis中映射器的配置顶级元素不多，但是里面的一些细节，比如缓存、级联、#和￥字符的替换参数、存储过程需要我们进一步学习。
MyBatis的映射器也可以使用注解完成，但是它在企业应用不广，原因主要来自3个方面：其一，面对复杂性，SQL会显得无力，尤其是长SQL。其二，注解的可读性比较差。其三，在功能上，注解丢失了XML上下文相互引用的功能。
5.1 概述 parameterMap是MyBatis官方不推荐的元素，可能即将被删除。
5.2 select元素——查询语句 在映射器中select元素代表SQL的select语句，用于查询。在SQL中，select语句是用得最多的语句，在MyBatis中select元素也是用得最多的元素，使用的多就意味着强大和复杂。
   元素 说明 备注     id 它和Mapper的命名空间组合起来是唯一的，供MyBatis调用 如果命名空间和id结合起来不唯一，MyBatis将抛出异常   parameterType 可以给出类的全命名，也可以给出别名，但是别名必须是MyBatis内部定义或者自定义的 ——   parameterMap 即将废弃的元素，不讨论 ——   resultType 定义类的全路径，在允许自动匹配的情况下，结果集将通过JavaBean的规范映射：或定义为int、double、float、map等参数；也可以使用别名，但必须要符合别名的命名规范，且不能和resultMap同时使用 常用的参数之一，比如统计总条数数时可以把它的值设置为int   resultMap 它是映射集的引用，将执行强大的映射功能，我们可以使用resultType和resultMap其中的一个，resultMap能提供自定义映射规则的机会。 是MyBatis最复杂的元素，可以配置映射规则、级联、typeHandler   flushCache 它的作用是在调用SQL后，是否要求MyBatis清空之前查询本地缓存和二级缓存 取值为布尔值，true/false.默认值为false   useCache 启动二级缓存的开关，是否要求MyBatsi将此次结果缓存 取值为布尔值，true/false.默认值为true   timeout 设置超时参数，超时将抛出异常，单位为秒 默认值是数据库厂商提供的JDBC驱动所设置的秒数   fetchSize 获取记录的总条数设定 默认值是数据库厂商提供的JDBC驱动所设置的条数   statementType 告诉Mybatis使用哪个JDBC的Statement工作，取值为STATEMENT、PREPARED、CALLABLE 默认值为PREPARED   resultSetType 这是对JDBC的resultSet接口而言，它的值包括FORWARD_ONLY（游标允许向前访问）、SCROLL_SENSITIVE（双向滚动，但不及时更新，就是如果数据库里的数据修改过，并不再resultSet中反映出来）、SCROLL_INSENSITIVE（双向滚动，并及时跟踪数据库的更新，以便更改resultSet中的数据） 默认值是数据库厂商提供的JDBC驱动所设置的   databaseId 配置使用 提供多种数据库的支持   resultOrdered 这个设置仅适用于嵌套结果select语句，如果为true，就是假设包含了嵌套结果集或是分组了，当返回一个主结果行是，就不能引用前面结果集了。这就确保了在获取嵌套的结果集时不至于导致内存不够用。 取值为布尔值，true/false。默认值为false   resultSets 适用于多个结果集的情况，它将列出执行SQL后每个结果集的名称，每个名称之间用逗号分隔 很少使用    在实际工作中用得最多的是id、parameterType、resultType、resultMap，如果要设置缓存，还会使用到flushCache、useCache，其他的都是不常用的功能。这里主要讨论id、parameterType、resultType、resultMap及它们的映射规则。</description>
    </item>
    
    <item>
      <title>SSM第四章-MyBatis配置</title>
      <link>https://zereals7.github.io/post/ssm%E7%AC%AC%E5%9B%9B%E7%AB%A0-mybatis%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 19 Apr 2021 01:38:36 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/ssm%E7%AC%AC%E5%9B%9B%E7%AB%A0-mybatis%E9%85%8D%E7%BD%AE/</guid>
      <description>4.1 概述 MyBatis配置文件不复杂
配置文件元素
&amp;lt;configuration&amp;gt;配置&amp;lt;properties/&amp;gt;属性&amp;lt;setting/s&amp;gt;设置&amp;lt;typeAliases/&amp;gt;类型别名&amp;lt;typeHandlers/&amp;gt;类型处理器&amp;lt;objectFactory/&amp;gt;对象工厂&amp;lt;plugins&amp;gt;插件&amp;lt;environments&amp;gt;配置环境&amp;lt;environment&amp;gt;环境变量&amp;lt;transactionManager&amp;gt;事务管理器&amp;lt;dataSource&amp;gt;数据源&amp;lt;/environment&amp;gt;&amp;lt;/environments&amp;gt;&amp;lt;databaseIdProvider/&amp;gt;数据库厂商标识&amp;lt;mappers&amp;gt;映射器&amp;lt;/configuration&amp;gt;需要注意配置的顺序不能颠倒。顺序错了，启动阶段就会发生异常，导致程序无法运行。
4.2 properties属性 properties属性可以给系统配置一些运行参数，可以放在XML文件或者 properties文件中，而不是放在Java编码中，这样的好处在于方便参数修改，不会引起代码重新编译。
可以使用元素 properties下的 propertie子元素定义。比如通过
,可以定义数据库的驱动，然后可以通过${database.driver},定义一次，到处引用。如果属性参数有成百上千个，可以使用properties文件。
使用properties文件是比较普遍的方法，一方面这个文件十分简单，其逻辑就是键值对应，我们可以配置多个键值放在一个properties文件中，也可以把多个键值对放在多个properties文件中，这些都是允许的，它方便日后维护和修改。
在MyBatis中通过properties的属性resource来引入properties文件。
&amp;lt;properties resource=&amp;#34;jdbc.properties&amp;#34;/&amp;gt; 也可以按${database.username}的方法引入properties文件的属性参数到MyBatis配置文件中。这个时候通过维护properties文件就可以维护我们的配置内容了。
在真实的生产环境中，数据库的用户密码是对开发人员和其他人员保密的。运维人员为了保密，一般都需要把用户和密码经过加密成为密文后，配置到properties文件中。对于开发人员及其他人员而言，就不知道其真实的用户密码了，数据库也不可能用以及加密的字符串去连接，此时往往需要通过解密才能得到真实的用户和密码了。现在假设系统已经为提供了这样的一个CodeUtils.decode(str)进行解密，那么我们在创建SqlSessionFactory前，就需要把用户名和密码解密，然后把解密后的字符串重置到properties属性中。
首先使用Resources对象读取了一个jdbc.properties配置文件，然后获取了它原来配置的用户和密码，进行解密并重置，最后使用SqlSessionFactoryBuilder的build方法，传递多个properties参数来完成。这将覆盖之前配置的密文，这样就能连接数据库了，同时也满足了运维人员对数据库用户和密码安全的要求。
总结：以上是MyBatis使用properties的3种方式。这3种方式是有优先级的，最优先的是使用程序传递的方式，其次是使用properties文件的方式，最后使用子元素的方式。MyBatis会根据优先级来覆盖原先配置的属性值。
建议采用properties文件的方式，因为管理它简单易行，而且可以从XML文件中剥离出来独立维护。
4.3 settings设置 settings是MyBatis中最复杂的配置，它能深刻影响MyBatis底层的运行，但大部分情况下使用默认值便可以运行，所以大部分情况下不需要大量配置它，只需要修改一些常用的规则即可，比如自动映射、驼峰命名映射、级联规则、是否启动缓存、执行器类型等。
settings的配置项很多，但是真正用到的不会太多，我们把常用的配置项研究清楚就可以了，比如关于缓存的CacheEnabled,关于级联的LazyloadingEnabled和aggressiveLazyLoading,关于自动映射的autoMappingBehavior和mapUnderscoreToCamelCase,关于执行器类型的defaultExecutorType等。
4.4 typeAliases别名 由于类的全限定名很长，需要大量使用的时候，写那么长的名称不方便。在MyBatis中允许定义一个简写来代表这个类，这就是别名，别名分为系统定义别名和自定义别名。在MyBatis中别名由类TypeAliasRegistry去定义。注意，在MyBatis中别名不区分大小写。
MyBatis也提供了用户自定义别名的规则。我们可以通过TypeAliasRegistry类的registerAlias方法注册，也可以采用配置文件或者扫描方式来自定义它。
使用配置文件定义很简单：
&amp;lt;typeAliases&amp;gt; &amp;lt;typeAliases alias=&amp;#34;role&amp;#34; type=&amp;#34;com.leartn.ssmchapter4.pojo.Role&amp;#34;/&amp;gt; &amp;lt;typeAliases alias=&amp;#34;user&amp;#34; type=&amp;#34;com.learn.ssm.chapter4.pojo.User&amp;#34;/&amp;gt; &amp;lt;/typeAliases&amp;gt; 这样就可以定义一个别名了。如果由很多类需要定义别名，那么用这样的方式进行配置可就不那么轻松了。MyBatis还支持扫描别名。比如上面的两个类都在包com.learn.ssm.chapter4.pojo之下，那么就可以定义为：
&amp;lt;typeAliases&amp;gt; &amp;lt;package name=&amp;#34;com.learn.ssm.chapter4.pojo&amp;#34;/&amp;gt; &amp;lt;typeAliases&amp;gt; 这样MyBatis将扫描这个包里面的类，将其第一个字母变为小写作为其别名，比如类Role的别名会变成role，而User的别名会变成user。使用这样的规则有时候会出现重名，这个时候可以使用MyBatis提供的直接@Alias来进行区分。
这样就能够避免因为别名重名导致的扫描失败的问题。
4.5 typeHandler类型转换器 在JDBC中，需要在PreparedStatement对象中设置那些已经预编译过的SQL语句的参数。执行SQL后，会通过ResultSet对象获取得到数据库的数据，而这些MyBatis是根据数据的类型typeHandler来实现的。在typeHandler中，分为jdbcType和javaType,其中jdbcType用于定义数据库类型，而javaType用于定义Java类型，那么typeHandler的作用就是承担jdbcType和iavaType之间的相互转换。在很多情况下我们并不需要去配置typeHandler、jdbcType、javaType,因为MyBatis会探测应该使用什么类型的typeHandler进行处理，但是有些场景无法探测到。对于那些需要使用自定义枚举的场景，或者数据库使用特殊数据类型的场景，可以使用自定义的typeHandler去处理类型之间的转换问题。
和别名一样，在MyBatis中存在系统定义typeHandler和自定义typeHandler。MyBatis会根据javaType和数据库的jdbcType来决定采用哪个typeHandler处理这些转换规则。系统提供的typeHandler能覆盖大部分场景的要求，但是有些情况下是不够的，比如我们由特殊的转换规则，枚举类就是这样。
总之，typeHandler负责jdbcType和javaType之间的相互转换。
在大部分的情况下无须显式地声明jdbcType和javaType，或者用typeHandler去指定对应的typeHandler来实现数据类型转换，因为MyBatis系统会自己探测。有时候需要修改一些转换规则，比如枚举类往往需要自己去编写规则。
typeHandler继承了BaseTypeHandler
 BaseTypeHandler是个抽象类，需要子类去实现其定义的4个抽象方法，而它本身实现类typeHandler接口的4个方法。 getResult方法，非空结果集是通过getNullableResult方法获取的。如果判断为空，则返回null。 setParameter方法，当参数parameter和jdbcType同时为空时，MyBatis将抛出异常，如果能明确jdbcType,则会进行空设置；如果参数不为空，那么它将采用setNonNullParameter方法设置参数。 getNullableResult方法用于存储过程。  MyBatis使用最多的typeHandler之一——StringTypeHandler。它用于字符串转换。它实现类BaseTypeHandler的4个抽象方法。</description>
    </item>
    
    <item>
      <title>SSM第三章-MyBatis核心组件</title>
      <link>https://zereals7.github.io/post/mybatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Fri, 16 Apr 2021 21:47:55 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/mybatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</guid>
      <description>3.1 持久层的概念和MyBatis的特点 持久层可以将业务数据存储到磁盘，具备长期存储能力，只要磁盘不损坏，在断电或者其他情况下，重新开启系统仍然可以读取这些数据。一般执行持久任务的都是数据库系统，持久层可以使用巨大的磁盘空间，也比较廉价，缺点就是慢，当然慢是针对内存而言的，在一般系统中运行是不存在问题的，比如内部管理系统，但是在互联网的秒杀场景下，每秒需要执行成千上万次数据操作，慢是不能承受的，极有可能导致宕机，在这样的场景下考虑使用Redis处理。
MyBatis最大的成功来自于三点
 不屏蔽SQL，意味着可以更为精确的定位SQL语句，可以对其进行优化和改造，这有利于互联网系统性能的提高，符合互联网需要性能优化的特点。 提供强大、灵活的映射机制，方便Java开发者使用。提供动态SQL的功能，允许我们根据不同条件组装SQL，这个功能远比其他工具或者Java编码的可读性和可维护性高得多，满足各种应用系统的同时也满足了需求经常变化的互联网应用的要求。 在MyBatis中，提供了使用Mapper的接口编程，只要一个接口和一个XML就能创建映射器，进一步简化我们的工作，使得很多框架API在MyBatis中消失，开发者更集中于业务逻辑。  3.2 准备MyBatis环境 网上复制相关依赖
3.3 MyBatis核心组件 MyBatis的核心组件分为4个部分
 SqlSessionFactoryBuilder(构造器)：它会根据配置或者代码来生成SqlSessionFactory,采用的是分布构建的Builder模式。 SqlSessionFactory（工厂接口）：依靠它来生成SqlSession，使用的是工厂模式。 SqlSession(会话)：一个既可以发送SQL执行返回结果，也可以获取Mapper的接口。在现有的技术中，我们会让其在业务逻辑代码中消失，而使用的是MyBatis提供的SQL Mapper接口编程技术，它能提高代码的可读性和可维护性。 SQL Mapper（映射器）：MyBatis新设计的组件存在的组件，它由一个Java接口和XML文件构成，需要给出对应的SQL和映射规则。它负责发送SQL去执行，并返回结果。  无论是映射器还是SqlSession都可以发送SQL到数据库执行。
3.4 SqlSessionFactory（工厂接口） 使用MyBatis首先是使用配置或者代码去生产SqlSessionFactory，而MyBatis提供了构造器SqlSessionFactoryBuilder。它提供了一个类org.apache.ibatis.session.Configuration作为引导，采用的是Builder模式。具体的分步是在Configuration类里面完成的。
在MyBatis中，可以通过读取皮质的XML文件的形式生成SqlSessionFactory，也可以通过Java代码的形式取生产SqlSessionFactory。推荐使用XML的形式，因为代码的方式在需要修改的时候会比较麻烦。当配置了XML或者提供代码后，MyBatis会读取配置文件，通过Configuration类对象构建整个MyBatis的上下文。SqlSessionFactory是一个接口，在MyBatis中存在两个实现类：SqlSessionManager和DefaultSqlSessionFactory,一般而言，具体是由DefaultSqlSessionFactory去实现的，而SqlSessionManager使用在多线程的环境中，它的具体实现依靠DefaultSqlSessionFactory。
每个基于MyBatis的应用都是以一个SqlSessionFacrory的实例为中心的，而SqlSessionFactory唯一的作用就是生产MyBatis的核心接口对象SqlSession,所以它的责任是唯一的。我们往往采用单例模式处理它，使用配置文件和Java代码两种形式去生成SqlSessionFactory的方法。
3.4.1 使用XML构建SqlSessionFactory 首先，在MyBatis中的XML分为两类，一类是基础配置文件，通常只有一个，主要是配置一些最基本的上下文参数和运行环境；另一类是映射文件，它可以配置映射关系，SQL、参数等信息。
基础配置文件：
元素定义了别名，可以代替全限定名。
元素的定义，这里描述的是数据库。它里面的元素是配置事务管理器，这里采用的是MyBatis的JDBC管理器方式。然后采用元素配置数据库，其中属性 type=“POOLED”代表采用MyBatis内部提供的连接池方式。
元素代表引入的那些映射器。
通过XML构建SqlSessionFactory
SqlSessionFactory SqlSessionFactory=null； String resource =&amp;#34;mybatis-config.xml&amp;#34;; InputStream inputStream; try{ inputStream =Resources.getResourceAsStream(resource); SqlSessionFactory= new SqlSessionFactoryBuilder().build(inputStream); }catch(IOException e){ e.printStarkTrace(); } 首先读取mybatis-config.xml,然后通过SqlSessionFactoryBuilder的Builder方法去创建SqlSessionFactory。整个过程比较简单，而里面的步骤还是比较烦琐的，只是MyBatis采用了Builder模式为开发者隐藏了这些细节。这样一个SqlSessionFactory就被创建出来了。
推荐采用XML创建的形式，信息在配置文件中，有利于我们日后的维护和修改，避免了重新编译代码。
3.4.2 使用代码创建SqlSessionFactory 代码冗长，如果发生系统修改，那么有可能需要重新编译代码才能继续，所以不是一个很好的方式。除非有特殊的需要，比如在配置文件中，需要配置加密过的数据库用户名和密码，需要我们在生产SqlSessionFactory前解密为明文的时候，才会考虑使用这样的方式。
3.5 SqlSession 在MyBatis中，SqlSession是其核心接口。在MyBatis中有两个实现类，DefaultSqlSession和SqlSessionManager。DefaultSqlSession是单线程使用的，而SqlSessionManager在多线程环境下使用。SqlSession的作用类似于一个JDBC中的Connection对象，代表着一个连接资源的启用。具体而言，有三个作用。
 获取Mapper接口 发送SQL给数据库 控制数据库事务  创建SqlSession
SqlSession sqlSession =SqlSessionFactory.</description>
    </item>
    
    <item>
      <title>SSM第二章-Java设计模式</title>
      <link>https://zereals7.github.io/post/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 15 Apr 2021 00:24:01 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>2.1 Java反射技术 Java反射技术应用广泛，它能够配置：类的全限定名、方法和参数，完成对象的初始化，甚至是反射某些方法。这样就可以大大增强Java的可配置性，Spring IOC的基本原理他也是如此，当然Spring IOC的代码要复杂得多。
2.1.1 通过反射构建对象 在Java中允许通过反射配置信息构建对象。
这里的代码就是生成一个对象，然后将其返回。下面这行代码的目的就是给类加载器注册了一个类对象，使用反射的方式也十分简单。
object=(ReflectServiceImpl)Class.forName(&amp;quot;com.learn.ssm.chapter2.reflect.ReflectServiceImpl&amp;quot;).newInstance();
这是一个构建方法，没有任何参数的类的反射生成，所以还剩下一个问题，即如果一个类的所有构建方法都至少存在一个参数，如何用反射构建它。其实，只要少排位改变就可以。
使用如下代码发生你和生成对象：
`object=(ReflectServiceImpl2)Class.forName(&amp;#34;com.learn.ssm.chapter2.reflect.ReflectServiceImpl2&amp;#34;).getConstructor(String.class).newInstance(&amp;#34;张三&amp;#34;)；` 先通过forName加载到类的加载器。然后通过getConstructor方法，它的参数可以是多个，这里定义为String.class，意为有且只有一个参数类型为String的方法。通过这个方法可以对重名方法进行排除，此时再用newInstance方法生成对象，只是newInstance方法也多了一个参数“张三&amp;quot;而已。实际就等于object=new ReflectServiceImpl2(&amp;ldquo;张三&amp;rdquo;)，只是这里用反射机制来生成这个对象而已。
反射的优点是只要配置就可以生成对象，可以接触程序的耦合度，比较灵活。反射的缺点是运行比较慢。但是大部分情况下为了灵活度，降低程序的耦合度，我们还是会使用反射的，比如Spring IOC容器。
2.1.2 反射方法 在使用反射方法前要获取方法对象，得到了方法才能去反射。
当有具体的对象target，而不知道具体是哪个类时，也可以使用getClass方法找到全限定类名
target.getClass().getMethod(&amp;#34;sayHello&amp;#34;,String.class); 代替它，其中第一个参数是方法名称，第二个参数是参数类型，是一个列表，多个参数可以继续编写多个类型，这样便能获得反射的方法对象。
反射方法是运用
returnObj=method.invoke(target,&amp;#34;张三&amp;#34;)； 代码完成的。
第一个参数为target，就是确定用哪个对象调用方法，而”张三“是参数，这行就等于target.sayhello(&amp;ldquo;张三&amp;rdquo;)；。
如果存在多个参数，可以写成Method.invoke(target，obj1,obj2,obj3&amp;hellip;..),这些要根据对象的具体方法来确定。
对象在反射机制生成后，反射了方法，我们完全可以通过配置完成对象和方法的反射，大大增强了Java的可配置性和可扩展性，其中Spring IOC就是一个典型的样例。
2.2 动态代理模式和责任链模式 动态代理的意义在于生成一个代理对象（占位），来代理真实对象，从而控制真实对象的访问。
代理模式举例：假设你的公司是一家软件公司，你是一位软件工程师。客户带着需求找公司不不会直接和你谈，而是找商务谈，此时客户会认为商务就代表公司。
显然客户是通过商务区访问软件工程师的，那么商务(代理对象)的意义是什么呢？商务可以进行谈判，比如项目启动前的商务谈判，软件的价格、交付、进度的事件节点等，或者项目完成后的商务追讨应收账款等。商务也有可能在开发软件之前谈判失败，此时商务就会根据公司规则去结束和客户的合作关系，这些都不用软件工程师来处理。因此，代理的作用就是，在真实对象访问之前或之后加入对应的逻辑，或者根据其他规则控制是否使用真实对象，显然这个例子里商务控制了客户对软件工程师的访问。
商务和软件工程师是代理和被代理的关系，客户是经过商务去访问软件工程师的。此时客户就是程序中的调用者，商务就是代理对象，软件工程师就是真实对象。我们需要在调用者调用对象之前产生一个代理对象，而这个代理对象需要和真实对象建立代理关系，所以代理必须分为两个步骤：
 代理对象和真实对象建立代理关系 实现代理对象的代理逻辑方法  在Java中有多种动态代理技术，比如JDK、CGLIB、Javassist、ASM，其中最常用的动态代理技术有两种：一种是JDK动态代理，这是JDK自带的功能；另一种是CGLIB,这是第三方提供的一个技术。目前，SPring 常用JDK和CGLIB，而MyBatis还使用了Javassist，无论使用哪种代理其技术，理念相似。
在JDK动态代理中，我们必须使用接口，而CGLIB不需要，所以使用CGLIB会更简单一些。
AOP的实现方式：动态代理。与静态代理对比，动态代理是在runtime动态生成Java代理类，由代理类完成对具体方法的封装，实现AOP的功能。
2.2.1 JDK动态代理 JDK动态代理是java.lang.reflect.*包提供的方式，它必须借助一个接口才能产生代理对象，所以先定义接口。
然后提供实现类来实现接口。有了接口和实现类，此时可以开始动态代理了。按照我们之前的分析，先要建立起代理对象和真实服务对象的关系，然后实现代理逻辑，所以一共 分为两个步骤。
在JDK动态代理中，要实现代理逻辑类必须去实现java.lang.reflect.InvocationHandler接口，它里面定义了一个invoke方法,并提供接口数组用于下挂代理对象。
***第一步，建立代理对象和真实对象的关系。***这里是使用了bind方法去完成的，方法里面首先用类的属性target保存了真实对象，然后 通过如下代码建立并生成代理对象。
其中newProxyInstance方法包含3个参数
第一个是类加载器，我们采用了target本身的类加载器。
第二个是把生成的动态代理对象下挂在哪些接口下，这个写法就是放在target实现的接口下。
第三个是定义实现方法逻辑的代理类，this表示当前对象，它必须实现InvocationHandler接口的invoke方法，它就是代理逻辑方法的现实方法。
​
***第二步，实现代理逻辑方法。***invoke方法可以实现代理逻辑，invoke方法的三个参数如下：
 Proxy,代理对象，就是bind方法生成的对象。 method，当前调度的方法。 args，调度方法的参数。  当我们使用了代理对象调度方法后，它就会进入到invoke方法里面。
Object obj =method.invoke(target,args); 这行代码相当于调度真实对象的方法，只是通过反射实现而已。
类比之前的例子，proxy相当于商务对象，target相当于软件工程师对象，bind方法是建立商务和软件工程师代理关系的方法。而invoke就是商务逻辑，它将控制软件工程师的访问。
测试JDK动态代理</description>
    </item>
    
    <item>
      <title>SSM第一章-入门和Redis</title>
      <link>https://zereals7.github.io/post/ssm/</link>
      <pubDate>Wed, 14 Apr 2021 21:56:15 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/ssm/</guid>
      <description>1.1 Spring框架 1.1.1 Spring IOC简介 IOC是一个容器，在Spring中，它会认为一切Java资源都是Java Bean,容器的目标就是管理这些Bean和它们之间的关系。
各个Java Bean之间会存在一定的依赖关系，容器能够对其进行管理。SPringIOC管理对象和依赖关系，采用的不是认为主动创建，而是SPring IOC自己通过描述创建的。
当需要某个实现类，可以通过配置实现依赖的注入 。这是一种被动的行为，控制权在IOC容器，它会根据描述找到使用者需要的资源。
当需要使用某个实现类时，通过配置信息就可以完成了。不需要用new来创建对象，依赖关系也可以通过配置完成，从而即插即拔地管理它们之间的关系。
总结：你不需要去找资源，只要向SPring IOC容器描述所需资源，SPring IOC自己会找到你需要的资源，这就是SPring IOC的理念。这样就把Bean之间的依赖关系解耦了，更容易写出结构清晰的程序。除此之外，SPring IOC还提供对Java Bean生命周期的管理，可以延迟加载，可以在其生命周期内定义一些行为等，更加方便有效地使用和管理Java资源，这就是SPring IOC的魅力。
1.1.2 SPring AOP IOC的目标时为了管理Java Bean,而Bean是Java面向对象的基础设计。但是，有些情况面向对象没办法处理。举个例子，生产部门的订单、生产部门、财务部门三者符合OOP的设计理念。订单发出，生产部门审批通过准备付款，但是财务部门发现订单的价格超支了，需要取消当你孤单。显然超支限定已经不只是影响财务部门了，还会影响生产部门之前所做的审批，需要把它们作废。我们把预算超支这个条件称为切面，它影响了订单、生产部门、财务部门三个OOP对象。在现实中，这样的切面条件跨越了3个甚至更多的对象，并且影响了它们的协作。所以只用OOP并不完善，还需要面向切面的编程，通过它去管理在切面上的某些对象的协作。
Spring AOP常用于数据库事务的编程，在默认的情况下，只要Spring接收到了异常信息，它会将数据库的事务回滚，从而保证数据的一致性。Spring提供了隔离级别和传播行为去控制复杂的事务。
1.2 MyBatis简介 MyBatis优势在于灵活，他几乎可以代替JDBC，同时提供了接口编程。目前MyBatis的数据访问层DAO是不需要实现类的，只需要一个接口和XML，或是注解。MyBatis提供自动映射，动态SQL、级联、缓存、注解、代码和SQL分离等特性。同时也可以对SQL进行优化。一位内具有封装少、映射多样化、支持存储过程、可以进行SQL优化等特点。
1.2.1 Hibernate简介 在MyBatis或者HIberNate中使用注解或者XML都是可以的。MyBatis中注解方式会受到一定的限制，所以MyBatis通常用XML方式实现映射关系。
我们把POJO对象和数据表相互映射的框架称为对象关系映射ORM。MyBatis和HIbernate都是ORM框架，只是Hibernate完全面向POJO，而前者不是。Hibernate基本不需要编写SQL就可以通过映射关系来操作数据库，是一种全表映射，而MyBatis不同，需要提供SQL去运行。
没有SQL是因为Hibernate会根据映射关系来生成对应的SQL。
1.2.2 Mybatis 在移动互联网时代，Mybatis是互联网Java持久框架的首选，与HIbernate消除SQL不同，MyBatis不屏蔽SQL。不屏蔽SQL的优势在于，程序员可以自己制定SQL规则，无须HIbernate自动生成规则，这样能够更加精确地定义SQL，从而优化性能。它更符合移动互联网、大数据、高并发、高性能、高响应的要求。
与HIbernate一样，MyBatis需要一个映射文件把POJO和数据库的表对应起来。
resultMap元素用于定义映射规则，Mybatis在满足一定规则下，完成自动映射。
mapper元素中的namespace属性，要和一个接口的全限定类名保持一致。里面的SQL的id也要和接口定义的方法保持完全一致。
定义了MyBatis的映射文件，就不再需要定义一个实现类。
Mybatis需要提供接口和SQL，意味着它的工作量会比HIbernate大，但是由于自定义SQL、映射关系，所以其灵活性、可优化性就超过了HIbernate。
1.2.3 HIbernate和MyBatis的区别 两者的增删查改对于业务逻辑层来说大同小异，对于映射层而言HIbernate的配置不需要接口和SQL，相反MyBatis是需要的。对于HIbernate而言，不需要编写大量的SQL就可以完全映射，同时提供了日志、缓存、级联等特性（级联比Mybatis强大）等特性，此外还提供了HQL对POJO操作，使用十分方便，但也有致命的缺陷。
由于无须SQL，当多表关联超过3个的时候，通过HIbernate的级联会造成太多的性能丢失，又或者我现在访问财务的表，然后它会关联财产信息表，财产又分为机械、原料等，显然机械和原料的字段不一样，这样关联的字段只能根据特定的条件变化而变化，而HIbernate无法支持这样的变化。遇到存储过程HIbernate只能作罢。
Mybatis可以自由书写SQL、支持动态SQL、处理列表、动态生成表名、支持存储过程。这样可以灵活定义查询语句，满足各类需求和性能优化的需要，这些在互联网系统中十分重要.
Mybatis也有缺陷。首先，要编写SQL和映射规则，其工作量稍微大于HIbernate。其次，支持的工具有限，不能像HIbernate那样有许多的插件可以帮助生成映射代码和关联关系，而即使使用生成工具，往往也需要开发者进一步简化，Mybatis通过手工编码，工作量相对大些。
所以对于性能要求不太苛刻的系统，比如管理系统、ERP等推荐HIbernate；而对于性能要求高、响应快、灵活的系统则推荐使用Mybatis。
1.3 Spring MVC简介 SPring MVC结构层次清晰，类比较简单，并且与SPring的核心IOC和AOP无缝对接。
MVC模式把应用程序分成不同的方面，同时提供这些元素的松耦合。
Model，封装了应用程序的数据和由它们组成的POJO
View，负责把模型数据渲染到视图上，将数据以一定的形式展现给用户。
Controller，负责处理用户请求，并建立适当的模型把它传递给试图渲染。
在SpringMVC中可以定义逻辑视图，通过其提供的试图解析器能够很方便地找到对应的视图进行渲染，或者使用其消息转换的功能，比如在Controller的方法内加入注解@ResponseBody后，SPring MVC就可以通过其消息转换系统，将数据转换为JSON，提供给前端Ajax请求使用。
SpriingMVC包括控制器、视图解析器、视图等重要内容。
1.4 最流行的NoSQL-Redis Redis是当前互联网最为流行的NoSQL。NoSQL在互联网系统中的作用很大，因为它可以在很大程度上提高互联网系统的性能。它具备一定持久层的功能，也可以作为一种缓存工具。对于NOSQL数据库而言，作为持久层，它存储的是半结构化的，这意味着计算机在读入内存中有更少的规则，读入速度更快。对于那些结构化、多范式规则的数据库系统而言，它更具性能优势。作为缓存，它可以支持大数据存入内存中，只要命中率高，就能快速响应，因为在内存中的数据读写比数据库读写磁盘的速度快几十上百倍。
Redis具有以下特点：
1、响应快速：Redis响应非常快，每秒课执行大约110000个写入操作，或者81000个读操作，其速度远超数据库。如果存入一些常用的数据，就能有效提高系统的性能。
2、支持6种数据结构：包括字符串、哈希结构、列表、集合、可排序集合和基数。比如对于字符串可以存入一些Java基础数据类型，哈希可以存储对象，列表可以存储List对象等。这使得在应用中很容易根据在自己的需要选择存储的数据类型，方便开发。既可以满足存储各种数据结构体的需要，又因为数据类型少，使得规则就少，需要的判断和裸机就少，这样读写速度就更快。
3、操作都是原子的：所有Redis的操作都是原子的，从而确保当两个客户同时访问Redis服务器时，得到的是更新后的值。在需要高并发的场合可以考虑使用Redis的事务，处理一些需要锁的事务。
4、MultiUtility工具：Redis可以在如缓存、消息传递队列中使用（支持“发布+订阅”的消息模式），在应用程序如Web应用程序会话、网站页面点击数等任何短暂的数据中使用。</description>
    </item>
    
    <item>
      <title>操作系统-进程与线程</title>
      <link>https://zereals7.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Sat, 10 Apr 2021 12:05:23 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</guid>
      <description>计算机上所有可运行的软件，通常也包括操作系统，被组织成若干顺序进程，简称进程。一个进程就是一个正在执行程序的实例，包括程序计数器，寄存器和变量的当前值。
从概念上来说，每个进程有自己的虚拟CPU。实际上真正的CPU在各进程间来回切换。
1、进程的创建 操作系统需要有一种方式来创建进程。
4种主要事件导致进程的创建：1、系统初始化 2、正在运行的程序执行了创建进程的系统调用 3、用户请求创建一个新进程 4、一个批处理作业的初始化
启动操作系统时，有些是前台进程，也就是与用户交互并且替他们完成工作的那些进程。其他的是后台进程，这些进程与特定的用户没有关系，却具有某些专门的功能。在大型系统中通常有很多守护进程，他们停留在后台，在请求到达时被唤醒。
从技术上看，新进程都是由于一个已存在的进程执行了一个用于创建进程的系统调用而创建的。这个进程可以是一个运行的用户进程、一个由键盘或鼠标启动的系统或者一个批处理管理进程。这个进程所做的工作是，执行一个用来创建新进程的系统调用。这个系统调用通知操作系统创建一个新进程，并且直接或间接地指定该进程中运行的程序。
UNIX系统中，只有一个系统调用可以用来创建新进程：fork。这个系统调用会创建一个与调用进程相同的副本。在调用了fork后，父进程和子进程拥有相同的内存映像、同样的环境字符串和同样的打开文件。
子进程接着执行execve或一个类似的系统调用，以修改其内存映像并运行一个新的程序。
当一个用户在shell中键入命令sort时，shell就创建一个子进程，然后，这个子进程执行sort。之所以要安排两步建立进程，是为了在fork之后但在execve之前允许该进程处理其文件描述符，这样可以完成对标准输入文件、标准输出文件和标准错误文件的重定向。
进程创建后，父进程和子进程有各自不同的地址空间。如果其中某个进程在其他地址空间修改了一个字，这个修改对其他进程而言是不可见的。在UNIX中。子进程的初始地址空间是父进程的一个副本，但是涉及两个不同的地址空间，不可写的内存区是共享的。某些UNIX的实现使程序正文在两者间共享，因为它不能被修改。或者，子进程共享父进程的所有内存，单这种情况下内存通过写时复制共享，这意味着一旦两者之一想要修改部分内存，则这块内存首先被明确的复制，以确保修改发生在私有内存区域。再次强调，可写的内存时不可以共享的。但是，对于一个新创建的进程而言，确实有可能共享其创建者的其他资源，诸如打开的文件等。在windows中，从一开始父进程的地址空间和子进程的地址空间就是不同的。
2、进程的终止 进程在创建之后，它开始运行，完成其工作。但永恒是不存在的，进程也一样。迟早这个新的进程会终止，通常由下列条件引起。
1、正常退出 2、出错退出 3、严重错误 4、被其他进程杀死
多数进程是由于完成了他们的工作而终止。
3、进程的层次结构 某些系统中，当进程创建了另一个进程后，父进程和子进程就以谋者形式继续保持关联。子进程自身可以创建更多的进程，组成一个进程的层次结构。进程只有一个父进程，但是可以有多个子进程。
在UNIX中，进程和它所有子进程以及后裔共同组成一个进程组。当用户从键盘发出一个信号时，该信号被送给当前与键盘相关进程组的所有成员。每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被该信号杀死。
一个称为init的特殊进程出现在启动映像中。当它开始运行时，读入一个说明终端数量的文件。接着，为每个终端创建一个新进程。这些进程等待用户登录。如果有一个用户登录成功，该登录进程就执行一个shell准备接收命令。所接受的这些命令会启动更多的进程，一次类推。这样在整个系统中，所有进程都属于以init为根的一棵树。
windows中没有进程层次的概念，所有进程都是地位相同的。唯一类似于进程层次的暗示是在创建进程的时候，父进程得到一个特别的令牌（称为句柄），该句柄可以用来控制子进程。但是它有权把这个令牌传送给某个其他进程，这样就不存在进程层次了。在UNIX中，进程不能剥夺其子线程的继承权。
4、进程的状态 每个进程是一个独立的实体，有自己的程序计数器和内部状态，但是，进程之间经常需要相互作用。一个进程的输出结果可能作为另一个进程的输入。进程有三种状态：1.运行态。该时刻进程实际占用CPU，啥都不缺。2.就绪态，可运行，但因为其他进程正在运行而暂时停止，缺CPU。3、阻塞态，除非某种外部事件发生，否则进程不能运行，缺资源，缺CPU。
前两中状态进程都可以运行，只是第二种状态暂时没有CPU分配给它。第三种状态与前两种状态不同，处于该状态的进程不能运行，即使CPU空闲也不行。
在操作系统发现进程不能运行下去时发生转换1.在某些系统，进程可以执行一个诸如pause的系统调用来进入阻塞状态。在其他系统，包括UNIX中，当一个进程从管道设备文件读取数据时，如果没有有效的输入存在，则进程会被自动阻塞。
转换2和3时由进程调度程序引起的，进程调度程序是操作系统的一部分，进程甚至感觉不到调度程序的存在。
当进程等待的一个外部事件发生时（如一些输入到达），则发生转换4.如果此时没有其他进程运行，则立即触发3转换3，该进程便开始运行。否则该进程将处于就绪态，等待CPU空闲并且轮到它运行。
操作系统的最底层是调度程序，在它上面有许多进程。所有关于中断处理、启动进程和停止进程的具体细节都隐藏在调度程序中。实际上，调度程序是一段非常短小的程序。操作系统的其他部分被简单地组织成进程的形式。不过，很少有真实的系统是以这样的理想方式构造的。
5、进程的实现 为了实现进程模型，操作系统维护者一张进程表（一个结构数组）。每个进程占用一个进程表项（进程控制块）。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开的文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。
![2021-04-1025 (Copy)](C:/Users/Zereal/Desktop/2021-04-1025 (Copy).jpg)
在了解进程表后，就可以对在单个CPU上如何维持多个顺序进程的错觉做更多的阐述。与每一IO类关联的是一个称作中断向量的位置（靠近内存底部的固定区域）。它包含中断服务程序的入口地址。
假设当一个磁盘中断发生时，用户进程3正在运行，则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈，计算机随后跳转到中断向量所指示的地址。这些是硬件完成的所有操作，然后软件，特别是中断服务例程就接管一切剩余的工作。
所有的中断都从保存寄存器开始，对于当前进程而言，通常是保存在进程表项中。
随后会从堆栈中删除由中断硬件机制存入堆栈的那部分信息，并将堆栈指针指向一个由进程处理程序所使用的临时堆栈。
一个进程在执行过程中可能被中断数千次，但关键是每次中断后，被中断的进程都返回到与中断发生前完全相同的状态。</description>
    </item>
    
    <item>
      <title>操作系统——引论</title>
      <link>https://zereals7.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Fri, 02 Apr 2021 18:22:48 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
      <description>完全基于《现代操作系统》第四版，摘取精华，掺杂个人理解。适用于自学党，和想要系统学习操作系统的人。
一、引论 1.为什么要有操作系统？操作系统的任务是什么？ 需求：现代计算机系统的组成极为复杂（处理器，主存，磁盘，输入输出设备&amp;hellip;）,应用程序员没有精力去掌握系统的所有细节。而且，管理这些部件并加以使用，是一件挑战性极强的工作。
所以计算机需要安装一层软件——操作系统。来满足这些需求。（注意：操作系统是系统软件，非应用软件）
任务：为用户程序提供一个更好、更简单、更清晰的计算机模型（操作系统）来实现对计算机所有设备的管理。
一言以蔽之，就是封装硬件运行和管理的细节，服务于上层的应用程序。
抽象是管理复杂性的一个关键，操作系统的任务就是创建好的抽象，并实现和管理它所创建的抽象对象。隐藏硬件，呈现给程序以及程序员良好/清晰/优雅/一致的抽象。
2.用户与操作系统交互的方式——用户接口程序 1.基于文本的——shell（命令行）
2.基于图标的——GUI（图形用户接口）
它们都属于用户接口程序，处于用户态程序中的最低层次。用户可以通过它们运行其他程序，如Web浏览器/音乐播放器等，这些程序也在大量使用操作系统。
3.操作系统内核态和用户态的区别 软件的最基础部分——操作系统，运行在内核态（也称管态，核心态）。核心态下，操作系统具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令。（为所欲为）
所以是有危险性的。
所以在用户态下，只使用了一部分机器指令，尤其是那些影响机器控制以及和IO操作有关系的指令，在用户态中的程序是禁止的。
4.操作系统所处的位置 由底层向上：硬件（裸机）——操作系统（软件，运行在内核态）——用户接口程序（软件，属于用户态最底层，靠近操作系统）——应用程序（软件，用户态）
总之，操作系统运行在裸机（纯硬件）之上，为其他所有软件提供基础的运行环境。
与普通软件的区别：操作系统软件不能被修改，受硬件保护，防止用户试图对其进行修改。
然而，在嵌入式系统（没有内核态）或解释系统（如基于Java的操作系统，它采用解释方式而非硬件方式区分组件）中，上述区别是模糊的。
操作系统一般比用户程序大型，复杂和长寿。（Linux和Windows内核源码都超过了500万行）
5.操作系统的实际用户——应用程序 应用程序直接与操作系统及其抽象打交道，而用户与用户接口所提供的抽象打交道（命令行shell或GUI）。虽然用户接口不同，但是操作系统下面的抽象是相同的。
6.操作系统是资源管理者——把潜在的混乱有序化 资源管理多路复用资源：在时间（CPU时间片）和空间（分割内存）上复用。
操作系统会分配CPU和内存，并协调管理使其有序，以提高运行的效率。
7.操作系统的历史 第一代：真空管和穿孔卡片 ——第二代：晶体管和批处理系统——第三代：集成电路和多道程序设计——第四代：个人计算机——第五代：移动计算机
8.处理器基础知识 CPU是计算机的大脑，它从内存中取出指令并且执行之。
三大流程：取指（从内存中）/解码（确定其类型和操作数）/执行
每个CPU都有特有的指令集，所以x86不能执行ARM程序，反之亦然。而且访存取指的时间比执行指令花费的时间长得多。因此。所有CPU的内部都有一些用来保存关键变量和临时数据的寄存器。
8.1 CPU中的寄存器介绍 除了用来保存变量和临时结果的通用寄存器外，还有一些程序员可见的专用寄存器。其中之一是程序计数器，它保存了将要取出的下一条指令的内存地址。
在取完指令后，程序计数器被更新以指向后继的指令。
另一个寄存器是堆栈指针，它指向内存中当前栈的顶端。该栈包含了每个执行过程的栈帧。一个过程的栈帧中保存了有关的输入参数、局部变量以及那些没有保存在寄存器中的临时变量。
当然还有程序状态字(PSW)寄存器。这个寄存器包含了条件码位、CPU优先级、模式（用户态或内核态），以及各种其他控制位。用户程序通常读入整个PSW，但是只对其中少量字段写入。在系统调用和I/O中，PSW的作用很重要。
操作系统必须知晓所有的寄存器。在时间多路复用CPU中，操作系统经常会中止正在运行的某个程序并再启动另一个程序，每次停止一个正在运行着的程序时，操作系统必须保存所有的寄存器值。这样在稍后该程序被再次运行时，可以把这些寄存器重新装入。
为了改善性能，现代CPU有同时取出多条指令的机制。例如，一个CPU可以有单独的取指单元、解码单元和执行单元，于是当它执行指令N时，可以对指令N+1进行解码，并且可以在内存读取指令N+2。这样的机制称为流水线。
一旦一条指令被取进流水线中，它就必须被执行完毕，即便前一条取出的指令是条件转移，它也必须被执行完毕。
还有更先进的**超标量CPU，有多个取指，解码，执行单元。**只要有一个执行单元空闲，就检查保持缓冲区中是否还有可处理的指令，如果有就把指令从缓冲区中移出并执行之。这种设计程序的指令经常不按顺序执行。多数情况下，硬件负责保证这种运算的结果与顺序执行指令时的结果相同，但是，仍然有部分令人烦恼的复杂情形被强加给操作系统处理（暂不讨论）。
在PSW中有一个二进制位控制CPU的内核态和用户态两种模式。内核态中运行的CPU可以执行指令集中的每一条指令，并且使用硬件的每种功能。值得一提的是，在台式机和服务器中，操作系统在内核态下运行，而在大多数嵌入式系统中，一部分操作系统运行在内核态，其余部分则运行在用户态。
相反**，用户程序在用户态下运行，仅允许执行指令集的一个子集和访问所有功能的一个子集**。一般而言，在用户态中有关IO和内存保护的所有指令是禁止的。当然，将PSW中的模式位设置成内核态也是禁止的。
为了从操作系统中获得服务，用户程序必须使用系统调用以陷入内核并调用操作系统。
只有TRAP指令能把用户态切换成内核态，并启用操作系统。在有关工作完成后，系统调用后面的指令把控制权返还给用户程序。
8.2 多线程和多核芯片 多线程允许CPU保持两个不同的线程状态，然后在纳秒级的时间尺度内来回切换。多线程不提供真正的并行处理。在同一时刻只有一个进程在运行，但是线程的切换时间则减少到纳秒数量级。
**GPU擅长处理大量并行的简单计算，比如在图像应用中渲染多边形。它们不太能胜任串行任务，并且很难编程。**虽然GPU对操作系统很有用（比如加密或者处理网络传输） ，但操作系统本身不太可能运行在GPU上。
8.3存储器 速度由快到慢：寄存器——高速缓存（Cache）——主存（RAM）——磁盘。每位成本也是由高到低。
缓存有利于改善性能。RAM具有电易失性，ROM则非易失。此外ROM速度快且便宜，用于启动计算机的引导加载模块就存放在ROM中。另外，一些I/O卡也采用ROM处理底层设备控制。
EEPROM和闪存也是非易失性的，与ROM相反，他们可以擦除和重写。不过重写比写入RAM要更高数量级的时间。
闪存速度介于RAM和磁盘之间。另外，与磁盘存储器不同，如果闪存擦除的次数过多，就被磨损了。
还有一类存储器是CMOS，它是易失性的。许多计算机利用CMOS存储器保持当前时间和日期。CMOS存储器和递增时间的时钟电路由一块小电池驱动，即使计算机没有上电，时间也可以正确的更新。CMOS存储器还可以保持配置参数。如哪一个是启动磁盘等。之所以采用CMOS是因为它电能消耗非常少，一块原装电池往往能使用数年。CMOS电池没电后，计算机将会不知道由哪个磁盘启动。
磁盘同RAM相比，每个二进制位的成本低了两个数量级。而且通常容量也大几个数量级。唯一的问题是访问数据时间大约慢了三个数量级。低速的原因是因为磁盘是一种机械装置。
磁盘有一个或多个金属盘片，以较高的速度旋转。信息写在磁盘一系列同心圆上。在任意一个给定臂的位置，每个磁头可以读取一段环形区域，称为磁道。把一个给定臂位置上的所有磁道合并起来，组成了一个柱面。
每个磁道划分为若干扇区，典型大小为512字节。现代磁盘中，较外的柱面拥有更多的扇区。机械臂从一个柱面移动到相邻的柱面大概需要1ms。而随机移到一个柱面的典型时间为5-10ms，具体时间取决于驱动器的转速。一旦所需要的扇区移到磁头之下，就开始读写。
固态硬盘没有可以移动的机械臂，是属于闪存，和磁盘同样具有非易失性。
虚拟内存机制：将程序放在磁盘上，将主存作为缓存，用来保存最频繁使用的部分程序。这种机制需要快速的映像内存地址，以便把程序生成的地址转换成为有关字节在RAM中的物理地址。这种映像由CPU中一个叫内存管理单元（MMU）的部件来完成。
缓存和MMU的出现对系统的性能有着重要的影响。在多道程序系统中，从一个程序切换到另一个程序，称为上下文切换。有必要对来自缓存的修改过的块进行写回磁盘的操作。并修改MMU中的映像寄存器。而上下文切换的代价很高，程序员应该努力避免这些操作。
8.4 I/O设备 I/O设备一般包括两个部分，设备控制器和设备本身。
控制器是插在电路板上的一块芯片和一组芯片，这块电路板物理地控制设备，从操作系统接受命令。控制器中一般存在一个小的嵌入式计算机。控制器的任务是为操作系统提供接口。
设备本身也有一个接口，但是功能比较简单。设备本身有个相对简单的接口，接口既不能做很多工作，又已经被标准化。实际的接口隐藏在控制器中。操作系统看到的是对控制器的接口，这个接口可能和设备接口有很大的差别。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zereals7.github.io/post/ml%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zereals7.github.io/post/ml%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5/</guid>
      <description>对常见的机器学习算法进行汇总，主要用到的参考书籍为《机器学习实战》、周志华的《机器学习》以及李航的《统计学习方法》。
一、K邻近算法 1、主要思想 K近邻算法，即是给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的K个实例。特征空间中的每个样本都可以用与它最近的这K个实例来代表。分类的过程是：k个实例进行投票，将待预测样本归入得票最多的类别里面。
不同的K值分类的结果会有偏差，因此如何确定K值呢？k为多少效果最好呢？所谓的最近邻又是如何来判断给定呢？
k太小会导致过拟合，很容易将一些噪声学习到模型中，而忽略了数据真实的分布！
如果我们选取较大的k值，就相当于用较大邻域中的训练数据进行预测，这时与输入实例较远的（不相似）训练实例也会对预测起作用，使预测发生错误，k值的增大意味着整体模型变得简单。
**如果k=N（N为训练样本的个数）,那么无论输入实例是什么，都将简单地预测它属于在训练实例中最多的类。这时，模型是不是非常简单，这相当于你压根就没有训练模型呀！**直接拿训练数据统计了一下各个数据的类别，找最大的而已！这个时候，模型过于简单，完全忽略训练数据实例中的大量有用信息，是不可取的。
k值既不能过大，也不能过小
一般对于二分类问题来说，把K设置为奇数是容易防止平局的现象。但对于多分类来说，设置为奇数未必一定能够防平局。
我们也一般都用欧式距离来衡量我们高维空间中俩点的距离。
欧式距离与曼哈顿距离区别 欧式距离：平方差求和再开方
曼哈顿距离：坐标差的绝对值求和
一般用欧式距离而非曼哈顿距离的原因：欧式距离可适用于不同空间，表示不同空间点之间的距离； 曼哈顿距离则只计算水平或垂直距离，有维度的限制。
特征的数值必须进行归一化，应该让每个特征都是同等重要的，这也是我们要归一化的原因。
k近邻最简单的实现方法是线性扫描，即计算输入实例与每一个训练实例的距离，当训练集很大时，计算非常耗时，所以这种方法是不可行的。 那么如何快速找到样本点的最近邻？
kd树（K-dimension tree)是一种二叉树，表示对特征空间的一个划分； 构造kd’树的过程是不断的用垂直于坐标轴的超平面特征空间划分，构造一系列的矩形区域，kd树的每一个结点对应于一个k维超矩形区域。 利用kd树可以省去对大部分数据点的搜索，从而减少搜索的计算量。
KNN算法算是监督学习还是无监 督学习呢？首先来看一下监督学习和无监督学习的定义。对于监督学习，数据都有明确的label（分类针对离散分布，回归针对连续分布），根据机器学习产生的模型可以将新数据分到一个明确的类或得到一个预测值。对于非监督学习，数据没有label，机器学习出的模型是从数据中提取出来的pattern（提取 决定性特征或者聚类等）。例如聚类是机器根据学习得到的模型来判断新数据“更像”哪些原数据集合。KNN算法用于分类时，每个训练数据都有明确的 label，也可以明确的判断出新数据的label，KNN用于回归时也会根据邻居的值预测出一个明确的值，因此KNN属于监督学习。
2、实现代码 from numpy import *#科学计算包 from numpy import tile from numpy import zeros import operator #运算符模块 import importlib import sys importlib.reload(sys) def createDataSet(): group = array([[1.0,1.1],[1.0,1.0],[0,0],[0,0.1]]) labels = [&amp;#39;A&amp;#39;,&amp;#39;A&amp;#39;,&amp;#39;B&amp;#39;,&amp;#39;B&amp;#39;] return group,labels def classify0(inX, dataSet, labels, k): dataSetSize = dataSet.shape[0] #距离计算 diffMat = tile(inX, (dataSetSize,1)) - dataSet sqDiffMat = diffMat**2 #平方 sqDistances = sqDiffMat.</description>
    </item>
    
    <item>
      <title>王道操作系统课程学习笔记</title>
      <link>https://zereals7.github.io/post/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zereals7.github.io/post/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-/</guid>
      <description>操作系统的概念功能和目标 裸机——操作系统
操作系统是计算机系统中最接近硬件的，一层最基本的系统软件。为上层应用软件提供了接口。
操作系统的功能与目标——作为系统资源的管理者
功能
 处理机管理 存储器管理 文件管理 设备管理  作为用户和计算机硬件之间的接口
 命令接口：允许用户直接使用  联机命令接口：说一句，做一句
脱机命令接口：说一堆，做一堆=批处理命令接口 （.bat文件）
 程序接口：通过程序间接使用  在程序中调用user32.dll，该过程即为系统调用，可实现创建窗口等功能，只能通过用户程序间接使用。
程序接口由一组系统调用组成（程序接口=系统调用=广义指令）
  图形用户接口（GUI）
三大接口统称为用户接口
  操作系统是最接近硬件的层次，实现了对硬件机器的扩展。
通常把覆盖了软件的机器称为扩充机器，也就是虚拟机。
形象比喻：
操作系统好比优秀的工匠，硬件就是：锤子、锯子、木头、钉子
操作系统对硬件的扩展：通过优秀工匠，讲简单的原料组成房子、帆船等等。普通用户可以直接使用工匠提供的房子，而无需关心这些东西在底层是怎么组织起来工作的。
操作系统的特征：并发，共享，虚拟，异步 并发和共享为最基本特征，且二者互为存在条件。
并发：当两个或多个时间在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。
并行：指两个或多个时间在同一时刻发生。
并发性：指计算机系统同时存在多个运行着的程序。
一个单核处理机同一时刻只能执行一个程序，因此操作系统会负责协调多个程序交替运行（这些程序微观上是交替执行的，但宏观上看起来就像是在同时执行）
事实上，操作系统上伴随着“多道程序技术”出现的，因此，操作系统和程序并发是一起诞生的。
对于4核心CPU，意味着同一时刻可以有4个程序并行执行，但是操作系统的并发性依然必不可少。
共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。
两种资源共享方式
  互斥共享方式
系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源。
  同时共享方式
  ​ 系统中的某些资源，允许一个时间段内多个进程同时对它们进行访问。
所谓的同时，往往是宏观上的，在微观上，这些进程可能是交替对该资源进行访问。当然微观上也是可以同时的：如打游戏时听音乐，对扬声器的占用。
例子
互斥共享方式：使用QQ和微信同时进行视频，同一时间段内摄像头只能分配给其中一个进程。
同时共享方式：用QQ发送文件A，同时使用微信发送文件B，宏观上看，两边都在同时读取并发送文件。说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。
并发与共享的关系
如果失去并发性，则系统中只有一个程序正在运行，则共享性也失去了意义。它们互为存在条件。
虚拟
虚拟是把一个物理上的实体变为若干逻辑上的对应物。物理实体是实际存在的，而逻辑上对应物，是用户感受到。
虚拟技术主要可分为
空分复用技术，如虚拟存储器技术
时分复用技术，如虚拟处理器
如果系统失去了并发性，则一段时间内系统中只许运行一道程序，那么就失去了实现虚拟下的意义了。因此，没有并发性就谈不上虚拟性。
异步
异步是指，在多道程序环境中，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。
显然，如果失去了并发性，则系统只能串行地处理各个进程，每个进程的执行会一贯到底。只有系统拥有并发性，才有可能导致异步性。操作系统的发展与分类 手工操作阶段</description>
    </item>
    
  </channel>
</rss>