<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Zereal-宋致远技术博客</title>
    <link>https://zereals7.github.io/</link>
    <description>Recent content on Zereal-宋致远技术博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 17 Jul 2021 20:01:42 +0800</lastBuildDate>
    
	<atom:link href="https://zereals7.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>暑期悬梁计划实施细则</title>
      <link>https://zereals7.github.io/post/%E6%82%AC%E6%A2%81%E8%AE%A1%E5%88%92%E5%AE%9E%E6%96%BD%E7%BB%86%E5%88%99/</link>
      <pubDate>Sat, 17 Jul 2021 20:01:42 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/%E6%82%AC%E6%A2%81%E8%AE%A1%E5%88%92%E5%AE%9E%E6%96%BD%E7%BB%86%E5%88%99/</guid>
      <description>一、作息篇
其一，起床，5点30，洗漱吃饭上厕所6点出门走路去图书馆
路上记记自己的笔记
其二，花一天时间专注于一项重要技能。每日都要有所精进，注重学习方法，注重实效。把自己培养成博学而精专之人。
其三，中午12点午饭，12点半到1点午睡半小时
其四，下午1点学到晚上9点。9点半回到家中，做饭吃。路上记记自己的笔记。用讯飞有声读。
其五，晚上10点半洗澡入睡。
如有时间可以把自己一天的经过拍成视频，回来吃完晚饭花半个小时剪辑。
如觉得学习累了，做做小猿搜题的兼职赚赚外快。
二、学习总目标
过完之后，需掌握坚实计算机软硬件基础，Java编程全方位疏通（达到找工作水平），机器学习入门，office三件套以及ps，cdr加上visio等一系列软件熟练。
此外要学好概率论加离散数学。掌握linux。python，c语言以及前端知识。
算法数据结构要达到一定水平。
三、具体学习方法
注重知识整合，知识回顾，要学通。
多参考各方资料，网课+博客+书+题目全方位练习。
各知识点要善于利用思维导图清晰化知识脉络，善于写总结笔记。善于思考各知识之间的联系。融会贯通。
当一个知识点达到精通可以出一期视频精讲（费曼学习法）
四、具体学习顺序
 第一阶段：考研残余及计算机本科专业知识查漏补缺。  此阶段主要针对于之前考研一知半解的知识进行深度回顾与复习。在某些具有价值的考点的地方可以多加回顾总结。出讲408的视频甚至可以精讲某个知识专题。
先操作系统——计算机组成原理——数据结构——计算机网络
王道书＋视频+黑皮书加教材+个人学霸视频多元素一起使用。以专题模块化思维解决问题。
2.第二阶段： Java深化学习
回顾之前Java学习中不甚明白的点，加以重新复习，深化自己的学习。
先JavaSE——JavaEE——前端WEB——数据库操作——SSM框架——Springboot——Java虚拟机——docker——Maven&amp;amp;git深化学习
——算法——中间件——linux系统深入学习——项目实战
要注重操作和深度理解，同样携带某一专题资料模块化解决。
中间要加强个人博客总结，记录个人有收获的小技巧。记录遇到的坑。
3.第三阶段：机器学习入门
先学习概率论——python——李宏毅全套课程网课配合两本教材
4.第四阶段：各软件操作深化学习
各编程软件数据库软件的优化和功能深入了解，操作熟练。
office套件办公能力学习加强，尤其加强ppt和excel
visio和mind manager 加上project思维导图流程图软件深入学习，学会甘特图
origin加上matlab深度掌握
cad cdr ps三大设计软件深度学习
论文检索以及科研能力培养，网上视频知乎大神经验总结。知道如何写出一篇好论文的全流程。
5、第五阶段：算法入门
熟悉各类算法，加上开始刷leetcode和牛客网的题目。
五、每日总结
每天花10分钟总结记录今日收获（可拍视频），10分做好明日学习计划（Things to do）,画出计划表。精确到小时。</description>
    </item>
    
    <item>
      <title>悬梁计划</title>
      <link>https://zereals7.github.io/post/%E6%82%AC%E6%A2%81%E8%AE%A1%E5%88%92/</link>
      <pubDate>Fri, 16 Jul 2021 23:25:25 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/%E6%82%AC%E6%A2%81%E8%AE%A1%E5%88%92/</guid>
      <description>此计划旨在逆袭人生，当让人刮目相看。
以此步骤开始学习，第一阶段巩固计算机基础知识
王道四门主要专业课和习题花10天过一过，期间结合b站讲的比较精的视频加深理解
第二阶段巩固Java学习成果
第三阶段开始学习机器学习
第四阶段努力学习必要软件的使用</description>
    </item>
    
    <item>
      <title>Java核心技术第十三章笔记-事件处理部署Java应用程序</title>
      <link>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E9%83%A8%E7%BD%B2java%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Thu, 15 Jul 2021 15:27:03 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E9%83%A8%E7%BD%B2java%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</guid>
      <description>JAR文件
将应用程序进行打包时吗，使用者希望仅提供其一个单独的文件，而不是一个含有大量类文件的目录。JAR文件就是为此目的而设计的 。一个JAR文件既可以包含类文件，也可以包含诸如图像换个声音这些其他类型的文件。此外，JAR文件是压缩的，它使用了大家熟悉的ZIP压缩格式。
创建JAR文件
可以使用jar工具制作JAR文件。创建一个新的JAR文件常见的命令格式为jar。
可以将应用程序，程序组件以及代码库打包在JAR文件中。例如，JDK的运行时库包含在一个非常庞大的文件rt.jar中。
清单文件
除了类文件、图像和其他资源外i，每个JAR文件还包含一个用于描述归档特征的清单文件。
清单文件被命名为 MANIFEST.MF，它位于JAR文件的一个特殊META-INF子目录中。最小的符合标准的清单文件是简单的：
Manifest-Version:1.0
复杂的清单文件可能包含更多条目。这些清单条目被分为多个节。第一节被称为主节。它作用于整个JAR文件。随后的条目用来指定已经命名条目的属性。这些已命名的条目可以是某个文件、包或者URL。它们都必须起始于名为Name的条目。节与节之间用空格分开
无论怎样，人们对JAR文件中的Java程序和本地文件有不同的感觉。在Windows平台中，可以使用第三方的包装器工具将JAR文件转换成Windows可执行文件。包装器是一个大家熟知的扩展名为.exe的Windows程序，它可以查找和加载Java的虚拟机，或者在没有找到JVM时，告诉用户应该做些什么。
应用首选项的存储
属性映射时一种存储键值对的数据结构。属性映射通常用来存储配置信息，它有3个特性：键和值是字符串。映射可以很容易地存入文件以及从文件加载。有一个二级表保存默认值。
实现属性映射的Java类名为Properties。
利用Properties类可与很容易地加载和保存配置文件。不过，使用属性文件有以下缺点：有些操作系统没有主目录的概念，所以和南宁找到一个统一的配置文件位置。
关于配置文件的命名没有标准阅读，用户安装多个Java应用时，就更容易发生命名冲突。</description>
    </item>
    
    <item>
      <title>Java核心技术第十四章笔记-并发</title>
      <link>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0-%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Fri, 09 Jul 2021 18:51:26 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0-%E5%B9%B6%E5%8F%91/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Java核心技术第十一章笔记-事件处理</title>
      <link>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</link>
      <pubDate>Thu, 08 Jul 2021 15:39:46 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</guid>
      <description>像Java这样的面向对象语言，都将事件的相关信息封装在一个事件对象中。在Java中，所有的事件对象都最终派生于一个类java.util.EventObject类。当然，每个事件类型还有子类，例如，ActionEvent和WindowsEvent。
不同的事件源可以产生不同类别的事件。例如图，按钮可以发送一个ActionEvent对象，而窗口可以发送WindowsEvent对象。、
下面是AWT事件处理机制的概要
 监听器对象是以一个实现了特定监听器接口的类的实例。 事件源是一个能够注册监听器对象并发送事件对象的对象 当事件发生时，事件源将事件对象传递给所有注册的监听器。 监听器对象将利用事件对象中的信息决定如何对事件做出响应。  ActionListener listener=...;JButton button =new JButton(&amp;quot;OK&amp;quot;);button.addActionListener(listener);现在只要按钮产生了一个动作事件，listener对象就会得到通告。对于按钮来说，正像我们所想到的，动作事件就是点击按钮。
为了实现ActionListener接口，监听器类必须有一个被称为actionPerformed的方法，改方法接受一个ActionEvent对象参数。
只要用户点击按钮，JButton对象就会创建一个ActionEvent对象，然后调用listener.action Performed(event)传递事件对象。可以将多个监听器对象添加到一个按钮这样的事件源中。
这样一来，只要用户点击按钮，按钮就会调用所有监听器的actionPerformed方法。
简洁地指定监听器
一个监听器有多个实例的情况并不多见。更常见的情况是：每个监听器执行一个单独的动作。在这种情况下，没有必要分别建立单独的类。只需要使用一个Lambda表达式：
exitButton.addActionListener(event→System.exit(0) )AWT将事件分为底层事件和语义事件。语义事件是表示用户动作的事件，例如，点击按钮。以那次，ActionEvent是一种语义事件。底层事件是形成那些事件的事件。在点击按钮时，包含了按下鼠标、连续移动鼠标、抬起鼠标事件。或者在用户利用TAB键选择按钮，并利用空格键激活它时，发生的敲击键盘事件。同样，调节滚动条是一种语义事件，但拖动鼠标是底层事件。</description>
    </item>
    
    <item>
      <title>Java核心技术第九章笔记-集合</title>
      <link>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E4%B9%9D%E7%AB%A0%E7%AC%94%E8%AE%B0-%E9%9B%86%E5%90%88/</link>
      <pubDate>Sat, 03 Jul 2021 23:59:02 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E4%B9%9D%E7%AB%A0%E7%AC%94%E8%AE%B0-%E9%9B%86%E5%90%88/</guid>
      <description>Java集合类库是接口与实现分离的。一旦构建了集合就不需要知道究竟使用哪种实现。可以是顺序表可以是链表，可以是队列，可以是循环数组。
集合类的基本接口是Colection接口，有两个基本方法
add 方法向集合中添加元素。如果添加元素改变了集合就返回true，如果集合没有发生变化就返回false。例如，如果试图向集中添加一个对象，而这个对象在集中已经存在，这个添加请求就没有失效，因为集中不允许有重复的对象。iterator方法用于返回一个实现了Iterator接口的对象。可以用这个迭代器对象以此访问集合中的元素。
迭代器
通过反复调用next方法，可以逐个访问集合中的每个元素。但是如果到达了集合末尾，next方法将抛出一个五元素的以此。因此，在调用next之前调用hasNext方法。如果迭代器对象还有多个供访问的元素，这个方法就返回true。如果想要查看集合中的所有元素，就请求一个迭代器，并在hasnext返回true时反复调用next方法。
用for each循环可以更加简练地表示同样的循环操作：
for (String element:collection){do something with element}编译器简单地将for each循环翻译为带有迭代器的循环.
for each 循环可以与任何实现了Iterable接口的对象一起工作。
Collection接口扩展了Iterable接口。因此，对于标准类库中的任何集合都可以使用for each循环。
应该将Java迭代器认为是位于两个元素之间。当调用next时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用。
Iterator接口的remove方法将会删除上次调用next方法时返回的元素。
更重要的时，对next方法和remove方法的调用具有互相依赖性。如果调用remove之前没有调用next将是不合法的。
如果向删除两个相邻的元素，中间必须用next越过将要删除的元素。
集合框架中的接口
Java集合框架为不同类型的集合定义了大量接口
集合有两个基本接口：Collection和Map
List是一个有序集合。元素会增加到容器中的特定位置。可以采用两种方式访问元素：使用迭代器访问，或者使用一个整数索引来访问。后遗症被称为随机访问，因为这样可以按照任意顺序访问元素。
链表尽管也是有序的，但是随机访问很慢，所以最好使用迭代器来遍历。
set接口等同于Collection接口。其add方法不允许增加重复的元素。只要两个集合包含同样的元素就认为是相等的，不需要元素有相同的顺序。hashcode方法的定义要包装包含相同元素的两个集会得到相同的散列码。
建立一个set接口可以让程序员编写只接受集的方法。
SortedSet和SortedMap接口会提供用于排序的比较器对象，这两个接口定义了可以得到集合子集视图的方法。
链表与泛型集合之间有一个重要的区别，链表是一个有序集合。
如果链表中只有很少几个元素，就完全没有必要为get方法和set方法的开销而烦恼，但是优先使用链表的唯一理由是尽可能减少 在列表之间插入或删除元素所付出的代价。如果列表中只有少数几个元素，完全可以使用ArrayList。
建议避免使用以整数索引表示链表中位置的所有方法。如果对集合进行随机访问，就使用数组或ArrayList，而不要使用链表。
List接口用于描述一个有序集合，并且集合中每个元素的位置十分重要。有两种访问元素的协议：一种是用迭代器，另一种是用get和set方法随机访问每个元素。后者不适用于链表，但对数组很有用。集合类库提供了一种大家熟悉的ArrayList类，这个类也实现了List接口。ArrayList封装了一个动态再分配的对象数组。
注意：对于一个经验丰富的Java程序员，在需要动态数组时，可能会使用Vector类。为什么要用ArrayList取代Vector呢？原因很简单：Vector类的所有丰富都是同步的。可以由两个线程安全地访问一个Vector对象。但是，如果有一个线程访问Vector,代码要在同步操作上耗费大量的实际。而ArrayList方法不是同步的。因此，建议在不需要同步时使用ArrayList,而不要使用Vector。
散列集
链表和数组可以按照人们的意愿排列元素的次序。单数，如果想要查看某个指定的元素，却又忘记了它的位置，就需要访问所有的元素，知道找到为止。如果集合中包含的元素很多，将会消耗很多的时间。如果不在意元素的顺序，可以又集中能够快速 查找元素的数据结构。其缺点是无法控制元素出现的次序。它们将按照有利于其操作目的的原则组织数据。
有一种众所周知的数据结构，可以快速地查找所需要的对象，这就是散列表。散列表为每个对象计算一个整数，称为散列码。散列码是由对象的实例域产生一个整数。更准确地说，具有不同的数据域将产生不同的散列码。
最重要的问题是散列码要能够快速地计算出来，并且这个计算只与要散列的对象状态有关，与散列表中的其他对象无关。
在Java中，散列表用链表数组实现。每个列表被称为桶。要想查找标准对象的位置，就要先计算它的散列码，然后与桶的zoo那个书取余，所得到的结果就是保存这个元素的桶的索引。
有时候会遇到桶被占满的情况，这也是不可避免的。这种现象被称为散列冲突。
这是，需要用新对象与桶中的所有对象进行比较，查看这个对象是否已经存在。如果散列码是合理且随机分布的，桶的数目也足够大，需要比较的次数就会很少。
在Javase8中，桶满时会从链表变为平衡二叉树。如果选择的散列函数不当，或者如果有恶意代码试图在散列表中填充多个有相同散列码的值，会产生很多冲突。
想要更多的控制散列表的运行性能，就要指定一个初始的桶数。桶数是指用于收集具有相同散列值的桶的数目。如果要插入到散列表中的元素太多，就会增加冲突的可能性，降低运行性能。
如果大致指定最终由多少个元素插入到散列表中，就可以设置桶数。通常，将桶数设定为预计元素个数的75%-150%。最好将桶数设置为一个素数。以防止键的聚集。
如果散列表太慢，就需要再散列，如果要对散列表再散列，就需要创建以恶个桶数更多的表，并将所有元素插入到这个信标中，然后丢弃原来的表。装填因子决定合适对散列表进行再散列。例如，如果装填因子为0.75，而表中超过75%的位置已经填入元素，这个表就会用双倍的桶数自动地进行再散列。对于大多数应用程序来说，装填因子为0.75是比较合理的。
散列表可以用于实现几个重要的数据结构，其中最简单的是set类型。set是没有重复元素的元素结合。set的add方法首先在集中查找要添加的对象，如果不存在，就将这个对象添加进去。
Java集合类库提供了一个HashSet类，它实现了基于散列表的集。可以用add方法添加元素。contains方法已经被重新定义，用来快速的查看是否某个元素已经出现在集中。它只在某个桶中查找元素，而不必查看集合中的所有元素。
散列集迭代器将以此访问所有的桶。由于散列将元素分散在表的各个位置上，所以访问它们的顺序几乎是随机的。只有不关心集合中的元素的顺序时，才应该使用HashSet。
在更改集中元素时要格外小心，如果元素的散列码发生了改变，元素在数据结构中的位置也会发生变化。
树集
TreeSet与散列集十分类似，不过，它比散列集有所改进。树集是一个有序集合。可以以任意顺序将元素插入到集合中。在对集合进行遍历时，每个值将自动按照排序后的顺序呈现。
排序时用树结构完成的，当前实现使用的是红黑树。每次将一个元素添加到树中时，都被放置到正确的位置上。因此，迭代器总是以排好序的顺序访问每个元素。
将一个元素添加到树中要比添加到散列表中慢。如果树中包含n个元素，查找新元素的正确位置平均需要log2n次比较。
要使用树集，必须能够比较元素。这些元素必须实现Comparable接口。或者构造集时必须提供一个Comparator。
是否应该用树集取代散列集。比较添加一个元素所花费的时间看上去不长，而且元素是自动排序的。到底应该怎么做将取决于所要收集的数据。如果不需要对数据进行排序，就没有必要付出排序的开销。更重要的是，对于某些数据来说，对其排序要比散列更加困难。散列函数只是将对象适当地打乱存放，而比较却要精确地判别每个对象。
队列
队列可以乳糖人们有效地在尾部添加一个元素，在头部删除一个元素。由两个端头的队列，即双端队列，可以让人们有效地在头部和尾部同时添加或删除元素。不支持在队列中间添加元素。
优先级队列
优先级队列中的元素可以按照任意的顺序进行插入，却总是按照排序的顺序进行检索。也就是说，无论何时调用remove方法，总会获得当前优先级队列中最小的元素。然而，优先级队列并没有对所有的元素进行排序。如果用迭代的方式处理这些元素，并不需要对它们进行排序。优先级队列使用了一个优雅且高效的数据结构称为堆。堆是一个可以自我调整的二叉树，对树执行添加和删除操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序。
与TreeSet一样，一个优先级队列既可以保存实现了Comparable接口的类对象，也可以保存在构造器中提供的Comparator对象。
使用优先级队列的典型示例是任务调度。每个任务有一个优先级，任务以随机顺序添加到队列中。每当启动一个新的任务时，都将优先级最高的任务从队列中删除 。由于习惯上将1设为最高优先级，所有会将最小的元素删除。</description>
    </item>
    
    <item>
      <title>Java核心技术第八章笔记-泛型程序设计</title>
      <link>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%85%AB%E7%AB%A0%E7%AC%94%E8%AE%B0-%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Fri, 02 Jul 2021 19:24:20 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%85%AB%E7%AB%A0%E7%AC%94%E8%AE%B0-%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</guid>
      <description>泛型机制编写的程序代码要比那些杂乱地使用Object变量，然后再进行强制类型转换的代码具有更好的安全性和可读性。泛型对于集合类尤其有用，例如，ArrayList就是一个无处不在的集合类。
泛型很像C++中的模板。与Java一样，在C++中，模板也是最先被添加到语言中支持强类型集合的。但是，多年以后人们发现模板那还有其他的用武之地。
泛型程序设计意味着编写的代码可以被很多不同的类型的对象所重用。例如，我们并不希望为聚集String和File对象分别设计不同的类。实际上，也不需要这样做，因为一个ArrayList类可以聚集任何类型的对象。
实际上，在Java增加泛型类之前已经有一个ArrayList类。
数组列表比数组好在可以进行自动扩展。
实现一个泛型类没有那么容易，一个泛型程序员的任务就是预测出所用类的未来可能有的所有用途。
定义简单泛型类
一个泛型类就是具有一个或多个类型变量的类。泛型类可以有多个类型变量。例如，可以定义Pair类，其中第一个域和第二个域使用不同的类型。
类型变量使用大写形式，且比较短，这是很常见的。在Java库中，使用变量E表示集合的元素类型。K和V 分别表示表的关键字和值的类型。T表示任意类型。
泛型方法
泛型方法可以定义在普通类中，也可以定义在泛型类中。
当调用一个泛型方法时，在方法名前的尖括号中放入具体的类型。 ·
类型变量的限定
有时，类或方法需要对类型变量加以约束。变量smallest类型从为T。这意味着它可以是任何一个类的对象。怎么才能确信T所属的类有compareTo方法呢？
解决这个问题的方案是将T限制为实现了Comparable接口的类。可与通过对类型变量T设置限定实现这一点：
实际上Comparable接口本身就是一个泛型类型。目前，我们忽略其复杂性以及编译器产生的警告。
&amp;lt;T extends BoundingType&amp;gt;表示T一个是绑定类型的子类型。T和绑定类型可以是类，也可以是接口。选择关键字extends的原因是更接近子类的概念，并且Java的设计者也不打算在语言中再添加一个新的关键字。 （如sub）
一个类型变量或通配符可以有多个限定，例如：
T extends Comparable &amp;amp; Serializable限定类型用”&amp;amp;“分隔，而逗号用来分隔类型变量。
泛型代码和虚拟机
虚拟机没有泛型类型对象——所有对象都属于普通类。再泛型实现的早期版本中，甚至能够将使用泛型的程序编译为在1.0虚拟机上运行的类文件。这个向后兼容性在Java泛型开发的后期被放弃了。
类型擦除
无论何时定义一个泛型类型，都自动提供了一个相应的原始类型。原始类型的名字就是删去类型参数后的泛型类型名。擦除类型变量，并替换为限定类型（无限定的变量用Object）
对于Pair因为T是一个无限定的变量，所以直接用Object替换。
结果是一个普通的类，就好像泛型引入Java语言之前已经实现的那样。
在程序中可以包含不同类型的Pair，例如Pair或Pair,而擦除类型后就变成原始的Pair类型了。
Java泛型与C++模板有很大区别。C++每个模板的实例化产生不同的类型，这一现象称为模板代码膨胀。Java不存在这个问题的困扰。
原始类型用第一个限定的类型变量来替换，如果没有给定限定就用Object替换。例如，类Pair中的类型变量没有显式的限定，因此，原始类型用Object替换T。假定声明了一个不同的类型。
翻译泛型表达式
当程序调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换。例如下面这个语句序列
Pair&amp;lt;Employee&amp;gt; buddies=...;Employee buddy =buddies.getFirst();擦除getFirst的返回类型后将返回Object类型。编译器自动插入Employee的强制类型转换。也就是说，编译器把这个方法调用翻译为两条虚拟机指令：
对原始方法Pair.getFirst的调用
对返回的Object类型强制转换为Employee类型。
当存取一个泛型域时也要插入强制类型转换。假设Pair类的first域和second域都是公有的。表达式
Employee buddy =buddies.first;会在结果字节码中插入强制类型转换。
翻译泛型方法
类型擦除也会出现在泛型方法中。通常认为下述的泛型方法是一个完整的方法族
public static &amp;lt;T extends Copmparable&amp;gt;T min(T[] a)而擦除类型之后，只剩下一个方法:
public static Comparable min(Comparable[] a)注意，类型参数T已经被擦除了，只留下了限定类型Comparable</description>
    </item>
    
    <item>
      <title>异常、断言和日志</title>
      <link>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%AC%94%E8%AE%B0-%E5%BC%82%E5%B8%B8%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97-/</link>
      <pubDate>Sat, 19 Jun 2021 20:04:09 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%AC%94%E8%AE%B0-%E5%BC%82%E5%B8%B8%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97-/</guid>
      <description>对于异常情况，Java使用一种称为异常处理的错误捕获机制。
在测试期间，需要进行大量的检测以验证程序操作的正确性。然而，这些检测可能非常耗时，在测试完成后也不必保留它们，因此，可以将这些检测删掉，并在其他测试需要时将它们粘贴回来，这是一件很乏味的事。可以使用断言来有选择地启用检测。
当程序出现错误时，并不总是能够与用户或终端进行沟通，此时，可能希望记录下出现的问题，以备日后进行分析。
处理错误
如果由于出现错误而使得某些操作没有完成，程序应该：
 返回到一种安全状态，并能够让用户执行一些其他的命令 或者允许用户保存所有操作的结果，并以妥善的方式终止程序。  异常处理的任务就是将控制权从错误产生的地方转移给能够处理这种情况的错误处理器。
以下为常见的错误：
1.用户输入错误假设有一个用户请求连接一个URL，而语法却不正确。在程序代码中应该对此进行检测，如果没有检查，网络层就会给出警告。2.设备错误例如，打印机在打印过程中可能没有纸了3.物理限制磁盘满了，可用存储空间已被用完。4.代码错误异常结构
所有的异常都由Throwable继承而来，但在下一层立即分解为两个分支：Error和Exception。
Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出这种类型的对象。如果出现了这样的内部错误，除了通告给用户，并尽力使程序安全终止之外，再也无能为力了。这种情况很少出现 。
而Exception又分为运行时RuntimeException异常，另一个分支IOException包含其他异常。划分两个分支的规则是：由出现错误导致的异常属于RuntimeException;而程序本身没有问题，但由于像IO错误这类问题导致的异常属于其他异常。
派生于RuntimeException的异常下面几种情况：
错误的类型转换 数组访问越界 访问null指针
不派生于RuntimeException的异常包括：
 试图在文件尾部读取数据 试图打开一个不存在的文件 试图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在。  如果出现运行时异常一般是程序员本身的问题。这些都一个在运行之前通过检测避免。如何处理不存在的文件呢？难道不能先检测文件是否存在再打开它吗？这个文件可能在你检查它是否存在之前就已经被删除了。是否存在取决于环境，而不只是取决于你的代码。
Java语言规范件将派生于Error类或RuntimeException类的所有异常称为非受查异常（unchecked），所有其他的异常称为受查异常。编译器将核查是否为所有的受查异常提供了异常处理器。
RuntimeException很容易混淆。实际上所有的错误都发生在运行时。
声明受查异常
如果遇到了无法处理的情况，那么Java的方法可以抛出一个异常。一个方法不M仅需要告知编译器将要返回什么值，还要告诉编译器有可能发生什么错误。
方法应该在首部声明所有可能抛出的异常。这样可以从首部反映出这个方法可能抛出哪类受查异常。 如
public FileInputStream(String name) throw FileNotFoundException 这个声明表示这个构造器将根据给定的String参数产生一个FileInputStream对象，但也可能抛出一个FileNotFoundException异常。如果发生了这种糟糕情况，构造器将不会初始化一个新的FileInputStream对象，而是抛出一个FileNotFoundException异常。如果发生了这种糟糕情况，构造器将不会初始化一个新的FileInputStream对象，而是抛出一个FileNotFoundException类对象。如果这个方法真的抛出来这样一个异常对象，运行时系统就会开始搜索异常处理器，以便知道如何处理FileNotFoundException类对象。
在自己编写方法是，不必将所有可能抛出的异常都进行声明。至于什么时候需要在方法中用throw子句声明异常，什么异常必须使用throw子句声明，需要记住以下4种情况需要抛出异常。
1.调用一个抛出受查异常的方法
2.程序运行过程发现错误并且利用throw语句抛出下一个受查异常。
3.程序出现错误
4.Java虚拟机和运行时库出现的内部错误
如果出现前两种情况之一，则必须告诉调用这个方法的程序员有可能抛出异常。为什么？因为任何一个抛出异常的方法都有可能是一个死亡陷阱。如果没有处理器捕获这个异常 ，当前执行的线程就会结束。
对于哪些可能被他人使用的Java方法，应该更具异常规范，在方法的首部声明这个方法可能抛出的异常。
如果一个方法有可能抛出多个受查异常类型，那么就必须在方法首部列出所有的异常类，每个异常类之间用逗号隔开。
但是不需要声明Java的内部错误，即从Error继承的错误。任何程序代码都具有抛出那些异常的潜能，而我们对其没有任何控制能力。
同时也不应该声明从RuntimeException继承的那些非受查异常。这些错误完全在我们的控制之下。如果特别关注数组下标引发的错误，就应该将更多的事件花费在修正程序的错误上，而不是说明这些错误发生的可能性上。
总之，一个方法必须声明所有可能抛出的受查异常，而非受查异常要么不可控制，要么就一个避免发生。
除了声明异常，还可以进行捕获。这样会使异常不被抛到方法之外，也不需要throw规范。
如果在子类中覆盖了超类的一个方法，子类方法中声明的受查异常不能比超类方法中声明的异常更通用。也就是说子类方法可以抛出更特定具体的异常或根本不抛出任何异常。
对于一个已经存在的异常类，将其抛出非常容易。
1.找到一个合适的异常类2.创建这个类的一个对象3.将对象抛出一旦方法抛出了异常，这个方法就不可能返回调用者。也就是说，不必为返回的默认值或错误代码担忧。
创建异常类
在程序中，可能遇到标准异常类不能清楚描述问题。这种情况下，创建自己的异常类就是顺理成章的事情。我们需要做的只是定义一个派生于Exception的类，或者派生于EXception子类的类。
例如，定义一个派生于IOException的类。习惯上，定义的类应该包含两个构造器，一个是默认的构造器；另一个是带有详细描述信息的构造器。
捕获异常
只要将异常抛出就不用理睬了。但是有些代码必须捕获异常。如果某个异常发生的时候没有在任何地方进行捕获， 那程序就会终止执行，并在控制台上打印出异常信息，其中包括异常的类型和堆栈的内容。</description>
    </item>
    
    <item>
      <title>Java核心技术第六章笔记-接口、lambda表达式和内部类</title>
      <link>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%AC%94%E8%AE%B0-%E6%8E%A5%E5%8F%A3lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB-/</link>
      <pubDate>Sun, 16 May 2021 23:10:42 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%AC%94%E8%AE%B0-%E6%8E%A5%E5%8F%A3lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB-/</guid>
      <description>接口主要用来描述类具有什么功能，而并不给出每个功能的具体实现。一个类可以实现一个或多个接口，并在需要接口的地方，随时使用实现了相应接口的对象。
lambda表达式是一种表示可以在将来某个时间点执行代码块的简洁方法。使用lambda表达式，可以用一种精巧而简洁的方式表示使用回调或变量行为的代码。
内部类定义在另一个类的内部，其中的方法可以访问到包含它们外部类的域。内部类技术主要用于设计具有相互协作关系的类集合。
代理，这是一种实现任意接口的对象。代理是一种非常专业的构造工具，它用来构建系统级的工具。
**接口 **
接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的同一格式进行定义。
如果类遵从某个特定的接口，那么就履行这项服务。
Array类的sort方法承诺可以对对象数组进行排序，但要求类必须实现Comparable接口。
任何实现Comparable接口的类都需要包含compareTo方法。
接口中的所有方法自动地属于public。因此，在接口中声明方法时，不必提供关键字public。
有些接口可能包含多个方法。在接口中声明方法时，不必提供关键字public。
提供实例域和方法实现的任务应该由实现接口的那个类来完成。可以将接口看做是没有实例域的抽象类。
假设希望使用Arrays类的sort方法对Employee对象数组进行排序，Employee就必须实现Comparable接口。
为了 让类是实现一个接口，通常需要下面的步骤：
1.将类声明为实现给定的接口
2.对接口中的所有方法进行定义
接口的特性
接口不是类，不能用new运算符实例化一个接口。
尽管不能构造接口的对象，却能声明接口的变量：
Comparable x; 接口变量必须引用实现了接口的类对象
x =new Employee(&amp;hellip;)
与可以建立类的继承关系一样，接口也可以被扩展。这里允许存在多条从具有较高通用性的接口到较高专用性的接口的链。例如，假设有一个被称为Moveable的接口
public interface Moveable{ void move（double x,double y）; } 然后，可以以它为基础扩展一个叫做Powered的接口：
public interface Powerd extends Moveable{double milesPerGallon();}虽然接口中不能包含实例域或静态方法，但却可以包含常量。
与接口中的方法都能自动的设置为public一样，接口中的域将被自动的设为public static final。
有些接口只定义了常量，而没有定义方法。这样的接口似乎偏离了接口概念的初衷，最好不要这样使用它。
尽管每个类只能够拥有一个超类，但却可以实现多个接口。这能为定义类的行为提供极大的灵活性。
Java有一个非常重要的内置接口，称为 Cloneable。如果某个类实现了这个cloneable接口。Object类中的clone方法就可以创建类对象的一个拷贝。如果希望自己设计的类拥有克隆和比较的能力，只要实现这两个接口就可以了。使用逗号将实现的各个接口分隔开。
class Employee implements Cloneable,Comparable 接口与抽象类
使用抽象类表示通用属性存在一个问题：每个类只能扩展于一个类。假设已经扩展于一个类，就不能再扩展第二个类了。但每个类可以实现多个接口。实际上，接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。
静态方法
允许在接口中增加静态方法。目前为止，通常做法都是将静态方法放在伴随类中。在标准库中，会看到成对出现的接口和实用工具类。如Collection或Path。
Path类只包含两个工厂方法。可以由一个字符串序列构造一个文件或目录的路径。
默认方法
可以为接口提供一个默认实现。必须用default修饰符标记这样一个方法。
public interface Comparable&amp;lt;T&amp;gt;{ default int compareTo(T other){ return 0; } } Comparable 的每个实际实现都要覆盖这个方法。不过有些情况下，默认方法可能很有用。</description>
    </item>
    
    <item>
      <title>Java核心技术第五章笔记-继承</title>
      <link>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%AC%94%E8%AE%B0-%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Sun, 09 May 2021 03:40:06 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%AC%94%E8%AE%B0-%E7%BB%A7%E6%89%BF/</guid>
      <description>利用继承，可以基于已存在的类构造一个新类。继承已存在的类就是复用这些类的方法和域。在此基础上，还可以添加一些方法和域，以满足新的需求。
关键字extends表明正在构造的新类派生于一个已存在的类。已存在的类称为超类、基类或父类；新类称为子类、派生类、或孩子类。超类和子类是最常用的术语。
在设计类的时候，应该将通用的方法放在超类中，而将具有特殊用途的方法放在 子类中。
覆盖方法
超类中的有些方法对子类Manager不一定适用。为此需要提供一个新的方法来覆盖超类中的这个方法。子类的访问器方法不能直接访问父类的私有域。要用到公有的接口，也就是父类的访问器方法。比如
super.getSalary（） super不是一个对象的引用，不能将super献给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。
在子类中可以怎么增加域、增加方法或覆盖超类的方法，然而绝对不能删除继承的任何域和方法。
子类构造器
由于子类的构造器不能访问父类的私有域，所以必须利用父类的构造器对这部分私有域进行初始化，我们可以通过super实现对超类构造器的调用，使用super调用构造器的语句必须是子类构造器的第一条语句。。
如果子类的构造器没有显式地调用超类的构造器，则将自动的调用超类默认（没有参数）的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用超类里的其他构造器，则Java编译器将报告错误。
关键字this有两个用途：一是引入隐式参数，二是调用该类其他的构造器(重载解析)。
super关键字也有两个用途：一是调用超类的方法，二是调用超类的构造器（实际上也是一种特殊的方法）。
注意：调用构造器只能作为另一个构造器的第一条语句出现。 构造参数既可以传递给本类的其他构造器，也可以传递给超类的构造器。
虚拟机知道对象引用的实际类型，因此可以正确调用相应的方法。
一个对象变量可以指示多种实际类型的现象称为多态。在运行时能够自动地选择调用哪个方法的现象称为动态绑定。
Java不需要将方法声明为虚拟方法。动态绑定是默认的处理方式。
如果不需要让一个方法具有虚拟特征，可以将其标记为final。
继承层次
有一个公共积累派生出来的所有类的集合被称为继承层次。在继承层次中，从某个特定的类到其祖先的路径被称为该类的继承链。一个祖先类可以拥有多个子孙继承链。
多态
在Java中，对象变量是多态的。一个Employee变量既可以引用一个Employee类对象，也可以引用一个Employee类的任何一个子类的对象。（父类引用指向子类对象）
不能将一个超类的引用赋给子类变量。因为不是所以的父类都是子类。
子类数组的引用可以转换为超类数组的引用，而不需要采用强制类型转换。
所有数组都要牢记创建它们的元素类型，并负责监督仅将类型兼容的引用存储到数组中。否则可能引发数组存储异常。
绑定——方法调用
将一个方法调用同一个方法主体连接到一起称为绑定。如果在程序运行之前执行绑定，由编译器决定方法调用的程序，称为静态绑定。如果绑定过程在程序运行期间，以对象的类型为基础，称为动态绑定。
如果一种语言实现了后期绑定，同时必须提供一些机制，可以在运行期间判断对象的实际类型，并分别调用适当的方法，即便一起此时不知道对象的类型，但方法调用机制能够自己去调查，找到正确的方法主体。Java方法的执行主要采用动态绑定技术，在程序运行时，虚拟机将调用对象实际类型所限定的方法。
下面是调用的过程
1.编译器查看对象的声明类型和方法名。通过声明类型找到方法列表。
2.编译器查看调用方法时提供的参数类型。如果在所有相同方法名中存在一个提供的参数类型完全匹配，就选择这个方法。这个过程被称为重载解析。
3.如果是private方法、static方法、final方法或者构造器，那么编译器可以准确知道应该调用哪个方法。这种调用方式被称为静态绑定。与此对应的是，调用的方法依赖于隐式参数的实际类型，在运行时实现动态绑定。
动态绑定过程
4.当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。假设x的实际elixir时D，它是C类的子类。如果D类定义了了方法f（String）,就直接调用它；否则，将在D类的超类中寻找f（String）,以此类推。
每次调用方法的时候，虚拟机仅查找这个表就行了。在前面的例子中，虚拟机搜索的D类的方法表，以便寻找与调用f（String）相匹配的方法。这个方法即有可能是D.f(String)，又有可能是X.f(String)，这里的X是D的超类。如果调用super.f(param)，编译器将对隐式参数超类的方法表进行搜索。566
实际过程为：
1.虚拟机提取对象实际类型的方法表
2.虚拟机搜索方法签名，知道应该调用哪个方法。
3.虚拟机调用方法。
动态绑定有一个非常重要的特性，无须对现存的代码进行修改就可以对程序进行扩展。假设新增一个新类。并且变量e有可能引用这个类的对象，我们不需要对包含调用e.getSalary()的代码进行重新编译。如果e恰好引用一个Executive类的对象，就会自动调用Exective.getSalary（）方法。
注意：在覆盖一个方法时，子类方法不能低于超类方法的可见性。特别是，如果超类是public，子类方法一定要声明为public。经常会发生这类错误：在声明子类方法的时候，遗漏了public修饰符。此时，编译器会把它解释为试图提供更严格的访问权限。
阻止继承：final类和方法
有时候，可能希望阻止人们利用某个类定义子类。不允许扩展的类被称为final类。如果在定义类的时候使用了final修饰符就表明这个类是final类。
类中的特定方法也可以被声明为final。如果这样做，子类就不能覆盖这个方法。final类中的所有方法都将自动地成为final方法。域也可以被声明为final。对于final域来说，构造对象之后就不允许改变它们的值了。不过，如果将一个类声明为final，只有其中的方法自动地成为final，而不包括域。
将方法和类声明为final的主要目的是：确保它们不会在子类中改变语义。String类是final类，这意味着不允许任何人定义String的子类。换言之，如果由一个String的引用，它引用的一定是一个String对象，而不可能是其他类的对象。
在早期的Java中，有些程序员为了避免动态绑定带来的系统开销而使用final关键字，如果一个方法没有被覆盖而且很短，编译器就能够对它进行优化处理，这个过程称为内联。
虚拟机的即时编译器比传统编译器的处理能力强得多。这种编译器能明确知道类之间的继承关系，并且能够检测出类中是否真正地存在覆盖给定的方法。如果方法很简短、被频繁调用且没有真正地被覆盖，那么即时编译器就会将这个歌方法进行内联处理。（将动态绑定改为静态绑定）。如果虚拟机加载了另外一个子类，而在这个子类中包含了对内联方法的覆盖。那么优化器将取消对覆盖方法的内联。这个过程很慢，但却很少发生。
强制类型转换
进行类型转换的唯一原因是：暂时忽视对象的实际类型之后，使用对象的全部功能。
将一个值存入变量时，编译器将检查是否允许该操作。将一个子类的引用赋给一个超类变量，编译器是允许的。但将一个超类的引用赋给一个子类变量，必须进行类型转换，这样才能通过运行时的检查。
如果试图在继承链上进行向下的类型转换。在进行类型转换之前，先查看一些是否能够成功转换。
if (staff[1] instanceof Manager) { ... } 最后，如果这个类型转换不可能成功,编译器就不会进行进行这个转换。
String c=(String) staff[1]; 将会产生编译错误，这是因为String不是Empoyee的子类。
综上所述：
只能在继承层次内进行类型转换
在将超类转换成子类之前，应该使用instanceof进行检查。
如果x为null，那么进行下列测试
x instanceof c 不会产生异常，只是返回false。之所以这样处理是因为null没有引用任何对象，当然也不会引用C类型的对象。</description>
    </item>
    
    <item>
      <title>Java核心技术第四章笔记-对象和类</title>
      <link>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/</link>
      <pubDate>Wed, 05 May 2021 23:11:17 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/</guid>
      <description>面向对象
Java是完全面向对象的。面向对象的抽象是由对象组成的。
每个对象包含对用户公开的特定功能部分和隐藏的实现部分。程序中的很多对象来自标准库，还有一些是自定义的。
从根本上说，只要对象满足要求，就不必关心其功能的具体实现过程。在OOP中，不必关心对象的具体实现，只要满足用户的需求即可。
对于一些规模较小的问题，将其分解为过程开发比较理想。而面向对象更加适用于解决规模较大的问题。要想实现一个WEB浏览器大约需要2000个过程。这些过程可能需要对一些全局数据进行操作。采用面向对象的设计风格，可能大约100个类，每个类平均包含20个方法。后者更易于程序员掌握，也容易找到bug。假设给定对象的数据出错了，访问过这个数据项的20个方法中查找错误要比在2000个过程中查找容易得多。
类
类是构造对象的模板和蓝图。我们可以将类想象成制作小甜饼的切割机，将对象想象为小甜饼。由类构造对象的过程为创建类的实例。
用Java编写的所有代码都位于某个类的内部。标准的Java库提供了几千个类，可以用于用户界面设计、日期、日历和网络程序设计。尽管如此，还是需要在Java程序中创建一些自己的类，解决实际问题。
封装是与对象有关的一个重要概念。从形式上看，封装不过是将数据和行为组合在以恶个包中，并对对象的使用这隐藏了数据的实现方式。对象中的数据称为称为实例域，操纵数据的过程称为方法。每个特定的类实例都有一组特定的实例域值。这些值的集合就是这个对象的当前状态。无论合适，只要向对象发送一个消息，它的状态就有可能发生改变。
实现封装的关键在于绝对不能让类中的方法直接访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。封装给对象赋予了黑盒特征，这是提高重用性和可靠性的关键。
这意味着一个类可以全面地改变存储数据的方式，只要仍旧使用同样的方法操作数据，其他对象就不会知道或介意所发生的变化。
对象
要想使用OOP，一定要清楚对象的三个主要特性
 对象的行为——可以对对象施加哪些操作，或可以对对象施加哪些方法？ 对象的状态——当是加急那些方法时，对象如何响应？ 对象标识——如何辨别具有相同行为与状态的不同对象？  每个对象都保存着描述当前特征的信息。这就是对象的状态。对象的状态可能会随着时间而发生改变。但这种改变不会是自发的。对象状态的改变必须通过调用方法实现。如果不经过方法调用就可以改变对象状态，只能说明封装性遭到了破坏。
但是，对象的状态并不能完全描述一个对象。每个对象都有一个唯一的身份。
需要注意，作为一个类的实例，每个对象的标识永远是不同的，状态常常也存在着差异。
对象的这些关键特性在彼此之间相互影响着。例如，对象的状态影响它的行为（如果一个订单“已送货”或已付款，就应该拒绝调用而具有增删订单中条目的方法。反过来，如果订单是“空的”，即还没有加入预定的物品，这个订单就不应该进入已送货状态）
识别类
识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。
类之间的关系
 依赖——如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类 聚合——聚合关系意味着类A的对象包含类B的对象 继承——类A扩展类B，类A不但包含从类B继承的方法，还会有一些额外的功能。  对象与对象变量
要想使用对象，必须首先构造对象，并指定其初始状态。然后、对对象应用方法。
构造器是一种特殊的方法，用来构造并初始化对象。
构造器的名字应该与类名相同。因此Date类的构造器名为Date。
new Date（）
这个表达式构造了一个新对象。这个对象被初始化为当前的日期和时间
如果需要的话，也可以将这个对象传递给一个方法：
System.out.println(new Date()); Date类中有一个toString方法。这个方法将返回日期的字符串描述
String s =new Date().toString();一定要认识到：一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。
在Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个引用。
可以显式地将对象变量设置为null，表明这个对象变量目前没有引用任何对象。
局部变量不会自动地初始化为null，而必须通过调用new或将它们设置为null进行初始化
更改器方法与访问器方法
更改器方法是访问并修改对象的方法，与只访问对象而不修改对象的方法是访问器方法。
关键字public意味着任何类的任何方法都可以调用
关键字private确保只有类自身的方法能够访问
为了保证封装性，建议将实例域标记为private
构造器与类同名。在构造类的对象时，构造器会允许，以便将实例域初始化为所希望的状态。
构造器与其他方法有一个重要的不同。它总是伴随着new操作符的执行被调用。不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。
务必记住！
 构造器与类同名 每个类可以有一个以上的构造器 构造器可以有0个、1个或多个参数 构造器没有返回值 构造器总是伴随着new操作一起调用  注意，不要再构造器中定义与实例域重名的局部变量。如
public Employee(String n,double s,...){String name = n;// Errordouble salary =s;//Error}隐式参数与显式参数</description>
    </item>
    
    <item>
      <title>Java核心技术第三章笔记-Java的基本程序设计结构</title>
      <link>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0-java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/</link>
      <pubDate>Fri, 30 Apr 2021 22:08:43 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0-java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/</guid>
      <description>关键字class后面紧跟类名。Java中定义类名的规则很宽松。名字必须以字母开头，后面可以跟字母和数字的任意组合。长度基本上没有限制。但是不能使用Java保留字，例如（public和class）
命名规范
类名必须是以大写字母开头的名词。如果名字由多个单词组成，每个单词的第一个字母都应该大写，这种在一个单词中间使用大写字母的方式称为骆驼命名法。
源代码的文件名必须与公共类的名字相同，并用.java作为扩展名。
运行已编译的程序时，Java虚拟机将从指定类中的main方法开始执行。为了代码能够执行，在类的源文件中必须包含一个main方法。当然，也可以将用户自定义的方法加入到类中，并且在main方法中调用它们。
数据类型
在Java中一共由8中基本类型，其中有4种整型（int4\short2\byte1\long8）、两种浮点类型、1种用于表示Unicode编码的字符char和一种用于表示真值的boolean类型。
在Java种，整型的范围与运行Java代码的机器无关，由于Java程序必须保证在所有机器上都能够得到相同的运行结果，所以各种数据类型的取值范围必须固定。
长整型数值有一个后缀L或l，16进制数值有一个前缀0x或0X。八进制有一个前缀0。从Java7开始，加上前缀0b或者0B就可以些二进制数。还可为数字加入下划线，这些下划线只是为了让人更易读。Java编译器会取出这些下划线。如（1_000_000）
注意，Java中没有无符号（unsigned）类型的整型。
double表示这种类型的数值精度时float类型的两倍。绝大部分应用程序都采用double类型。在很多情况下，float类型的精度很难满足需求。实际上，只有很少的情况适合使用float类型，例如，需要单精度数据的库，或者需要存储大量数据。
float类型的数值有一个后缀的F或f。没有后缀的浮点数值默认为double类型。，当然也可以在浮点数值后面加D或者d。
下面是用于表示溢出和出错情况的三个特殊的浮点数值
正无穷大
负无穷大
NaN（不是一个数字）
例如，有个正整数除以0的结果为正无穷大。计算0/0或者附属的平方根结果为NaN。
浮点数值不适用于无法接受舍入误差的金融计算中，如果数值计算中不允许有任何舍入误差就应该使用BigDecimal类。
变量
变量必须以一个字母或者下划线或者$开头，不能以数字开头。变量名对大小写敏感。且不能使用关键字和保留字。
声明一个变量之后，必须用赋值语句对变量进行显式初始化，千万不要使用未初始化的变量。
在Java中可以将声明放在代码中的任何地方。
在Java中，变量的声明尽可能地靠近变量第一次使用的地方，这是一种良好的程序编写风格。在Java中不区分变量的声明和定义。
常量
关键字final指示常量，表示这个变量只能够被赋值一次。一旦被赋值之后，就不能够再更改了。习惯上，常量名使用全大写。
在Java中，经常希望某个常量可以在一个类的多个方法使用，通常将这些常量称为类常量。 可以使用关键字static final设置一个类常量。
需要注意，类常量的定义位于main方法的外部。因此，在同一个类的其他方法中也可以使用这个常量。而且，如果一个常量被声明为public，那么其他类的方法也可以使用这个常量。
在Java中，必须使用final定义常量。
strictfp关键字标记的方法或者类，则其内的计算必须使用严格的浮点计算。
数值类型转换的优先级是double\float\long\int
小数值向大数值转化不会有丢失。
强制类型转换
当数值转换出现丢失类型的适合，需要通过强制类型转换（cast）实现这个操作。
有时候，变量的取值只在一个有限的集合内。针对这种情况可以自定义枚举类型。枚举类型包括有限个命名的值
如：enum Size{SMALL,MEDIUM,LARGE,EXTRA_LARGE};
现在可以声明这种类型的变量
Size s =Size.MEDIUM
字符串
Java字符串其实就是Unicode字符序列。Java没有内置的字符串类型，而是在标准Java类库中提供了一个预定义类，很自然地叫做String。
每个用双引号括起来的字符串都是String类的一个实例。
字串
String类的subString方法可以从一个较大的字符串提取出一个字串
subString方法的第二个参数是不想复制的第一个位置。它的工作方式有一个优点：容易计算字串的长度。
拼接
Java允许使用+号连接两个字符串 。当将一个字符串与一个非字符串进行拼接时，后者被转换为字符串，任何一个Java对象都可以转换成字符串。
如果需要把多个字符串放在一起，用一个定界符分隔，可以使用join方法。
String all=String.join(&amp;quot;/&amp;quot;,&amp;quot;S&amp;quot;,&amp;quot;M&amp;quot;,&amp;quot;L&amp;quot;,&amp;quot;XL&amp;quot;);// 相当于字符串&amp;quot;S/M/L/XL&amp;quot;不可变字符
String类没有提供用于修改字符串的方法。由于不能修改Java中的字符，所以Java文档中将String类对象称为不可变字符串，当然可以修改字符串变量，让它引用另外一个字符串。
不可变字符串有一个优点：编译器可以让字符串共享。
可以将各种字符串存放在公共的存储池中。字符串变量指向存储池中相应的位置。如果复制一个字符串变量，原始字符串与复制的字符串共享相同的字符。
总而言之，Java设计者认为共享带来的高效率远远胜过提取、拼接字符串所带来的低效率
检测字符串是否相等
可以使用equals方法检测两个字符串是否相等。对于表达式：
s.equals(t)
如果字符串s和字符串t相等，则返回true，否则返回false。需要注意，s和t可以是字符串变量，也可以是字符串字面量。例如，下面的表达式是合法的：
&amp;ldquo;hello&amp;rdquo;.equals（greeting)
要想检测两个字符串是否相等，而不区分大小写，可以使用equalsIgnoreCase方法.
&amp;ldquo;Hello&amp;rdquo;.equalsIgnoreCase（&amp;ldquo;hello&amp;rdquo;）
一定不要使用==运算符检测两个字符串是否相等。这个运算符只能够确定两个字符串是否放置在同一个位置上。当然，如果字符串放置在同一个位置上，它们必然相等。但是完全有可能将内容相同的多个字符串拷贝放置在不同的位置上。
空串与Null串</description>
    </item>
    
    <item>
      <title>常见Dos命令总结</title>
      <link>https://zereals7.github.io/post/%E5%B8%B8%E8%A7%81dos%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 30 Apr 2021 18:50:46 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/%E5%B8%B8%E8%A7%81dos%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</guid>
      <description>常用的内部命令有MD、CD、RD、DIR、PATH、COPY、TYPE、EDIT、REN、DEL、CLS、VER、DATE、TIME、PROMPT。 常用的外部命令有DELTREE、FORMAT、DISKCOPY、LABEL、VOL、SYS、XCOPY、FC、ATTRIB、MEM、TREE。
切换到其他盘符D：
1．MD——建立子目录 功能：创建新的子目录 类型：内部命令ü 格式：MD[盘符：][路径名]〈子目录名〉 FOR 1： C:&amp;gt;md y /&amp;mdash;建立y子目录&amp;mdash;/
2．CD——改变当前目录 功能：显示当前目录ü 类型：内部命令ü 格式：CD[盘符：][路径名][子目录名] 说明：CD命令不能改变当前所在的盘，CD..退回到上一级目录，CD\表示返回到当前盘的目录下，CD无参数时显示当前目录名。 FOR 2： C:&amp;gt;cd y /&amp;mdash;显示当前目录y&amp;mdash;/
3．RD——删除子目录命令 功能：从指定的磁盘删除了目录。 类型：内部命令ü 格式：RD[盘符：][路径名][子目录名] FOR 3： C:&amp;gt;rd y
4．DIR——显示磁盘目录命令 功能：显示磁盘目录的内容。 类型：内部命令ü 格式：DIR [盘符][路径][/P][/W] FOR 4： C:&amp;gt;dir y
5．PATH——路径设置命令 功能：设备可执行文件的搜索路径，只对文件有效。 类型：内部命令ü 格式：PATH[盘符1]目录[路径名1]{[；盘符2：]，〈目录路径名2〉…} FOR 5： C:&amp;gt;path PATH=C:\WINDOWS;C:\WINDOWS\COMMAND;C:\PROGRAMFILES\MTS 6．COPY文件复制命令 ü 功能：拷贝一个或多个文件到指定盘上。 类型：内部命令ü 格式：COPYü [源盘][路径]〈源文件名〉[目标盘][路径][目标文件名] FOR 6_1： C:&amp;gt;copy yyy.txt yyy 1 file(s) copied C:\yyy&amp;gt;dir yyy YYY TXT 8 11-23-03 19:21 /&amp;mdash;现在用DIR命令查看复制的情况&amp;mdash;/ 说明： 如果是将多个文件复制到一个新的文件，命令是这样的COPY [源盘][路径]〈源文件A〉+[源盘][路径]〈源文件B〉[目标盘][路径][目标文件名] FOR 6_2： C:&amp;gt;copy x.</description>
    </item>
    
    <item>
      <title>Java核心技术第一章笔记-概述</title>
      <link>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0-%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Fri, 30 Apr 2021 18:28:02 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0-%E6%A6%82%E8%BF%B0/</guid>
      <description>Java并不只是一种语言。它是一个完整的平台，有一个庞大的库，其中包含很多可重用的代码和一个诸如安全性、跨操作系统的可移植性以及自动垃圾收集等服务的执行环境。Java是一种功能齐全的出色语言，是一个高质量的执行环境，还提供一个庞大的库。
Java的11个关键词
 简单性 面向对象 分布式 健壮性 安全性 体系结构中立 可移植性 解释型 高性能 多线程 动态性   1.简单性
Java是C++的一个纯净版本。这里没有头文件、指针运算、结构、联合、操作符重载、虚基类等。然而设计者并没有试图清除c++中所有不适当的特性。例如switch语句的语法在Java中就没有改变。
简单的另一方面是小。Java的目标之一是支持开发能够在小型机器上独立运行的软件。基本的解释器以及类支持大约仅为40KB；再加上基础的标准类库和对线程的支持（基本上是一个自包含的微内核）大约需要增加175KB。
在当时，这是一个了不起的成就。当然，由于不断的扩展，类库已经相当庞大了。还有一个独立的具有较小类库的Java微型版JME，这个版本适用于嵌入式设备。
2.面向对象
简单地讲，面向对象设计是一种程序设计技术。它将重点放在数据（即对象）和对象的接口上。开发Java时面向对象技术已经相当成熟。Java的面向对象特性与C++旗鼓相当。Java与C++的主要不同点在于多重继承，在Java中，取而代之是更简单的接口概念。与C++相比，Java提供了更丰富的运行时自省概念。
3.分布式
Java有一个丰富的例程库，用于处理像HTTP和FTP之类的TCP/IP协议。Java应用能够通过URL打开和访问网络上的对象，其便捷程度就好像访问本地文件一样。
4.健壮性
Java投入了大量的精力进行早期的问题检测、后期动态的（运行时）检测，并消除了容易出错的情况·······Java和C++最大的不同在于Java采用的指针模型可以消除重写内存和损坏数据的可能性。
Java编译器能够检测许多在其他语言仅在运行时才能够检测出来的问题。至于第二点，对于曾经花费几个小时来检查由于指针BUG而引起内存冲突的人来说，一定很喜欢Java的这一特性。
5.安全性
Java适用于网络/分布式环境。为了达到这个目标，在安全方面投入了很大精力。使用Java可以构建防病毒、防篡改的系统。
从一开始，Java就设计成能够防范各种攻击，其中包括：
 运行时堆栈溢出。如蠕虫和病毒常用攻击手段。 破坏自己的进程空间之外的内存。 未经授权读写文件  遭遇多次高调攻击之后。浏览器开发商和oracle都越来越谨慎。Java浏览器插件不再信任远程代码、除非代码有数字签名而且用户同意执行这个代码。
6.体系结构中立
编译器生成一个体系结构中立的目标文件格式，这是一种编译过的代码，只要有Java运行时系统，这些编译后的代码可以在许多处理器上运行。Java编译器通过生成与特定的计算机体系结构无关的字节码指令来实现这一特性。精心编写的字节码不仅可以很容易在任何机器上解释执行，而且还可以动态地翻译成本地机器代码。
当时，为虚拟机生成代码并不是一个新思路。诸如Lisp、Smalltalk和Pascal等编程语言多年前就已经采用了这种技术。
当然解释虚拟机指令肯定会比全速运行机器指令慢很多。然而，虚拟机有一个选项，可以将执行最频繁的字节码序列翻译成机器码，这一过程称为即时编译。
Java虚拟机还有一些其他的有点。它可以检测指令序列的行为，从而增强其安全性。
7.可移植性
Java是一种强类型语言。数据类型具有固定的大小，而与编译器无关，如int永远为32位的。这消除了代码移植时令人头痛的主要问题。二进制数据以固定的格式进行存储和传输、消除了字节顺序的困扰。字符串是用标准的Unicode格式存储的。
作为系统组成部分的类库，定义了可移植的接口。例如，有一个抽象的Window类，并给出了在UNIX、Windows和Macintosh环境下的不同实现。
除了与用户界面有关的部分外，所有其他Java库都能很好的支持平台独立性。你可以处理文件、正则表达式、XML、日期和时间、数据库、网络连接、线程等，而不用操心底层操作系统。不仅程序是可移植的，JavaAPI往往也比原生API质量更高。
8.解释型
Java解释器可以在任何移植了解释器的机器上执行Java字节码。由于链接是一个增量式且轻量级的过程。所以，开发过程也变得更加快捷，更加具有探索性。
9.高性能
字节码可以在运行时动态的翻译成对应运行这个应用的特定CPU的机器码。
现在的即时编译器已经非常出色，以至于成了传统编译器的竞争对手。在某些情况下，甚至超越了传统编译器，原因是它们含有更多的可用信息。例如，即时编译器可以监控经常执行哪些代码并优化这些代码以提高速度。更为复杂的优化是消除函数调用（即“内联”）。即时编译器知道哪些类已经加载。基于当前加载的类集，如果特定的函数不会被覆盖，就可以使用内联。必要时，还可与撤销优化。
10.多线程
多线程可以带来更好的交互响应和实时行为。
11.动态性
从各种角度看，Java与C或C++相比更加具有动态性。它能够适应不断发展的环境。库中可以自由地添加新方法和实例变量，而对客户端却没有任何影响。在Java中找出运行时类型信息十分简单。
2.关于Java的常见误解 1.Java是HTML的扩展
Java是一种程序设计原因；HTML是一种描述网页结构的方式。除了用于在网页上放置Java applet的HTML扩展之外，两者没有仍和共同之处。
2.使用XML，所有不需要Java
Java是一种程序设计语言；XML是一种描述数据的方式。可以使用任何一种程序设计语言处理XML数据，而Java API对XML处理提供了很好的支持。
3.Java是一种非常容易学习的程序设计语言
像Java这种功能强大的语言大豆不太容易学习。首先，必须将编写玩具式程序的轻松和开发实际项目的艰难区分开来。Java类库包含了数千种类和接口以及数万个函数。虽然不需要知道全部，但是要想Java解决实际问题，还是需要了解不少内容的。
4.Java将成为适用于所有平台的通用性编程语言
从理论上讲，这是完全可能的。但是实际上某些领域其他语言有更出色的表现，比如Swift在IOS设备有着无可取代的地位。浏览器的处理几乎完全由JavaScript掌控。Windows程序通常都用C++或C#编写。Java在服务器编程和跨平台客户端应用领域很有优势。</description>
    </item>
    
    <item>
      <title>SSM第七章-MyBatis的解析和运行原理</title>
      <link>https://zereals7.github.io/post/ssm%E7%AC%AC%E4%B8%83%E7%AB%A0-mybatis%E7%9A%84%E8%A7%A3%E6%9E%90%E5%92%8C%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</link>
      <pubDate>Fri, 30 Apr 2021 17:12:32 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/ssm%E7%AC%AC%E4%B8%83%E7%AB%A0-mybatis%E7%9A%84%E8%A7%A3%E6%9E%90%E5%92%8C%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</guid>
      <description></description>
    </item>
    
    <item>
      <title>SSM第六章-动态SQL</title>
      <link>https://zereals7.github.io/post/ssm%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%8A%A8%E6%80%81sql/</link>
      <pubDate>Thu, 29 Apr 2021 15:06:05 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/ssm%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%8A%A8%E6%80%81sql/</guid>
      <description>if元素 if元素是最常用的判断语句，相当于Java中的if语句，常常与test属性联合使用。
&amp;lt;select id=&amp;#34;findRoles&amp;#34; parameterType=&amp;#34;String&amp;#34; resultMap=”roleResultMap&amp;#34;&amp;gt; select role_no,role_name,note from t_role where 1=1 &amp;lt;if test=&amp;#34;roleName !=null and roleName !=&amp;#39;&amp;#39;&amp;#34;&amp;gt; and role_name like concat(&amp;#39;%&amp;#39;,#{roleName},&amp;#39;%&amp;#39;)\ &amp;lt;/if&amp;gt; &amp;lt;/select&amp;gt; 当参数roleName传递进映射器时，如果参数不为空，则采取构造对roleName的模糊查询，否则就不要去构造这个条件。显然这样的场景在实际工作中十分常见，通过MyBatis的if元素节省了许多拼接SQL的工作，集中在XML里面维护。
choose ,when,otherwise元素 上面的if语句，不是这个就是哪个。有时候还需要第三种选择，甚至更多选择，也就是需要类似switch&amp;hellip;case&amp;hellip;default&amp;hellip;功能的语句。在映射器的动态语句中choose\when\otherwise这三个元素承担了这个给功能。假设这样一个场景
 如果角色编号不为空，则只用角色编号作为条件查询 当角色编号为空，而角色名称不为空，则用角色名称作为条件进行模糊查询 当角色编号和角色名称都为空，则要求角色备注不为空  这个场景也许有点不切实际，但是没关系，这里主要集中于如何使用动态元素来实现它。使用这3个元素，这样MyBatis就会更具参数的设置进行判断来组装SQL，以满足不同的业务要求。远比Hibernate和JDBC等需要大量判断Java代码，要清晰和明确得多，进而提高程序的可读性和可维护性。
&amp;lt;select id=&amp;#34;findRoles&amp;#34; parameterType=&amp;#34;role&amp;#34; resultMap=”roleResultMap&amp;#34;&amp;gt; select role_no,role_name,note from t_role where 1=1 &amp;lt;choose&amp;gt; &amp;lt;when test=&amp;#34;roleNo!=null and roleNo !=&amp;#39;&amp;#39;&amp;#34;&amp;#34;&amp;gt; AND role_no =#{roleNo} &amp;lt;/when&amp;gt; &amp;lt;when test=&amp;#34;roleName !=null and roleName !=&amp;#39;&amp;#39;&amp;#34;&amp;gt; AND role_name like concat(&amp;#39;%&amp;#39;,#{roleName},&amp;#39;%&amp;#39;)\ &amp;lt;/when&amp;gt; &amp;lt;otherwise&amp;gt; AND note is not null &amp;lt;/otherwise&amp;gt; &amp;lt;/select&amp;gt; trim、where、set元素 上面代码SQL语句上的动态元素的SQL中都加入了一个条件“1=1”，如果没有加入这个条件，就可能如下面的错误</description>
    </item>
    
    <item>
      <title>SSM第五章-映射器</title>
      <link>https://zereals7.github.io/post/ssm%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%98%A0%E5%B0%84%E5%99%A8/</link>
      <pubDate>Thu, 22 Apr 2021 18:36:47 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/ssm%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%98%A0%E5%B0%84%E5%99%A8/</guid>
      <description>映射器是MyBatis最复杂且最重要的组件。它由一个接口加上XML文件（或者注解）组成。在映射器中可以配置参数、各类的SQL语句、存储过程、缓存、级联等复杂的内容，并且通过简易的映射规则映射到指定的POJO或者其他对象上，映射器能有效消除JDBC底层的代码。
在MyBatis应用程序开发中，映射器的开发工作量占全部工作量的80%。在MyBatis中映射器的配置顶级元素不多，但是里面的一些细节，比如缓存、级联、#和￥字符的替换参数、存储过程需要我们进一步学习。
MyBatis的映射器也可以使用注解完成，但是它在企业应用不广，原因主要来自3个方面：其一，面对复杂性，SQL会显得无力，尤其是长SQL。其二，注解的可读性比较差。其三，在功能上，注解丢失了XML上下文相互引用的功能。
5.1 概述 parameterMap是MyBatis官方不推荐的元素，可能即将被删除。
5.2 select元素——查询语句 在映射器中select元素代表SQL的select语句，用于查询。在SQL中，select语句是用得最多的语句，在MyBatis中select元素也是用得最多的元素，使用的多就意味着强大和复杂。
   元素 说明 备注     id 它和Mapper的命名空间组合起来是唯一的，供MyBatis调用 如果命名空间和id结合起来不唯一，MyBatis将抛出异常   parameterType 可以给出类的全命名，也可以给出别名，但是别名必须是MyBatis内部定义或者自定义的 ——   parameterMap 即将废弃的元素，不讨论 ——   resultType 定义类的全路径，在允许自动匹配的情况下，结果集将通过JavaBean的规范映射：或定义为int、double、float、map等参数；也可以使用别名，但必须要符合别名的命名规范，且不能和resultMap同时使用 常用的参数之一，比如统计总条数数时可以把它的值设置为int   resultMap 它是映射集的引用，将执行强大的映射功能，我们可以使用resultType和resultMap其中的一个，resultMap能提供自定义映射规则的机会。 是MyBatis最复杂的元素，可以配置映射规则、级联、typeHandler   flushCache 它的作用是在调用SQL后，是否要求MyBatis清空之前查询本地缓存和二级缓存 取值为布尔值，true/false.默认值为false   useCache 启动二级缓存的开关，是否要求MyBatsi将此次结果缓存 取值为布尔值，true/false.默认值为true   timeout 设置超时参数，超时将抛出异常，单位为秒 默认值是数据库厂商提供的JDBC驱动所设置的秒数   fetchSize 获取记录的总条数设定 默认值是数据库厂商提供的JDBC驱动所设置的条数   statementType 告诉Mybatis使用哪个JDBC的Statement工作，取值为STATEMENT、PREPARED、CALLABLE 默认值为PREPARED   resultSetType 这是对JDBC的resultSet接口而言，它的值包括FORWARD_ONLY（游标允许向前访问）、SCROLL_SENSITIVE（双向滚动，但不及时更新，就是如果数据库里的数据修改过，并不再resultSet中反映出来）、SCROLL_INSENSITIVE（双向滚动，并及时跟踪数据库的更新，以便更改resultSet中的数据） 默认值是数据库厂商提供的JDBC驱动所设置的   databaseId 配置使用 提供多种数据库的支持   resultOrdered 这个设置仅适用于嵌套结果select语句，如果为true，就是假设包含了嵌套结果集或是分组了，当返回一个主结果行是，就不能引用前面结果集了。这就确保了在获取嵌套的结果集时不至于导致内存不够用。 取值为布尔值，true/false。默认值为false   resultSets 适用于多个结果集的情况，它将列出执行SQL后每个结果集的名称，每个名称之间用逗号分隔 很少使用    在实际工作中用得最多的是id、parameterType、resultType、resultMap，如果要设置缓存，还会使用到flushCache、useCache，其他的都是不常用的功能。这里主要讨论id、parameterType、resultType、resultMap及它们的映射规则。</description>
    </item>
    
    <item>
      <title>SSM第四章-MyBatis配置</title>
      <link>https://zereals7.github.io/post/ssm%E7%AC%AC%E5%9B%9B%E7%AB%A0-mybatis%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 19 Apr 2021 01:38:36 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/ssm%E7%AC%AC%E5%9B%9B%E7%AB%A0-mybatis%E9%85%8D%E7%BD%AE/</guid>
      <description>4.1 概述 MyBatis配置文件不复杂
配置文件元素
&amp;lt;configuration&amp;gt;配置&amp;lt;properties/&amp;gt;属性&amp;lt;setting/s&amp;gt;设置&amp;lt;typeAliases/&amp;gt;类型别名&amp;lt;typeHandlers/&amp;gt;类型处理器&amp;lt;objectFactory/&amp;gt;对象工厂&amp;lt;plugins&amp;gt;插件&amp;lt;environments&amp;gt;配置环境&amp;lt;environment&amp;gt;环境变量&amp;lt;transactionManager&amp;gt;事务管理器&amp;lt;dataSource&amp;gt;数据源&amp;lt;/environment&amp;gt;&amp;lt;/environments&amp;gt;&amp;lt;databaseIdProvider/&amp;gt;数据库厂商标识&amp;lt;mappers&amp;gt;映射器&amp;lt;/configuration&amp;gt;需要注意配置的顺序不能颠倒。顺序错了，启动阶段就会发生异常，导致程序无法运行。
4.2 properties属性 properties属性可以给系统配置一些运行参数，可以放在XML文件或者 properties文件中，而不是放在Java编码中，这样的好处在于方便参数修改，不会引起代码重新编译。
可以使用元素 properties下的 propertie子元素定义。比如通过
,可以定义数据库的驱动，然后可以通过${database.driver},定义一次，到处引用。如果属性参数有成百上千个，可以使用properties文件。
使用properties文件是比较普遍的方法，一方面这个文件十分简单，其逻辑就是键值对应，我们可以配置多个键值放在一个properties文件中，也可以把多个键值对放在多个properties文件中，这些都是允许的，它方便日后维护和修改。
在MyBatis中通过properties的属性resource来引入properties文件。
&amp;lt;properties resource=&amp;#34;jdbc.properties&amp;#34;/&amp;gt; 也可以按${database.username}的方法引入properties文件的属性参数到MyBatis配置文件中。这个时候通过维护properties文件就可以维护我们的配置内容了。
在真实的生产环境中，数据库的用户密码是对开发人员和其他人员保密的。运维人员为了保密，一般都需要把用户和密码经过加密成为密文后，配置到properties文件中。对于开发人员及其他人员而言，就不知道其真实的用户密码了，数据库也不可能用以及加密的字符串去连接，此时往往需要通过解密才能得到真实的用户和密码了。现在假设系统已经为提供了这样的一个CodeUtils.decode(str)进行解密，那么我们在创建SqlSessionFactory前，就需要把用户名和密码解密，然后把解密后的字符串重置到properties属性中。
首先使用Resources对象读取了一个jdbc.properties配置文件，然后获取了它原来配置的用户和密码，进行解密并重置，最后使用SqlSessionFactoryBuilder的build方法，传递多个properties参数来完成。这将覆盖之前配置的密文，这样就能连接数据库了，同时也满足了运维人员对数据库用户和密码安全的要求。
总结：以上是MyBatis使用properties的3种方式。这3种方式是有优先级的，最优先的是使用程序传递的方式，其次是使用properties文件的方式，最后使用子元素的方式。MyBatis会根据优先级来覆盖原先配置的属性值。
建议采用properties文件的方式，因为管理它简单易行，而且可以从XML文件中剥离出来独立维护。
4.3 settings设置 settings是MyBatis中最复杂的配置，它能深刻影响MyBatis底层的运行，但大部分情况下使用默认值便可以运行，所以大部分情况下不需要大量配置它，只需要修改一些常用的规则即可，比如自动映射、驼峰命名映射、级联规则、是否启动缓存、执行器类型等。
settings的配置项很多，但是真正用到的不会太多，我们把常用的配置项研究清楚就可以了，比如关于缓存的CacheEnabled,关于级联的LazyloadingEnabled和aggressiveLazyLoading,关于自动映射的autoMappingBehavior和mapUnderscoreToCamelCase,关于执行器类型的defaultExecutorType等。
4.4 typeAliases别名 由于类的全限定名很长，需要大量使用的时候，写那么长的名称不方便。在MyBatis中允许定义一个简写来代表这个类，这就是别名，别名分为系统定义别名和自定义别名。在MyBatis中别名由类TypeAliasRegistry去定义。注意，在MyBatis中别名不区分大小写。
MyBatis也提供了用户自定义别名的规则。我们可以通过TypeAliasRegistry类的registerAlias方法注册，也可以采用配置文件或者扫描方式来自定义它。
使用配置文件定义很简单：
&amp;lt;typeAliases&amp;gt; &amp;lt;typeAliases alias=&amp;#34;role&amp;#34; type=&amp;#34;com.leartn.ssmchapter4.pojo.Role&amp;#34;/&amp;gt; &amp;lt;typeAliases alias=&amp;#34;user&amp;#34; type=&amp;#34;com.learn.ssm.chapter4.pojo.User&amp;#34;/&amp;gt; &amp;lt;/typeAliases&amp;gt; 这样就可以定义一个别名了。如果由很多类需要定义别名，那么用这样的方式进行配置可就不那么轻松了。MyBatis还支持扫描别名。比如上面的两个类都在包com.learn.ssm.chapter4.pojo之下，那么就可以定义为：
&amp;lt;typeAliases&amp;gt; &amp;lt;package name=&amp;#34;com.learn.ssm.chapter4.pojo&amp;#34;/&amp;gt; &amp;lt;typeAliases&amp;gt; 这样MyBatis将扫描这个包里面的类，将其第一个字母变为小写作为其别名，比如类Role的别名会变成role，而User的别名会变成user。使用这样的规则有时候会出现重名，这个时候可以使用MyBatis提供的直接@Alias来进行区分。
这样就能够避免因为别名重名导致的扫描失败的问题。
4.5 typeHandler类型转换器 在JDBC中，需要在PreparedStatement对象中设置那些已经预编译过的SQL语句的参数。执行SQL后，会通过ResultSet对象获取得到数据库的数据，而这些MyBatis是根据数据的类型typeHandler来实现的。在typeHandler中，分为jdbcType和javaType,其中jdbcType用于定义数据库类型，而javaType用于定义Java类型，那么typeHandler的作用就是承担jdbcType和iavaType之间的相互转换。在很多情况下我们并不需要去配置typeHandler、jdbcType、javaType,因为MyBatis会探测应该使用什么类型的typeHandler进行处理，但是有些场景无法探测到。对于那些需要使用自定义枚举的场景，或者数据库使用特殊数据类型的场景，可以使用自定义的typeHandler去处理类型之间的转换问题。
和别名一样，在MyBatis中存在系统定义typeHandler和自定义typeHandler。MyBatis会根据javaType和数据库的jdbcType来决定采用哪个typeHandler处理这些转换规则。系统提供的typeHandler能覆盖大部分场景的要求，但是有些情况下是不够的，比如我们由特殊的转换规则，枚举类就是这样。
总之，typeHandler负责jdbcType和javaType之间的相互转换。
在大部分的情况下无须显式地声明jdbcType和javaType，或者用typeHandler去指定对应的typeHandler来实现数据类型转换，因为MyBatis系统会自己探测。有时候需要修改一些转换规则，比如枚举类往往需要自己去编写规则。
typeHandler继承了BaseTypeHandler
 BaseTypeHandler是个抽象类，需要子类去实现其定义的4个抽象方法，而它本身实现类typeHandler接口的4个方法。 getResult方法，非空结果集是通过getNullableResult方法获取的。如果判断为空，则返回null。 setParameter方法，当参数parameter和jdbcType同时为空时，MyBatis将抛出异常，如果能明确jdbcType,则会进行空设置；如果参数不为空，那么它将采用setNonNullParameter方法设置参数。 getNullableResult方法用于存储过程。  MyBatis使用最多的typeHandler之一——StringTypeHandler。它用于字符串转换。它实现类BaseTypeHandler的4个抽象方法。</description>
    </item>
    
    <item>
      <title>SSM第三章-MyBatis核心组件</title>
      <link>https://zereals7.github.io/post/mybatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Fri, 16 Apr 2021 21:47:55 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/mybatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</guid>
      <description>3.1 持久层的概念和MyBatis的特点 持久层可以将业务数据存储到磁盘，具备长期存储能力，只要磁盘不损坏，在断电或者其他情况下，重新开启系统仍然可以读取这些数据。一般执行持久任务的都是数据库系统，持久层可以使用巨大的磁盘空间，也比较廉价，缺点就是慢，当然慢是针对内存而言的，在一般系统中运行是不存在问题的，比如内部管理系统，但是在互联网的秒杀场景下，每秒需要执行成千上万次数据操作，慢是不能承受的，极有可能导致宕机，在这样的场景下考虑使用Redis处理。
MyBatis最大的成功来自于三点
 不屏蔽SQL，意味着可以更为精确的定位SQL语句，可以对其进行优化和改造，这有利于互联网系统性能的提高，符合互联网需要性能优化的特点。 提供强大、灵活的映射机制，方便Java开发者使用。提供动态SQL的功能，允许我们根据不同条件组装SQL，这个功能远比其他工具或者Java编码的可读性和可维护性高得多，满足各种应用系统的同时也满足了需求经常变化的互联网应用的要求。 在MyBatis中，提供了使用Mapper的接口编程，只要一个接口和一个XML就能创建映射器，进一步简化我们的工作，使得很多框架API在MyBatis中消失，开发者更集中于业务逻辑。  3.2 准备MyBatis环境 网上复制相关依赖
3.3 MyBatis核心组件 MyBatis的核心组件分为4个部分
 SqlSessionFactoryBuilder(构造器)：它会根据配置或者代码来生成SqlSessionFactory,采用的是分布构建的Builder模式。 SqlSessionFactory（工厂接口）：依靠它来生成SqlSession，使用的是工厂模式。 SqlSession(会话)：一个既可以发送SQL执行返回结果，也可以获取Mapper的接口。在现有的技术中，我们会让其在业务逻辑代码中消失，而使用的是MyBatis提供的SQL Mapper接口编程技术，它能提高代码的可读性和可维护性。 SQL Mapper（映射器）：MyBatis新设计的组件存在的组件，它由一个Java接口和XML文件构成，需要给出对应的SQL和映射规则。它负责发送SQL去执行，并返回结果。  无论是映射器还是SqlSession都可以发送SQL到数据库执行。
3.4 SqlSessionFactory（工厂接口） 使用MyBatis首先是使用配置或者代码去生产SqlSessionFactory，而MyBatis提供了构造器SqlSessionFactoryBuilder。它提供了一个类org.apache.ibatis.session.Configuration作为引导，采用的是Builder模式。具体的分步是在Configuration类里面完成的。
在MyBatis中，可以通过读取皮质的XML文件的形式生成SqlSessionFactory，也可以通过Java代码的形式取生产SqlSessionFactory。推荐使用XML的形式，因为代码的方式在需要修改的时候会比较麻烦。当配置了XML或者提供代码后，MyBatis会读取配置文件，通过Configuration类对象构建整个MyBatis的上下文。SqlSessionFactory是一个接口，在MyBatis中存在两个实现类：SqlSessionManager和DefaultSqlSessionFactory,一般而言，具体是由DefaultSqlSessionFactory去实现的，而SqlSessionManager使用在多线程的环境中，它的具体实现依靠DefaultSqlSessionFactory。
每个基于MyBatis的应用都是以一个SqlSessionFacrory的实例为中心的，而SqlSessionFactory唯一的作用就是生产MyBatis的核心接口对象SqlSession,所以它的责任是唯一的。我们往往采用单例模式处理它，使用配置文件和Java代码两种形式去生成SqlSessionFactory的方法。
3.4.1 使用XML构建SqlSessionFactory 首先，在MyBatis中的XML分为两类，一类是基础配置文件，通常只有一个，主要是配置一些最基本的上下文参数和运行环境；另一类是映射文件，它可以配置映射关系，SQL、参数等信息。
基础配置文件：
元素定义了别名，可以代替全限定名。
元素的定义，这里描述的是数据库。它里面的元素是配置事务管理器，这里采用的是MyBatis的JDBC管理器方式。然后采用元素配置数据库，其中属性 type=“POOLED”代表采用MyBatis内部提供的连接池方式。
元素代表引入的那些映射器。
通过XML构建SqlSessionFactory
SqlSessionFactory SqlSessionFactory=null； String resource =&amp;#34;mybatis-config.xml&amp;#34;; InputStream inputStream; try{ inputStream =Resources.getResourceAsStream(resource); SqlSessionFactory= new SqlSessionFactoryBuilder().build(inputStream); }catch(IOException e){ e.printStarkTrace(); } 首先读取mybatis-config.xml,然后通过SqlSessionFactoryBuilder的Builder方法去创建SqlSessionFactory。整个过程比较简单，而里面的步骤还是比较烦琐的，只是MyBatis采用了Builder模式为开发者隐藏了这些细节。这样一个SqlSessionFactory就被创建出来了。
推荐采用XML创建的形式，信息在配置文件中，有利于我们日后的维护和修改，避免了重新编译代码。
3.4.2 使用代码创建SqlSessionFactory 代码冗长，如果发生系统修改，那么有可能需要重新编译代码才能继续，所以不是一个很好的方式。除非有特殊的需要，比如在配置文件中，需要配置加密过的数据库用户名和密码，需要我们在生产SqlSessionFactory前解密为明文的时候，才会考虑使用这样的方式。
3.5 SqlSession 在MyBatis中，SqlSession是其核心接口。在MyBatis中有两个实现类，DefaultSqlSession和SqlSessionManager。DefaultSqlSession是单线程使用的，而SqlSessionManager在多线程环境下使用。SqlSession的作用类似于一个JDBC中的Connection对象，代表着一个连接资源的启用。具体而言，有三个作用。
 获取Mapper接口 发送SQL给数据库 控制数据库事务  创建SqlSession
SqlSession sqlSession =SqlSessionFactory.</description>
    </item>
    
    <item>
      <title>SSM第二章-Java设计模式</title>
      <link>https://zereals7.github.io/post/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 15 Apr 2021 00:24:01 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>2.1 Java反射技术 Java反射技术应用广泛，它能够配置：类的全限定名、方法和参数，完成对象的初始化，甚至是反射某些方法。这样就可以大大增强Java的可配置性，Spring IOC的基本原理他也是如此，当然Spring IOC的代码要复杂得多。
2.1.1 通过反射构建对象 在Java中允许通过反射配置信息构建对象。
这里的代码就是生成一个对象，然后将其返回。下面这行代码的目的就是给类加载器注册了一个类对象，使用反射的方式也十分简单。
object=(ReflectServiceImpl)Class.forName(&amp;quot;com.learn.ssm.chapter2.reflect.ReflectServiceImpl&amp;quot;).newInstance();
这是一个构建方法，没有任何参数的类的反射生成，所以还剩下一个问题，即如果一个类的所有构建方法都至少存在一个参数，如何用反射构建它。其实，只要少排位改变就可以。
使用如下代码发生你和生成对象：
`object=(ReflectServiceImpl2)Class.forName(&amp;#34;com.learn.ssm.chapter2.reflect.ReflectServiceImpl2&amp;#34;).getConstructor(String.class).newInstance(&amp;#34;张三&amp;#34;)；` 先通过forName加载到类的加载器。然后通过getConstructor方法，它的参数可以是多个，这里定义为String.class，意为有且只有一个参数类型为String的方法。通过这个方法可以对重名方法进行排除，此时再用newInstance方法生成对象，只是newInstance方法也多了一个参数“张三&amp;quot;而已。实际就等于object=new ReflectServiceImpl2(&amp;ldquo;张三&amp;rdquo;)，只是这里用反射机制来生成这个对象而已。
反射的优点是只要配置就可以生成对象，可以接触程序的耦合度，比较灵活。反射的缺点是运行比较慢。但是大部分情况下为了灵活度，降低程序的耦合度，我们还是会使用反射的，比如Spring IOC容器。
2.1.2 反射方法 在使用反射方法前要获取方法对象，得到了方法才能去反射。
当有具体的对象target，而不知道具体是哪个类时，也可以使用getClass方法找到全限定类名
target.getClass().getMethod(&amp;#34;sayHello&amp;#34;,String.class); 代替它，其中第一个参数是方法名称，第二个参数是参数类型，是一个列表，多个参数可以继续编写多个类型，这样便能获得反射的方法对象。
反射方法是运用
returnObj=method.invoke(target,&amp;#34;张三&amp;#34;)； 代码完成的。
第一个参数为target，就是确定用哪个对象调用方法，而”张三“是参数，这行就等于target.sayhello(&amp;ldquo;张三&amp;rdquo;)；。
如果存在多个参数，可以写成Method.invoke(target，obj1,obj2,obj3&amp;hellip;..),这些要根据对象的具体方法来确定。
对象在反射机制生成后，反射了方法，我们完全可以通过配置完成对象和方法的反射，大大增强了Java的可配置性和可扩展性，其中Spring IOC就是一个典型的样例。
2.2 动态代理模式和责任链模式 动态代理的意义在于生成一个代理对象（占位），来代理真实对象，从而控制真实对象的访问。
代理模式举例：假设你的公司是一家软件公司，你是一位软件工程师。客户带着需求找公司不不会直接和你谈，而是找商务谈，此时客户会认为商务就代表公司。
显然客户是通过商务区访问软件工程师的，那么商务(代理对象)的意义是什么呢？商务可以进行谈判，比如项目启动前的商务谈判，软件的价格、交付、进度的事件节点等，或者项目完成后的商务追讨应收账款等。商务也有可能在开发软件之前谈判失败，此时商务就会根据公司规则去结束和客户的合作关系，这些都不用软件工程师来处理。因此，代理的作用就是，在真实对象访问之前或之后加入对应的逻辑，或者根据其他规则控制是否使用真实对象，显然这个例子里商务控制了客户对软件工程师的访问。
商务和软件工程师是代理和被代理的关系，客户是经过商务去访问软件工程师的。此时客户就是程序中的调用者，商务就是代理对象，软件工程师就是真实对象。我们需要在调用者调用对象之前产生一个代理对象，而这个代理对象需要和真实对象建立代理关系，所以代理必须分为两个步骤：
 代理对象和真实对象建立代理关系 实现代理对象的代理逻辑方法  在Java中有多种动态代理技术，比如JDK、CGLIB、Javassist、ASM，其中最常用的动态代理技术有两种：一种是JDK动态代理，这是JDK自带的功能；另一种是CGLIB,这是第三方提供的一个技术。目前，SPring 常用JDK和CGLIB，而MyBatis还使用了Javassist，无论使用哪种代理其技术，理念相似。
在JDK动态代理中，我们必须使用接口，而CGLIB不需要，所以使用CGLIB会更简单一些。
AOP的实现方式：动态代理。与静态代理对比，动态代理是在runtime动态生成Java代理类，由代理类完成对具体方法的封装，实现AOP的功能。
2.2.1 JDK动态代理 JDK动态代理是java.lang.reflect.*包提供的方式，它必须借助一个接口才能产生代理对象，所以先定义接口。
然后提供实现类来实现接口。有了接口和实现类，此时可以开始动态代理了。按照我们之前的分析，先要建立起代理对象和真实服务对象的关系，然后实现代理逻辑，所以一共 分为两个步骤。
在JDK动态代理中，要实现代理逻辑类必须去实现java.lang.reflect.InvocationHandler接口，它里面定义了一个invoke方法,并提供接口数组用于下挂代理对象。
***第一步，建立代理对象和真实对象的关系。***这里是使用了bind方法去完成的，方法里面首先用类的属性target保存了真实对象，然后 通过如下代码建立并生成代理对象。
其中newProxyInstance方法包含3个参数
第一个是类加载器，我们采用了target本身的类加载器。
第二个是把生成的动态代理对象下挂在哪些接口下，这个写法就是放在target实现的接口下。
第三个是定义实现方法逻辑的代理类，this表示当前对象，它必须实现InvocationHandler接口的invoke方法，它就是代理逻辑方法的现实方法。
​
***第二步，实现代理逻辑方法。***invoke方法可以实现代理逻辑，invoke方法的三个参数如下：
 Proxy,代理对象，就是bind方法生成的对象。 method，当前调度的方法。 args，调度方法的参数。  当我们使用了代理对象调度方法后，它就会进入到invoke方法里面。
Object obj =method.invoke(target,args); 这行代码相当于调度真实对象的方法，只是通过反射实现而已。
类比之前的例子，proxy相当于商务对象，target相当于软件工程师对象，bind方法是建立商务和软件工程师代理关系的方法。而invoke就是商务逻辑，它将控制软件工程师的访问。
测试JDK动态代理</description>
    </item>
    
    <item>
      <title>SSM第一章-入门和Redis</title>
      <link>https://zereals7.github.io/post/ssm/</link>
      <pubDate>Wed, 14 Apr 2021 21:56:15 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/ssm/</guid>
      <description>1.1 Spring框架 1.1.1 Spring IOC简介 IOC是一个容器，在Spring中，它会认为一切Java资源都是Java Bean,容器的目标就是管理这些Bean和它们之间的关系。
各个Java Bean之间会存在一定的依赖关系，容器能够对其进行管理。SPringIOC管理对象和依赖关系，采用的不是认为主动创建，而是SPring IOC自己通过描述创建的。
当需要某个实现类，可以通过配置实现依赖的注入 。这是一种被动的行为，控制权在IOC容器，它会根据描述找到使用者需要的资源。
当需要使用某个实现类时，通过配置信息就可以完成了。不需要用new来创建对象，依赖关系也可以通过配置完成，从而即插即拔地管理它们之间的关系。
总结：你不需要去找资源，只要向SPring IOC容器描述所需资源，SPring IOC自己会找到你需要的资源，这就是SPring IOC的理念。这样就把Bean之间的依赖关系解耦了，更容易写出结构清晰的程序。除此之外，SPring IOC还提供对Java Bean生命周期的管理，可以延迟加载，可以在其生命周期内定义一些行为等，更加方便有效地使用和管理Java资源，这就是SPring IOC的魅力。
1.1.2 SPring AOP IOC的目标时为了管理Java Bean,而Bean是Java面向对象的基础设计。但是，有些情况面向对象没办法处理。举个例子，生产部门的订单、生产部门、财务部门三者符合OOP的设计理念。订单发出，生产部门审批通过准备付款，但是财务部门发现订单的价格超支了，需要取消当你孤单。显然超支限定已经不只是影响财务部门了，还会影响生产部门之前所做的审批，需要把它们作废。我们把预算超支这个条件称为切面，它影响了订单、生产部门、财务部门三个OOP对象。在现实中，这样的切面条件跨越了3个甚至更多的对象，并且影响了它们的协作。所以只用OOP并不完善，还需要面向切面的编程，通过它去管理在切面上的某些对象的协作。
Spring AOP常用于数据库事务的编程，在默认的情况下，只要Spring接收到了异常信息，它会将数据库的事务回滚，从而保证数据的一致性。Spring提供了隔离级别和传播行为去控制复杂的事务。
1.2 MyBatis简介 MyBatis优势在于灵活，他几乎可以代替JDBC，同时提供了接口编程。目前MyBatis的数据访问层DAO是不需要实现类的，只需要一个接口和XML，或是注解。MyBatis提供自动映射，动态SQL、级联、缓存、注解、代码和SQL分离等特性。同时也可以对SQL进行优化。一位内具有封装少、映射多样化、支持存储过程、可以进行SQL优化等特点。
1.2.1 Hibernate简介 在MyBatis或者HIberNate中使用注解或者XML都是可以的。MyBatis中注解方式会受到一定的限制，所以MyBatis通常用XML方式实现映射关系。
我们把POJO对象和数据表相互映射的框架称为对象关系映射ORM。MyBatis和HIbernate都是ORM框架，只是Hibernate完全面向POJO，而前者不是。Hibernate基本不需要编写SQL就可以通过映射关系来操作数据库，是一种全表映射，而MyBatis不同，需要提供SQL去运行。
没有SQL是因为Hibernate会根据映射关系来生成对应的SQL。
1.2.2 Mybatis 在移动互联网时代，Mybatis是互联网Java持久框架的首选，与HIbernate消除SQL不同，MyBatis不屏蔽SQL。不屏蔽SQL的优势在于，程序员可以自己制定SQL规则，无须HIbernate自动生成规则，这样能够更加精确地定义SQL，从而优化性能。它更符合移动互联网、大数据、高并发、高性能、高响应的要求。
与HIbernate一样，MyBatis需要一个映射文件把POJO和数据库的表对应起来。
resultMap元素用于定义映射规则，Mybatis在满足一定规则下，完成自动映射。
mapper元素中的namespace属性，要和一个接口的全限定类名保持一致。里面的SQL的id也要和接口定义的方法保持完全一致。
定义了MyBatis的映射文件，就不再需要定义一个实现类。
Mybatis需要提供接口和SQL，意味着它的工作量会比HIbernate大，但是由于自定义SQL、映射关系，所以其灵活性、可优化性就超过了HIbernate。
1.2.3 HIbernate和MyBatis的区别 两者的增删查改对于业务逻辑层来说大同小异，对于映射层而言HIbernate的配置不需要接口和SQL，相反MyBatis是需要的。对于HIbernate而言，不需要编写大量的SQL就可以完全映射，同时提供了日志、缓存、级联等特性（级联比Mybatis强大）等特性，此外还提供了HQL对POJO操作，使用十分方便，但也有致命的缺陷。
由于无须SQL，当多表关联超过3个的时候，通过HIbernate的级联会造成太多的性能丢失，又或者我现在访问财务的表，然后它会关联财产信息表，财产又分为机械、原料等，显然机械和原料的字段不一样，这样关联的字段只能根据特定的条件变化而变化，而HIbernate无法支持这样的变化。遇到存储过程HIbernate只能作罢。
Mybatis可以自由书写SQL、支持动态SQL、处理列表、动态生成表名、支持存储过程。这样可以灵活定义查询语句，满足各类需求和性能优化的需要，这些在互联网系统中十分重要.
Mybatis也有缺陷。首先，要编写SQL和映射规则，其工作量稍微大于HIbernate。其次，支持的工具有限，不能像HIbernate那样有许多的插件可以帮助生成映射代码和关联关系，而即使使用生成工具，往往也需要开发者进一步简化，Mybatis通过手工编码，工作量相对大些。
所以对于性能要求不太苛刻的系统，比如管理系统、ERP等推荐HIbernate；而对于性能要求高、响应快、灵活的系统则推荐使用Mybatis。
1.3 Spring MVC简介 SPring MVC结构层次清晰，类比较简单，并且与SPring的核心IOC和AOP无缝对接。
MVC模式把应用程序分成不同的方面，同时提供这些元素的松耦合。
Model，封装了应用程序的数据和由它们组成的POJO
View，负责把模型数据渲染到视图上，将数据以一定的形式展现给用户。
Controller，负责处理用户请求，并建立适当的模型把它传递给试图渲染。
在SpringMVC中可以定义逻辑视图，通过其提供的试图解析器能够很方便地找到对应的视图进行渲染，或者使用其消息转换的功能，比如在Controller的方法内加入注解@ResponseBody后，SPring MVC就可以通过其消息转换系统，将数据转换为JSON，提供给前端Ajax请求使用。
SpriingMVC包括控制器、视图解析器、视图等重要内容。
1.4 最流行的NoSQL-Redis Redis是当前互联网最为流行的NoSQL。NoSQL在互联网系统中的作用很大，因为它可以在很大程度上提高互联网系统的性能。它具备一定持久层的功能，也可以作为一种缓存工具。对于NOSQL数据库而言，作为持久层，它存储的是半结构化的，这意味着计算机在读入内存中有更少的规则，读入速度更快。对于那些结构化、多范式规则的数据库系统而言，它更具性能优势。作为缓存，它可以支持大数据存入内存中，只要命中率高，就能快速响应，因为在内存中的数据读写比数据库读写磁盘的速度快几十上百倍。
Redis具有以下特点：
1、响应快速：Redis响应非常快，每秒课执行大约110000个写入操作，或者81000个读操作，其速度远超数据库。如果存入一些常用的数据，就能有效提高系统的性能。
2、支持6种数据结构：包括字符串、哈希结构、列表、集合、可排序集合和基数。比如对于字符串可以存入一些Java基础数据类型，哈希可以存储对象，列表可以存储List对象等。这使得在应用中很容易根据在自己的需要选择存储的数据类型，方便开发。既可以满足存储各种数据结构体的需要，又因为数据类型少，使得规则就少，需要的判断和裸机就少，这样读写速度就更快。
3、操作都是原子的：所有Redis的操作都是原子的，从而确保当两个客户同时访问Redis服务器时，得到的是更新后的值。在需要高并发的场合可以考虑使用Redis的事务，处理一些需要锁的事务。
4、MultiUtility工具：Redis可以在如缓存、消息传递队列中使用（支持“发布+订阅”的消息模式），在应用程序如Web应用程序会话、网站页面点击数等任何短暂的数据中使用。</description>
    </item>
    
    <item>
      <title>操作系统-进程与线程</title>
      <link>https://zereals7.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Sat, 10 Apr 2021 12:05:23 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</guid>
      <description>计算机上所有可运行的软件，通常也包括操作系统，被组织成若干顺序进程，简称进程。一个进程就是一个正在执行程序的实例，包括程序计数器，寄存器和变量的当前值。
从概念上来说，每个进程有自己的虚拟CPU。实际上真正的CPU在各进程间来回切换。
1、进程的创建 操作系统需要有一种方式来创建进程。
4种主要事件导致进程的创建：1、系统初始化 2、正在运行的程序执行了创建进程的系统调用 3、用户请求创建一个新进程 4、一个批处理作业的初始化
启动操作系统时，有些是前台进程，也就是与用户交互并且替他们完成工作的那些进程。其他的是后台进程，这些进程与特定的用户没有关系，却具有某些专门的功能。在大型系统中通常有很多守护进程，他们停留在后台，在请求到达时被唤醒。
从技术上看，新进程都是由于一个已存在的进程执行了一个用于创建进程的系统调用而创建的。这个进程可以是一个运行的用户进程、一个由键盘或鼠标启动的系统或者一个批处理管理进程。这个进程所做的工作是，执行一个用来创建新进程的系统调用。这个系统调用通知操作系统创建一个新进程，并且直接或间接地指定该进程中运行的程序。
UNIX系统中，只有一个系统调用可以用来创建新进程：fork。这个系统调用会创建一个与调用进程相同的副本。在调用了fork后，父进程和子进程拥有相同的内存映像、同样的环境字符串和同样的打开文件。
子进程接着执行execve或一个类似的系统调用，以修改其内存映像并运行一个新的程序。
当一个用户在shell中键入命令sort时，shell就创建一个子进程，然后，这个子进程执行sort。之所以要安排两步建立进程，是为了在fork之后但在execve之前允许该进程处理其文件描述符，这样可以完成对标准输入文件、标准输出文件和标准错误文件的重定向。
进程创建后，父进程和子进程有各自不同的地址空间。如果其中某个进程在其他地址空间修改了一个字，这个修改对其他进程而言是不可见的。在UNIX中。子进程的初始地址空间是父进程的一个副本，但是涉及两个不同的地址空间，不可写的内存区是共享的。某些UNIX的实现使程序正文在两者间共享，因为它不能被修改。或者，子进程共享父进程的所有内存，单这种情况下内存通过写时复制共享，这意味着一旦两者之一想要修改部分内存，则这块内存首先被明确的复制，以确保修改发生在私有内存区域。再次强调，可写的内存时不可以共享的。但是，对于一个新创建的进程而言，确实有可能共享其创建者的其他资源，诸如打开的文件等。在windows中，从一开始父进程的地址空间和子进程的地址空间就是不同的。
2、进程的终止 进程在创建之后，它开始运行，完成其工作。但永恒是不存在的，进程也一样。迟早这个新的进程会终止，通常由下列条件引起。
1、正常退出 2、出错退出 3、严重错误 4、被其他进程杀死
多数进程是由于完成了他们的工作而终止。
3、进程的层次结构 某些系统中，当进程创建了另一个进程后，父进程和子进程就以谋者形式继续保持关联。子进程自身可以创建更多的进程，组成一个进程的层次结构。进程只有一个父进程，但是可以有多个子进程。
在UNIX中，进程和它所有子进程以及后裔共同组成一个进程组。当用户从键盘发出一个信号时，该信号被送给当前与键盘相关进程组的所有成员。每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被该信号杀死。
一个称为init的特殊进程出现在启动映像中。当它开始运行时，读入一个说明终端数量的文件。接着，为每个终端创建一个新进程。这些进程等待用户登录。如果有一个用户登录成功，该登录进程就执行一个shell准备接收命令。所接受的这些命令会启动更多的进程，一次类推。这样在整个系统中，所有进程都属于以init为根的一棵树。
windows中没有进程层次的概念，所有进程都是地位相同的。唯一类似于进程层次的暗示是在创建进程的时候，父进程得到一个特别的令牌（称为句柄），该句柄可以用来控制子进程。但是它有权把这个令牌传送给某个其他进程，这样就不存在进程层次了。在UNIX中，进程不能剥夺其子线程的继承权。
4、进程的状态 每个进程是一个独立的实体，有自己的程序计数器和内部状态，但是，进程之间经常需要相互作用。一个进程的输出结果可能作为另一个进程的输入。进程有三种状态：1.运行态。该时刻进程实际占用CPU，啥都不缺。2.就绪态，可运行，但因为其他进程正在运行而暂时停止，缺CPU。3、阻塞态，除非某种外部事件发生，否则进程不能运行，缺资源，缺CPU。
前两中状态进程都可以运行，只是第二种状态暂时没有CPU分配给它。第三种状态与前两种状态不同，处于该状态的进程不能运行，即使CPU空闲也不行。
在操作系统发现进程不能运行下去时发生转换1.在某些系统，进程可以执行一个诸如pause的系统调用来进入阻塞状态。在其他系统，包括UNIX中，当一个进程从管道设备文件读取数据时，如果没有有效的输入存在，则进程会被自动阻塞。
转换2和3时由进程调度程序引起的，进程调度程序是操作系统的一部分，进程甚至感觉不到调度程序的存在。
当进程等待的一个外部事件发生时（如一些输入到达），则发生转换4.如果此时没有其他进程运行，则立即触发3转换3，该进程便开始运行。否则该进程将处于就绪态，等待CPU空闲并且轮到它运行。
操作系统的最底层是调度程序，在它上面有许多进程。所有关于中断处理、启动进程和停止进程的具体细节都隐藏在调度程序中。实际上，调度程序是一段非常短小的程序。操作系统的其他部分被简单地组织成进程的形式。不过，很少有真实的系统是以这样的理想方式构造的。
5、进程的实现 为了实现进程模型，操作系统维护者一张进程表（一个结构数组）。每个进程占用一个进程表项（进程控制块）。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开的文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。
![2021-04-1025 (Copy)](C:/Users/Zereal/Desktop/2021-04-1025 (Copy).jpg)
在了解进程表后，就可以对在单个CPU上如何维持多个顺序进程的错觉做更多的阐述。与每一IO类关联的是一个称作中断向量的位置（靠近内存底部的固定区域）。它包含中断服务程序的入口地址。
假设当一个磁盘中断发生时，用户进程3正在运行，则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈，计算机随后跳转到中断向量所指示的地址。这些是硬件完成的所有操作，然后软件，特别是中断服务例程就接管一切剩余的工作。
所有的中断都从保存寄存器开始，对于当前进程而言，通常是保存在进程表项中。
随后会从堆栈中删除由中断硬件机制存入堆栈的那部分信息，并将堆栈指针指向一个由进程处理程序所使用的临时堆栈。
一个进程在执行过程中可能被中断数千次，但关键是每次中断后，被中断的进程都返回到与中断发生前完全相同的状态。</description>
    </item>
    
    <item>
      <title>操作系统——引论</title>
      <link>https://zereals7.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Fri, 02 Apr 2021 18:22:48 +0800</pubDate>
      
      <guid>https://zereals7.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
      <description>完全基于《现代操作系统》第四版，摘取精华，掺杂个人理解。适用于自学党，和想要系统学习操作系统的人。
一、引论 1.为什么要有操作系统？操作系统的任务是什么？ 需求：现代计算机系统的组成极为复杂（处理器，主存，磁盘，输入输出设备&amp;hellip;）,应用程序员没有精力去掌握系统的所有细节。而且，管理这些部件并加以使用，是一件挑战性极强的工作。
所以计算机需要安装一层软件——操作系统。来满足这些需求。（注意：操作系统是系统软件，非应用软件）
任务：为用户程序提供一个更好、更简单、更清晰的计算机模型（操作系统）来实现对计算机所有设备的管理。
一言以蔽之，就是封装硬件运行和管理的细节，服务于上层的应用程序。
抽象是管理复杂性的一个关键，操作系统的任务就是创建好的抽象，并实现和管理它所创建的抽象对象。隐藏硬件，呈现给程序以及程序员良好/清晰/优雅/一致的抽象。
2.用户与操作系统交互的方式——用户接口程序 1.基于文本的——shell（命令行）
2.基于图标的——GUI（图形用户接口）
它们都属于用户接口程序，处于用户态程序中的最低层次。用户可以通过它们运行其他程序，如Web浏览器/音乐播放器等，这些程序也在大量使用操作系统。
3.操作系统内核态和用户态的区别 软件的最基础部分——操作系统，运行在内核态（也称管态，核心态）。核心态下，操作系统具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令。（为所欲为）
所以是有危险性的。
所以在用户态下，只使用了一部分机器指令，尤其是那些影响机器控制以及和IO操作有关系的指令，在用户态中的程序是禁止的。
4.操作系统所处的位置 由底层向上：硬件（裸机）——操作系统（软件，运行在内核态）——用户接口程序（软件，属于用户态最底层，靠近操作系统）——应用程序（软件，用户态）
总之，操作系统运行在裸机（纯硬件）之上，为其他所有软件提供基础的运行环境。
与普通软件的区别：操作系统软件不能被修改，受硬件保护，防止用户试图对其进行修改。
然而，在嵌入式系统（没有内核态）或解释系统（如基于Java的操作系统，它采用解释方式而非硬件方式区分组件）中，上述区别是模糊的。
操作系统一般比用户程序大型，复杂和长寿。（Linux和Windows内核源码都超过了500万行）
5.操作系统的实际用户——应用程序 应用程序直接与操作系统及其抽象打交道，而用户与用户接口所提供的抽象打交道（命令行shell或GUI）。虽然用户接口不同，但是操作系统下面的抽象是相同的。
6.操作系统是资源管理者——把潜在的混乱有序化 资源管理多路复用资源：在时间（CPU时间片）和空间（分割内存）上复用。
操作系统会分配CPU和内存，并协调管理使其有序，以提高运行的效率。
7.操作系统的历史 第一代：真空管和穿孔卡片 ——第二代：晶体管和批处理系统——第三代：集成电路和多道程序设计——第四代：个人计算机——第五代：移动计算机
8.处理器基础知识 CPU是计算机的大脑，它从内存中取出指令并且执行之。
三大流程：取指（从内存中）/解码（确定其类型和操作数）/执行
每个CPU都有特有的指令集，所以x86不能执行ARM程序，反之亦然。而且访存取指的时间比执行指令花费的时间长得多。因此。所有CPU的内部都有一些用来保存关键变量和临时数据的寄存器。
8.1 CPU中的寄存器介绍 除了用来保存变量和临时结果的通用寄存器外，还有一些程序员可见的专用寄存器。其中之一是程序计数器，它保存了将要取出的下一条指令的内存地址。
在取完指令后，程序计数器被更新以指向后继的指令。
另一个寄存器是堆栈指针，它指向内存中当前栈的顶端。该栈包含了每个执行过程的栈帧。一个过程的栈帧中保存了有关的输入参数、局部变量以及那些没有保存在寄存器中的临时变量。
当然还有程序状态字(PSW)寄存器。这个寄存器包含了条件码位、CPU优先级、模式（用户态或内核态），以及各种其他控制位。用户程序通常读入整个PSW，但是只对其中少量字段写入。在系统调用和I/O中，PSW的作用很重要。
操作系统必须知晓所有的寄存器。在时间多路复用CPU中，操作系统经常会中止正在运行的某个程序并再启动另一个程序，每次停止一个正在运行着的程序时，操作系统必须保存所有的寄存器值。这样在稍后该程序被再次运行时，可以把这些寄存器重新装入。
为了改善性能，现代CPU有同时取出多条指令的机制。例如，一个CPU可以有单独的取指单元、解码单元和执行单元，于是当它执行指令N时，可以对指令N+1进行解码，并且可以在内存读取指令N+2。这样的机制称为流水线。
一旦一条指令被取进流水线中，它就必须被执行完毕，即便前一条取出的指令是条件转移，它也必须被执行完毕。
还有更先进的**超标量CPU，有多个取指，解码，执行单元。**只要有一个执行单元空闲，就检查保持缓冲区中是否还有可处理的指令，如果有就把指令从缓冲区中移出并执行之。这种设计程序的指令经常不按顺序执行。多数情况下，硬件负责保证这种运算的结果与顺序执行指令时的结果相同，但是，仍然有部分令人烦恼的复杂情形被强加给操作系统处理（暂不讨论）。
在PSW中有一个二进制位控制CPU的内核态和用户态两种模式。内核态中运行的CPU可以执行指令集中的每一条指令，并且使用硬件的每种功能。值得一提的是，在台式机和服务器中，操作系统在内核态下运行，而在大多数嵌入式系统中，一部分操作系统运行在内核态，其余部分则运行在用户态。
相反**，用户程序在用户态下运行，仅允许执行指令集的一个子集和访问所有功能的一个子集**。一般而言，在用户态中有关IO和内存保护的所有指令是禁止的。当然，将PSW中的模式位设置成内核态也是禁止的。
为了从操作系统中获得服务，用户程序必须使用系统调用以陷入内核并调用操作系统。
只有TRAP指令能把用户态切换成内核态，并启用操作系统。在有关工作完成后，系统调用后面的指令把控制权返还给用户程序。
8.2 多线程和多核芯片 多线程允许CPU保持两个不同的线程状态，然后在纳秒级的时间尺度内来回切换。多线程不提供真正的并行处理。在同一时刻只有一个进程在运行，但是线程的切换时间则减少到纳秒数量级。
**GPU擅长处理大量并行的简单计算，比如在图像应用中渲染多边形。它们不太能胜任串行任务，并且很难编程。**虽然GPU对操作系统很有用（比如加密或者处理网络传输） ，但操作系统本身不太可能运行在GPU上。
8.3存储器 速度由快到慢：寄存器——高速缓存（Cache）——主存（RAM）——磁盘。每位成本也是由高到低。
缓存有利于改善性能。RAM具有电易失性，ROM则非易失。此外ROM速度快且便宜，用于启动计算机的引导加载模块就存放在ROM中。另外，一些I/O卡也采用ROM处理底层设备控制。
EEPROM和闪存也是非易失性的，与ROM相反，他们可以擦除和重写。不过重写比写入RAM要更高数量级的时间。
闪存速度介于RAM和磁盘之间。另外，与磁盘存储器不同，如果闪存擦除的次数过多，就被磨损了。
还有一类存储器是CMOS，它是易失性的。许多计算机利用CMOS存储器保持当前时间和日期。CMOS存储器和递增时间的时钟电路由一块小电池驱动，即使计算机没有上电，时间也可以正确的更新。CMOS存储器还可以保持配置参数。如哪一个是启动磁盘等。之所以采用CMOS是因为它电能消耗非常少，一块原装电池往往能使用数年。CMOS电池没电后，计算机将会不知道由哪个磁盘启动。
磁盘同RAM相比，每个二进制位的成本低了两个数量级。而且通常容量也大几个数量级。唯一的问题是访问数据时间大约慢了三个数量级。低速的原因是因为磁盘是一种机械装置。
磁盘有一个或多个金属盘片，以较高的速度旋转。信息写在磁盘一系列同心圆上。在任意一个给定臂的位置，每个磁头可以读取一段环形区域，称为磁道。把一个给定臂位置上的所有磁道合并起来，组成了一个柱面。
每个磁道划分为若干扇区，典型大小为512字节。现代磁盘中，较外的柱面拥有更多的扇区。机械臂从一个柱面移动到相邻的柱面大概需要1ms。而随机移到一个柱面的典型时间为5-10ms，具体时间取决于驱动器的转速。一旦所需要的扇区移到磁头之下，就开始读写。
固态硬盘没有可以移动的机械臂，是属于闪存，和磁盘同样具有非易失性。
虚拟内存机制：将程序放在磁盘上，将主存作为缓存，用来保存最频繁使用的部分程序。这种机制需要快速的映像内存地址，以便把程序生成的地址转换成为有关字节在RAM中的物理地址。这种映像由CPU中一个叫内存管理单元（MMU）的部件来完成。
缓存和MMU的出现对系统的性能有着重要的影响。在多道程序系统中，从一个程序切换到另一个程序，称为上下文切换。有必要对来自缓存的修改过的块进行写回磁盘的操作。并修改MMU中的映像寄存器。而上下文切换的代价很高，程序员应该努力避免这些操作。
8.4 I/O设备 I/O设备一般包括两个部分，设备控制器和设备本身。
控制器是插在电路板上的一块芯片和一组芯片，这块电路板物理地控制设备，从操作系统接受命令。控制器中一般存在一个小的嵌入式计算机。控制器的任务是为操作系统提供接口。
设备本身也有一个接口，但是功能比较简单。设备本身有个相对简单的接口，接口既不能做很多工作，又已经被标准化。实际的接口隐藏在控制器中。操作系统看到的是对控制器的接口，这个接口可能和设备接口有很大的差别。</description>
    </item>
    
    <item>
      <title>王道操作系统课程学习笔记</title>
      <link>https://zereals7.github.io/post/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zereals7.github.io/post/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-/</guid>
      <description>操作系统的概念功能和目标 裸机——操作系统
操作系统是计算机系统中最接近硬件的，一层最基本的系统软件。为上层应用软件提供了接口。
操作系统的功能与目标——作为系统资源的管理者
功能
 处理机管理 存储器管理 文件管理 设备管理  作为用户和计算机硬件之间的接口
 命令接口：允许用户直接使用  联机命令接口：说一句，做一句
脱机命令接口：说一堆，做一堆=批处理命令接口 （.bat文件）
 程序接口：通过程序间接使用  在程序中调用user32.dll，该过程即为系统调用，可实现创建窗口等功能，只能通过用户程序间接使用。
程序接口由一组系统调用组成（程序接口=系统调用=广义指令）
  图形用户接口（GUI）
三大接口统称为用户接口
  操作系统是最接近硬件的层次，实现了对硬件机器的扩展。
通常把覆盖了软件的机器称为扩充机器，也就是虚拟机。
形象比喻：
操作系统好比优秀的工匠，硬件就是：锤子、锯子、木头、钉子
操作系统对硬件的扩展：通过优秀工匠，讲简单的原料组成房子、帆船等等。普通用户可以直接使用工匠提供的房子，而无需关心这些东西在底层是怎么组织起来工作的。
操作系统的特征：并发，共享，虚拟，异步 并发和共享为最基本特征，且二者互为存在条件。
并发：当两个或多个时间在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。
并行：指两个或多个时间在同一时刻发生。
并发性：指计算机系统同时存在多个运行着的程序。
一个单核处理机同一时刻只能执行一个程序，因此操作系统会负责协调多个程序交替运行（这些程序微观上是交替执行的，但宏观上看起来就像是在同时执行）
事实上，操作系统上伴随着“多道程序技术”出现的，因此，操作系统和程序并发是一起诞生的。
对于4核心CPU，意味着同一时刻可以有4个程序并行执行，但是操作系统的并发性依然必不可少。
共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。
两种资源共享方式
  互斥共享方式
系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源。
  同时共享方式
  ​ 系统中的某些资源，允许一个时间段内多个进程同时对它们进行访问。
所谓的同时，往往是宏观上的，在微观上，这些进程可能是交替对该资源进行访问。当然微观上也是可以同时的：如打游戏时听音乐，对扬声器的占用。
例子
互斥共享方式：使用QQ和微信同时进行视频，同一时间段内摄像头只能分配给其中一个进程。
同时共享方式：用QQ发送文件A，同时使用微信发送文件B，宏观上看，两边都在同时读取并发送文件。说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。
并发与共享的关系
如果失去并发性，则系统中只有一个程序正在运行，则共享性也失去了意义。它们互为存在条件。
虚拟
虚拟是把一个物理上的实体变为若干逻辑上的对应物。物理实体是实际存在的，而逻辑上对应物，是用户感受到。
虚拟技术主要可分为
空分复用技术，如虚拟存储器技术
时分复用技术，如虚拟处理器
如果系统失去了并发性，则一段时间内系统中只许运行一道程序，那么就失去了实现虚拟下的意义了。因此，没有并发性就谈不上虚拟性。
异步
异步是指，在多道程序环境中，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。
显然，如果失去了并发性，则系统只能串行地处理各个进程，每个进程的执行会一贯到底。只有系统拥有并发性，才有可能导致异步性。操作系统的发展与分类 手工操作阶段</description>
    </item>
    
  </channel>
</rss>